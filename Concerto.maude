
fmod Declarations is  -------------declarations  
---including BOOL .
pr STRING .
sort Ident .
----subsort String < Ident .
----------------------------
------------pour ComponentType
sorts InitPlace Places Stations StationPlaces . --- identifiers for Transitionns and places
sorts Place Station StationPlace .

---subsort String  < InitPlace Place Station .
subsort InitPlace < Place .
sort ComponentType .

sort Transitionn .
sort Behavior .
sort TransitionnEnding .
sort Transitionns .
sort Behaviors .
sort TransitionnEndings .
---sort TransitionnsL .
sort BehaviorL .

sort ProPort .
sort ProPorts .
sort UsePort .
sort UsePorts .
sort Port .
sorts GUse GPro .
sorts GUses GPros . 
subsorts ProPort UsePort < Port .          --------------a verifier si toujours marche
-------------------------------------

sort Configuration .
sort Program .
sort Instances .
sort Instance . ---on garde les deux?
sort Connection .
sort Connections .
sort Instruction .


sort Marking .
sort Markings .


----------------subset
sort SubSetStation .
subsort SubSetStation < Stations .

sort SubSetTransitionn .
subsort SubSetTransitionn < Transitionns .

sort SubSetPlace .
subsort SubSetPlace < Places .

sort SubSetTansitionEnding .
subsort SubSetTansitionEnding < TransitionnEndings .

-------------------------




---------------------------------definition explicite de place et station a la supprision reactive subsort subsort String  < InitPlace Place Station .
ops id1 id2 id3 id4 : -> Ident .

op p1 : -> InitPlace .
op p2 : -> Place .
op p3 : -> Place .
op p4 : -> Place .
op p5 : -> Place .

op q1 : -> InitPlace .
op q2 : -> Place .
op q3 : -> Place .
op q4 : -> Place .

op y1 : -> InitPlace .
op y2 : -> Place .
op y3 : -> Place .
op y4 : -> Place .

op z1 : -> InitPlace .
op z2 : -> Place .

op s1 : -> Station .
op s2 : -> Station .
op s3 : -> Station .
op s4 : -> Station .
op s5 : -> Station .
op s6 : -> Station .
op s7 : -> Station .
op s4 : -> Station .
op r1 : -> Station .
op r2 : -> Station .
op r3 : -> Station .
op r4 : -> Station .

op w1 : -> Station .
op w2 : -> Station .
op w3 : -> Station .
op w4 : -> Station .
op w5 : -> Station .
op us1 : -> UsePort .
op us2 : -> UsePort .
op pr1 : -> ProPort .
op pr2 : -> ProPort .

op(_;_) : Station Place -> StationPlace . 
op (_!_) : UsePort Places -> GUse .
op (_?_) : ProPort Places -> GPro .

op (_,_,_,_) : Ident UsePort Ident ProPort -> Connection .





endfm
---------------------------------------------------------------------------------------------------------- end Declaration

---------------------------------------------Definition des views 

------------modifi view

view Place from TRIV to Declarations is
  sort Elt to Place .
endv

view StationPlace from TRIV to Declarations is
  sort Elt to StationPlace .
endv

view Station from TRIV to Declarations is
  sort Elt to Station .
endv
----------a supprimer lorsque rendre string

view Instance from TRIV to Declarations is
  sort Elt to Instance .
endv

view Transitionn from TRIV to Declarations is
  sort Elt to Transitionn .
endv

view Transitionns from TRIV to Declarations is
  sort Elt to Transitionns .
endv


view TransitionnEnding from TRIV to Declarations is
  sort Elt to TransitionnEnding .
endv

view Behavior from TRIV to Declarations is
  sort Elt to Behavior .
endv

view GUse from TRIV to Declarations is
sort Elt to GUse .
endv

view GPro from TRIV to Declarations is
 sort Elt to GPro .
endv


view Connection from TRIV to Declarations is
 sort Elt to Connection .
endv
 

------------------------------------------- End definition des views 

fmod ModInstancesAndrComponentType is 

pr Declarations .

protecting STRING .
protecting BOOL .
protecting INT .


pr SET{Transitionn} .
subsort Set{Transitionn} < Transitionns . 

pr LIST{Behavior} .
subsort List{Behavior} < BehaviorL . 

pr SET{TransitionnEnding} .
subsort Set{TransitionnEnding} < TransitionnEndings . 

---subsort Behavior < Transitionns .

pr SET{Behavior} .
subsort Set{Behavior} < Behaviors . 

pr SET{GUse} .
subsort Set{GUse} < GUses .

pr SET{GPro} .
subsort Set{GPro} < GPros .




-----------new modif
-----pr SET{String} . 
--- subsorts Set{String} <  Places Stations . 

pr SET{Place} . 
pr SET{Station} . 
pr SET{StationPlace} . 

subsort Set{Place} <  Places  . 
subsort Set{Station} <  Stations  . 
subsort Set{StationPlace} <  StationPlaces . 

-----end new modif
--------------------Marking
---subsort Places < Markings . 
---subsort Transitionns < Markings . 
---subsort TransitionnEndings < Markings .  
---pr SET{Marking} .
---subsort Set{Marking} < Markings . 


---pr SET{String} .

pr SET{Instance} .

subsort Set{Instance} < Instances .

pr SET{Connection} .
subsort Set{Connection} < Connections . 


---subsort Transitionns <  Behavior .  

-------les autres operation  Pi: la place d'une station, Transitionn t(,) , transirion ending te(,) ,  Behavior et ComponentType sans port

op Pi(_,_) : Station StationPlaces -> Place .
vars s ss2 ss1 : Station .
var SPs : StationPlaces .
var q : Place .

ceq Pi(ss1, ((ss2 ; q),SPs)) = q if(ss1 == ss2) .
ceq Pi(ss1, ((ss2 ; q),SPs)) = Pi(ss1,SPs) if(ss1 =/= ss2) .




op t(_,_) : Place Stations -> Transitionn .
op te(_,_) : Transitionn Station -> TransitionnEnding .
op b(_) : Transitionns -> Behavior .
----------
var trans : Transitionns .
op TransBeh(_) : Behavior -> Transitionns .
eq TransBeh(b(trans)) = trans .
----------- pour la regle ending behavior on a besoin d'une fonction pour trouver les places des Transitionns
var pla : Place .
vars S S1 : Stations .

op PlacesTrans(_) : Transitionns -> Places .
eq PlacesTrans(empty) = empty .
eq PlacesTrans(t(pla,S),trans) = pla, PlacesTrans(trans) .

-----------------------
---op m(_,_,_) : SubSetPlace SubSetTransitionn SubSetTansitionEnding -> Marking .   when we use subset the reduction term is impossble
op m(_,_,_) : Places Transitionns TransitionnEndings -> Marking .
-------------------
var pls : Places .
var tre : TransitionnEndings .
op PlMar : Marking -> Places .
op TrMar : Marking -> Transitionns .
op TrEnMar : Marking -> TransitionnEndings .

eq PlMar(m(pls,trans,tre)) = pls .
eq TrMar(m(pls,trans,tre)) = trans .
eq TrEnMar(m(pls,trans,tre)) = tre .
---------------------------
op < _,_,_,_,_,_,_ > : Places InitPlace StationPlaces Transitionns Behaviors GUses GPros -> ComponentType .

op InitialPlace(_) : ComponentType -> Place .


vars p pG : Places .
var st : StationPlaces .
vars t t1  : Transitionns . 
vars tes tes1 : TransitionnEndings .
var b : Behaviors .
var gu : GUses .
var gp : GPros .

eq InitialPlace (< p,q,st,t,b,gu,gp >) = q .

op GetStationPlaces(_) : ComponentType -> StationPlaces .

eq GetStationPlaces (< p,q,st,t,b,gu,gp >) = st .
-----------------------------------------------operation pour les instances

---op Q : -> List{Transitionns} .
op M : -> Marking .


op <_,_,_,_> : Ident ComponentType BehaviorL Marking -> Instance .

--------------------------------------------operations active  et refusing 



----------------------fonctions suplemnetaire
var por : Port . 
vars poru up : UsePort .
vars porp pp : ProPort .
---op (_!_) : UsePort Places -> GUse .
---op (_?_) : ProPort Places -> GPro .

op G(_,_) : Port ComponentType -> Places .
op PlaceUse(_,_) : Port GUses -> Places .
op PlacePro(_,_) : Port GPros -> Places .
eq G(poru,< p,q,st,t,b,gu,gp > ) = PlaceUse(poru,gu)  .
eq G(porp,< p,q,st,t,b,gu,gp > ) = PlacePro(porp,gp)  .

ceq PlaceUse(poru,(up ! p),gu) = p if (poru == up) . 
ceq PlaceUse(poru,(up ! p),gu) = PlaceUse(poru,gu) if (poru =/= up) . 
eq PlaceUse(poru,empty) = empty . 

ceq PlacePro(porp,(pp ? p),gp) = p if (porp == pp) . 
ceq PlacePro(porp,(pp ? p),gp) = PlacePro(porp,gp) if (porp =/= pp) . 
eq PlacePro(porp,empty) = empty . 

-----fonction elements
op elements(_,_) : Places ComponentType -> Marking .
op TranElt(_,_,_) : Places Transitionns Stations -> Transitionns .        
op TranEndElts(_) : Transitionns -> TransitionnEndings .
op TranEndElt(_,_) : Transitionn Stations -> TransitionnEndings .
op EndingStationsGroup(_,_) : Stations  Stations -> Bool .

ceq EndingStationsGroup((s,S),S1) = EndingStationsGroup(S,S1) if (s in S1) .
ceq EndingStationsGroup((s,S),S1) = false if (not (s in S1)) .
eq EndingStationsGroup(empty,S1) = true .

eq TranEndElt(t(q,S), s,S1)= union(te(t(q,S),s), TranEndElt(t(q,S), S1) ) .
eq TranEndElt(t(q,S),empty) = empty .

eq TranEndElts(t(q,S),t) = union(TranEndElt(t(q,S),S), TranEndElts(t) ) .
eq TranEndElts(empty) = empty .
------------selection only station that end in the eleent of ExitGroupPlac
op StationsGplaces(_,_) : Places StationPlaces -> Stations .

ceq StationsGplaces(p,(s ; q),st) = s, StationsGplaces(p,st) if(q in p) .
ceq StationsGplaces(p,(s ; q),st) =  StationsGplaces(p,st) if(not(q in p)) .
eq StationsGplaces(p,empty) = empty .
------------------------------------------------------------------
eq elements(pG,< p,q,st,t,b,gu,gp >) = m( pG, TranElt(pG,t,StationsGplaces(pG,st)), TranEndElts(TranElt(pG,t,StationsGplaces(pG,st))) ) .
ceq TranElt(pG,t(q,S),t,S1) = t(q,S),TranElt(pG,t,S1) if (q in pG and (EndingStationsGroup(S,S1))) .
ceq TranElt(pG,t(q,S),t,S1) = TranElt(pG,t,S1) if (not (q in pG and (EndingStationsGroup(S,S1)))) .
eq TranElt(pG,empty,S1) = empty .

op  IntersectionMarking(_,_) : Marking Marking -> Marking .
eq  IntersectionMarking( m(p,t,tes),m(pG,t1,tes1)) = m(intersection(p,pG),intersection(t,t1),intersection(tes,tes1)) .

op NotEmptyMarking(_) : Marking -> Bool .
eq NotEmptyMarking(m(p,t,tes)) = (p =/= empty or t =/= empty or tes =/= empty ) .
----------------------------------

op active(_,_) : Instance Port -> Bool . 


vars identI identII : Ident .
var c : ComponentType .
var bl : BehaviorL .
var mm : Marking .


op IdentInstance(_) : Instance -> Ident .
eq IdentInstance(< identI,c,bl,mm > ) = identI .

eq active(< identI, < p,q,st,t,b,gu,gp > ,bl,m(pls,trans,tre) >,por) = NotEmptyMarking(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))) .

------------- fonctions pour refusing

op AllExitGroup(_,_,_,_) : Places Transitionns Places StationPlaces -> Bool .
op ExitGroupPlace(_,_,_,_) : Place Transitionns Places StationPlaces -> Bool .
op ExistSourceTranPlace(_,_) : Place Transitionns -> Bool .
op AllTranQuitGroupPlace(_,_,_,_) : Place Transitionns Places StationPlaces -> Bool .
op EndingStationsNotGroup(_,_,_) : Stations Places StationPlaces -> Bool .
eq AllExitGroup((q,p),t,pG,st)  = ExitGroupPlace(q,t,pG,st) and AllExitGroup(p,t,pG,st) .
eq AllExitGroup(empty,t,pG,st) = true .
eq ExitGroupPlace(q,t,pG,st) = ExistSourceTranPlace(q,t) and AllTranQuitGroupPlace(q,t,pG,st) . 

ceq  ExistSourceTranPlace(q,t(p,S),t1) = true if (p == q ) .
ceq  ExistSourceTranPlace(q,t(p,S),t1) = ExistSourceTranPlace(q,t1) if (p =/= q ) .
eq   ExistSourceTranPlace(q,empty) = false .

ceq AllTranQuitGroupPlace(q,t(p,S),t1,pG,st) = AllTranQuitGroupPlace(q,t1,pG,st) if (p =/= q) .
eq AllTranQuitGroupPlace(q,empty,pG,st) = true .
ceq AllTranQuitGroupPlace(q,t(p,S),t1,pG,st) = AllTranQuitGroupPlace(q,t(p,S),t1,pG,st) if (p == q and  EndingStationsNotGroup(S,pG,st)) .
ceq AllTranQuitGroupPlace(q,t(p,S),t1,pG,st) = false if (p == q and  not EndingStationsNotGroup(S,pG,st)) .

ceq EndingStationsNotGroup(s,S,pG,st) = EndingStationsNotGroup(S,pG,st) if (not (Pi(s,st) in pG)) .
ceq EndingStationsNotGroup(s,S,pG,st) = false if ((Pi(s,st) in pG)) .
eq EndingStationsNotGroup(empty,pG,st) = true .


op refusing(_,_) : Instance Port -> Bool .

ceq refusing(< identI, < p,q,st,t,b,gu,gp > ,b(t1) bl,m(pls,trans,tre) >,por) = true if
(
TrMar(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))) == empty and 
TrEnMar(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))) == empty and 
AllExitGroup(PlMar(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))),t1,G(por,< p,q,st,t,b,gu,gp >),st)

)  .

eq refusing(< identI, < p,q,st,t,b,gu,gp > ,b(t1) bl,m(pls,trans,tre) >,por) = false [owise] .

---------------------------------------operation pour Configuration

op add(_,_) : Ident ComponentType -> Instruction .
op del(_) : Ident -> Instruction .
op pushB(_,_) : Ident Behavior -> Instruction .
op con(_,_,_,_) : Ident UsePort Ident ProPort -> Instruction .
op dcon(_,_,_,_) : Ident UsePort Ident ProPort -> Instruction .
op wait(_) : Ident -> Instruction .
op [] : -> Program [ctor] .
op _._ : Instruction Program -> Program [ctor] .
op < (_,_),_ > : Instances Connections Program -> Configuration . --- conf simplifie a  Instances et Program


---- determiner l'instance associe a ident
op InstanceIdent(_,_) : Instances Ident -> Instance . 
vars iden id : Ident .
var contcomp : ComponentType .
var behL : BehaviorL .
var mark : Marking .
var I : Instances .
ceq  InstanceIdent((< iden,contcomp,behL,mark > ,I) , id ) = < iden,contcomp,behL,mark > if (iden == id) .
eq  InstanceIdent((< iden,contcomp,behL,mark > ,I) , id ) =  InstanceIdent(I,id) [owise] .



----------------------------------------------------operation used in rules ----------------------------------------------

-----------------operations and equations of PushingBehavior
op IsBehaviorOfComponent(_,_) : Behavior ComponentType -> Bool .
vars beh beh1  : Behavior .

eq IsBehaviorOfComponent(beh,< p,q,st,t,b,gu,gp >) = beh in b .
---ceq IsBehaviorOfComponent(beh,< p,q,st,t,beh1,b,gu,gp >) = true if (beh1 == beh)  .
---ceq IsBehaviorOfComponent(beh,< p,q,st,t,beh1,b,gu,gp >) = IsBehaviorOfComponent(beh,< p,q,st,t,b,gu,gp >) if (beh1 =/= beh)  .
---eq IsBehaviorOfComponent(beh,< p,q,st,t,empty,gu,gp >) = false .


---------------operations and equations of ConnectPorts
var  LL : Connections .
vars uus1 uus : UsePort .
var ppr2 : ProPort .
vars iid iid1 iid2 : Ident .
op InConnectionIdentUsePort(_,_,_) :  Ident UsePort Connections -> Bool .

ceq InConnectionIdentUsePort(iid,uus,((iid1,uus1,iid2,ppr2),LL)) = true if (iid1 == iid and uus1 == uus) .
ceq InConnectionIdentUsePort(iid,uus,((iid1,uus1,iid2,ppr2),LL)) = InConnectionIdentUsePort(iid,uus,LL) if (iid1 =/= iid or uus1 =/= uus) .
eq  InConnectionIdentUsePort(iid,uus,empty) = false .

------------operations and equations of DeleteCompoenentInstance

op InConnectionIdent(_,_) :  Ident Connections -> Bool .

ceq InConnectionIdent(iid,((iid1,uus1,iid2,ppr2),LL)) = true if (iid1 == iid or iid2 == iid) .
ceq InConnectionIdent(iid,((iid1,uus1,iid2,ppr2),LL)) = InConnectionIdent(iid,LL) if (iid1 =/= iid and iid2 =/= iid) .
eq  InConnectionIdent(iid,empty) = false .

----------------operations and equation of AddComponentInstance
op IsUsedIdentInstances(_,_) : Ident Instances -> Bool .
var Is : Instances .

ceq IsUsedIdentInstances(identII, < identI,c,bl,mm >, Is) = true if (identII == identI) .
ceq IsUsedIdentInstances(identII, < identI,c,bl,mm >, Is) = IsUsedIdentInstances(identII, Is) if (identII =/= identI) .
eq IsUsedIdentInstances(identII, empty) = false .

-------------- operations and equation of EnteringPlace


op RemoveTransitionnEndingStation(_,_) : TransitionnEndings Station -> TransitionnEndings .
op IsSatisfiedTransitionnEndingStation(_,_,_) : Station Transitionns TransitionnEndings -> Bool .

var ss : Station .
ceq IsSatisfiedTransitionnEndingStation(s,t(q,S),t,tes) = false 
if( (s in S) and (not(te(t(q,S),s) in tes)) ) .
ceq IsSatisfiedTransitionnEndingStation(s,t(q,S),t,tes) = IsSatisfiedTransitionnEndingStation(s,t,tes) 
if(not(s in S) or (te(t(q,S),s) in tes) ) .
eq IsSatisfiedTransitionnEndingStation(s,empty,tes) = true .

ceq RemoveTransitionnEndingStation(te(t(q,S),s),tes,ss) = te(t(q,S),s),RemoveTransitionnEndingStation(tes,ss)
if (s =/= ss) .
ceq RemoveTransitionnEndingStation(te(t(q,S),s),tes,ss) = RemoveTransitionnEndingStation(tes,ss)
if (s == ss) .
eq RemoveTransitionnEndingStation(empty,ss) = empty .



op GetUsePort(_) : ComponentType -> GUses .
eq GetUsePort (< p,q,st,t,b,gu,gp >) = gu .

op ProvidedAllowed(_,_,_,_,_,_) : Place GUses Instance Instance Instances Connections -> Bool . 
vars i1 i2 : Instance .
---vars poru up : UsePort . 
ceq ProvidedAllowed(q,(up ! p),gu,i1,i2,Is,LL) = ProvidedAllowed(q,gu,i1,i2,Is,LL) if (not (q in p)) .
ceq ProvidedAllowed(q,(up ! p),gu,i1,i2,Is,LL) = Provided(up,IdentInstance(i1),Is,LL) and Allowed(up,i1,i2,Is,LL) 
and ProvidedAllowed(q,gu,i1,i2,Is,LL) if  (q in p) .
eq ProvidedAllowed(q,empty,i1,i2,Is,LL) = true .

op Provided(_,_,_,_) : UsePort Ident  Instances Connections -> Bool . 
op Allowed(_,_,_,_,_) : UsePort  Instance Instance Instances Connections -> Bool . 
---var prou : UsePort
var IdentIns : Ident .
ceq Provided(poru,IdentIns,Is,(iid1,up,iid2,pp),LL) = Provided(poru,IdentIns,Is,LL)
if (poru =/= up or iid1 =/= IdentIns) .
ceq Provided(poru,IdentIns,Is,(iid1,up,iid2,pp),LL) = active(InstanceIdent(Is,iid2),pp)
if (poru == up and iid1 == IdentIns) .
eq Provided(poru,IdentIns,Is,empty) = false .

ceq Allowed(poru,i1,i2,Is,(iid1,up,iid2,pp),LL) = Allowed(poru,i1,i2,Is,LL)
if (poru =/= up or iid1 =/= IdentInstance(i1)) .

ceq Allowed(poru,i1,i2,Is,(iid1,up,iid2,pp),LL) = (refusing(InstanceIdent(Is,iid2),pp) and (not active(i1,up)) implies not active(i2,up) ) 

and Allowed(poru,i1,i2,Is,LL) if (poru == up and iid1 == IdentInstance(i1)) .

eq Allowed(poru,i1,i2,Is,empty) = true .







endfm 






---con(id1, u, id2, p)
----------------Initialisation

fmod InitMod is

pr ModInstancesAndrComponentType .

ops c0 c00 c1 c2 c3 c4 c11 c22 : -> ComponentType .
ops Fig1 Fig2 conf0 conf1 conf2 conf3 : -> Configuration .


eq c11 =  < (p1, p2, p3) , p1 , (s1 ; p1, s2 ; p2, s3 ; p3), (t(p1, s2), t(p2, s3),t(p3, s1) ), (b(t(p2, s3),t(p1, s2)), b(t(p3, s1))) , us1 ! (p2, p3), empty   > .
eq c22 =  < (q1, q2, q3) , q1 , (r1 ; q1, r2 ; q2, r3 ; q3), (t(q1, r2), t(q2, r3),t(q3, r2) ), (b(t(q2, r3),t(q1, r2)),b(t(q3, r2))) , empty, pr1 ? (q3) > .

eq c0  =  < (p1, p2, p3, p4) , p1 , (s1 ; p1, s2 ; p2, s3 ; p3, s4 ; p3),(t(p1, s2),  t(p1, s3,s4),t(p2,  s3,s4)), b(t(p1, s2), t(p1, s3,s4),t(p2,  s3,s4)) , empty, empty   > .


eq c00  =  < (p1, p2, p3, p4) , p1 , (s1 ; p1, s2 ; p2, s3 ; p3, s5 ; p4),(t(p1, s2),
 t(p1, s3),t(p2,  s3),t(p3, s5) ), (b(t(p1, s2), t(p1, s3),t(p2,  s3)), b(t(p3, s5))) , empty, empty   > .


eq c11 =  < (p1, p2, p3) , p1 , (s1 ; p1, s2 ; p2, s3 ; p3), (t(p1, s2), t(p2, s3),t(p3, s1) ), (b(t(p2, s3),t(p1, s2)), b(t(p3, s1))) , us1 ! (p2, p3), empty   > .
eq c22 =  < (q1, q2, q3) , q1 , (r1 ; q1, r2 ; q2, r3 ; q3), (t(q1, r2), t(q2, r3),t(q3, r2) ), (b(t(q2, r3),t(q1, r2)),b(t(q3, r2))) , empty, pr1 ? ( q3, p2) > .
eq conf3 = < (empty, empty) , add(id1,c11) . add(id2,c22) . con(id1,us1,id2,pr1).  pushB(id2,b(t(q1, r2), t(q2, r3))) . 
  pushB(id1,b(t(p1, s2), t(p2, s3))) . wait(id1)  .  pushB(id2,b(t(q3, r2))) .  pushB(id1,b(t(p3, s1))) . [] >  .



eq c0  =  < (p1, p2, p3) , p1 , (s1 ; p1, s2 ; p2, s3 ; p3, s4 ; p3), (t(p1, s2), t(p1, s3,s4),t(p2,  s3,s4)), b(t(p1, s2), t(p1, s3,s4),t(p2,  s3,s4)) , empty, empty   > .
eq c00  =  < (p1, p2, p3) , p1 , (s1 ; p1, s2 ; p2, s3 ; p3), (t(p1, s2), t(p1, s3),t(p2,  s3) ),(b(t(p1, s2), t(p1, s3),t(p2,  s3))) , empty, empty   > .


eq Fig1 = < (empty, empty) , add(id1,c0)  . pushB(id1,b(t(p1, s2), t(p1, s3,s4),t(p2,  s3,s4))) . [] >  .

eq Fig2 = < (empty, empty) , add(id1,c00)  . pushB(id1,b(t(p1, s2), t(p1, s3),t(p2,  s3)))   . [] >  .

eq conf1 = < (empty, empty) , add(id1,c11) . add(id2,c22) . con(id1,us1,id2,pr1).  
  pushB(id1,b(t(p1, s2), t(p2, s3))) . wait(id1)  .  pushB(id2,b(t(q3, r2)))  . [] >  .

eq conf2 = < (empty, empty) , add(id1,c11) . add(id2,c22) . con(id1,us1,id2,pr1).  pushB(id2,b(t(q1, r2), t(q2, r3))) . 
  pushB(id1,b(t(p1, s2), t(p2, s3))) . wait(id1)  .  pushB(id2,b(t(q3, r2)))  . [] >  .









endfm


mod OperationalSemantics is

pr InitMod .



var R : Program .
var I : Instances . 
vars L L1 : Connections .
---var l : Connection .
vars id idd1 idd2 : Ident .
vars ct ctt : ComponentType .
vars qb : BehaviorL .
var b : Transitionns .
var m : Marking .
var inst : Instance .

var ps : Places .
var ts : Transitionns .
var tr : Transitionn .
vars tes tes1 : TransitionnEndings .

var use : UsePort .
var pro : ProPort .
---var gu : GUses .
---var gp : GPros .

var p : Place .

---Evolution of Components
---m(p1,empty,empty)
ops i ii : -> Instance .


op mar : -> Marking .
op ccc : -> ComponentType .




var q : Place .
var t : Transitionn .
var S : Stations .
var s : Station .
var Ts : Transitionns .


op restrict(_,_) : Transitionns Place -> Transitionns .
eq restrict(empty,p) = empty .
ceq restrict((t(q,S),Ts),p) = restrict(Ts,p) if (q =/= p) .
ceq restrict(t(q,S),Ts,p) = t(q,S), restrict(Ts,p) if (q == p) .

--- l'ensemble de connexion L' relatives a un ident
***(
op ConnectionProIdent(_,_) : Ident Connections -> Connections .

ceq ConnectionProIdent(id , ((id1,use,id2,pro),L)) = (id1,use,id2,pro), ConnectionProIdent(id , L) if(id2 == id) .
ceq ConnectionProIdent(id , ((id1,use,id2,pro),L)) = ConnectionProIdent(id , L) if(id2 =/= id) .
eq ConnectionProIdent(id , empty) = empty .

)
op ConnectionProIdent(_,_) : Connections Ident -> Connections .

ceq ConnectionProIdent(((idd1,use,idd2,pro),L),id) = (id1,use,idd2,pro), ConnectionProIdent(L,id) if(idd2 == id) .
ceq ConnectionProIdent(((idd1,use,idd2,pro),L),id) = ConnectionProIdent(L,id) if(idd2 =/= id) .
eq ConnectionProIdent(empty,id) = empty .


---- determiner l'instance associe a ident
op InstanceIdent(_,_) : Instances Ident -> Instance . 
var iden : Ident .
---var ct : ComponentType .
var bl : BehaviorL .
---var m : Marking .

ceq  InstanceIdent((< iden,ct,bl,m > ,I) , id ) = < iden,ct,bl,m > if (iden == id) .
eq  InstanceIdent((< iden,ct,bl,m > ,I) , id ) =  InstanceIdent( I , id ) [owise] .

op ConsistencyPort(_,_,_) : Instance Instances Connections ->  Bool .
eq ConsistencyPort(inst,I,(idd1,use,idd2,pro),L) = ConsistencyPort(inst,I,L) and (active(InstanceIdent(I,id1),use) implies active(inst,pro)  ).
eq ConsistencyPort(inst,I,empty) = true .




------------------------------------------------------------------------------------------Rules----------------------------------------------------------------------
----------------------------------------------------------------------------------Evolution of Components-------------------------------------------------------------------

crl [FiringTransitionns] : < ( < idd1,ct,b(b) qb,m(p, ps,ts,tes) > , I, L),  R > 
=>   < (  < idd1,ct,b(b) qb,m(ps,union(ts, restrict(b,p) ),tes) >, I , L), R > 
if (restrict(b,p) =/= empty and ConsistencyPort(< idd1,ct,b(b) qb,m(ps,union(ts, restrict(b,p) ),tes) >,I,ConnectionProIdent(L, idd1 ))) .  

rl [EndingTransitionn] : < ( < idd1,ct,qb,m(ps, t(q,s,S), ts,tes) > , I, L),  R > 
=>  < ( < idd1,ct,qb,m(ps, ts, te(t(q,s,S),s), tes  ) > , I, L),  R >  .  

---------a revoir le marquage de place apres entree place ps normalement ps union nouveau marquage a voir
crl [EnteringPlace] : < ( < idd1,ct,b(b) qb,m(ps, ts, te(t(q,s,S),s), tes  ) > , I, L),  R > 
=>  < ( < idd1,ct,b(b) qb,m(Pi(s,GetStationPlaces(ct)), ts, RemoveTransitionnEndingStation(tes,s) ) > , I, L),  R > 
if (IsSatisfiedTransitionnEndingStation(s,b,te(t(q,s,S),s), tes) and 
ProvidedAllowed (Pi(s,GetStationPlaces(ct)), GetUsePort(ct), < idd1,ct,b(b) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >,
< idd1,ct,b(b) qb,m(Pi(s,GetStationPlaces(ct)), ts, RemoveTransitionnEndingStation(tes,s) ) >,I, L)) .  

crl [FinishingBehavior] : < ( < idd1,ct,b(b) qb,m(ps, empty, empty) > , I, L),  R > 
=>  < ( < idd1,ct, qb,m(ps, empty, empty) > , I, L),  R >  if (intersection(ps,PlacesTrans(b)) == empty) .  

------------------------------------------------------------------------------------ Instructions of program------------------------------------------------------------------------- 

crl [AddComponentInstance] :  < ( I, L), add(id, ct) . R > 
=>   < (insert( < id, ct, nil, m(InitialPlace(ct) ,empty,empty)  > , I), L), R > if (not IsUsedIdentInstances(id,I)) .  

crl [DeleteComponentInstance] : < ( < idd1,ct,qb,m > , I, L), del(id) . R > 
=>   < ( I , L), R > if (id == idd1 and (not InConnectionIdent(id,L)) ) . 

crl [ConnectPorts] : < ( I, L), con(id,use,idd1,pro) . R > 
=>   < ( I , (id,use,idd1,pro),L), R > 
if (id =/= idd1 and (InstanceIdent(I,id) in I) and (InstanceIdent(I,idd1) in I) and (not InConnectionIdentUsePort(id,use,L)) ) . 

crl [DisconnectPorts] : < ( I, L), dcon(id,use,idd1,pro) . R > 
=>   < ( I , delete((id,use,idd1,pro),L)), R > if (not active(InstanceIdent(I,id),use)) . 

crl [PushingBehavior] : < ( < idd1,ct,qb,m > , I, L), pushB(id, b(b)) . R > 
=>   < (  < idd1,ct,append(qb,b(b)),m >, I , L), R > if (id == idd1 and IsBehaviorOfComponent(b(b),ct)) .  

crl [Waiting] : < ( < idd1,ct,nil,m > , I, L), wait(id) . R > 
=>   < ( < idd1,ct,nil,m > , I, L), R > if (idd1 == id) . 


endm

***(
mod Concerto-PREDS is 
 protecting OperationalSemantics . 
 including SATISFACTION .
 subsort Configuration < State .
 ops activeUs1 activePr1 :  -> Prop .
 op AccessibleStateP3 : -> Prop .

 var i1 : Instance .
 var I : Instances .
 var L : Connections .
 var R : Program .
 var Q : Prop .
 
 
 var ct : ComponentType .
 var bl : BehaviorL .
 var p : Places .
 var te : Transitionns .
var tes : TransitionnEndings .


 eq < ( < "id1",ct,bl,m(p3, p,te,tes) > ,I, L),  R >  |= AccessibleStateP3  = true .
 ceq < ( I, L),  R >  |= activeUs1 = true if(active(InstanceIdent(I,"id1"),us1)) .
 ceq < ( I, L),  R >  |= activePr1 = true if(active(InstanceIdent(I,"id2"),pr1)) .
 eq < (I, L),  R > |= Q = false [owise] . 
endm
mod Concerto-CHECK is 
 protecting Concerto-PREDS . 
 including MODEL-CHECKER . 
 including LTL-SIMPLIFIER . 
endm


--- red modelCheck(initial, [] ( activeUs1 -> activePr1 )) .


---red modelCheck(Fig1, <> AccessibleStateP3  ) .
---red modelCheck(Fig2, <> AccessibleStateP3  ) .

)

