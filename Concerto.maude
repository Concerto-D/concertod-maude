


fmod Declarations is  ----------------------------------------------------------------------------------------declarations  

pr STRING .
sort Ident .
subsort String < Ident .
----------------------------
------------pour ComponentType
sorts InitPlace Places Stations . --- identifiers for transitions and places
sorts Place Station .

---subsort String  < InitPlace Place Station .
subsort InitPlace < Place .
sort ComponentType .

sort Transition .
sort Behavior .
sort TransitionEnding .
sort Transitions .
sort Behaviors .
sort TransitionEndings .
---sort TransitionsL .
sort BehaviorL .

sort ProPort .
sort ProPorts .
sort UsePort .
sort UsePorts .
sort Port .
sorts GUse GPro .
sorts GUses GPros . 
subsorts ProPort UsePort < Port .          --------------a verifier si toujours marche
-------------------------------------

sort Configuration .
sort Program .
sort Instances .
sort Instance . ---on garde les deux?
sort Connection .
sort Connections .
sort Instruction .


sort Marking .
sort Markings .


----------------subset
sort SubSetStation .
subsort SubSetStation < Stations .

sort SubSetTransition .
subsort SubSetTransition < Transitions .

sort SubSetPlace .
subsort SubSetPlace < Places .

sort SubSetTansitionEnding .
subsort SubSetTansitionEnding < TransitionEndings .

-------------------------




---------------------------------definition explicite de place et station a la supprision reactive subsort subsort String  < InitPlace Place Station .
op p1 : -> InitPlace .
op p2 : -> Place .
op p3 : -> Place .
op p4 : -> Place .

op q1 : -> InitPlace .
op q2 : -> Place .
op q3 : -> Place .
op q4 : -> Place .

op z1 : -> InitPlace .
op z2 : -> Place .

op s1 : -> Station .
op s2 : -> Station .
op s3 : -> Station .
op s4 : -> Station .

op r1 : -> Station .
op r2 : -> Station .
op r3 : -> Station .
op r4 : -> Station .

op w1 : -> Station .
op w2 : -> Station .
op w3 : -> Station .
op w4 : -> Station .

op us1 : -> UsePort .
op us2 : -> UsePort .
op pr1 : -> ProPort .
op pr2 : -> ProPort .

op (_!_) : UsePort Places -> GUse .
op (_?_) : ProPort Places -> GPro .

op (_,_,_,_) : Ident UsePort Ident ProPort -> Connection .

endfm
---------------------------------------------------------------------------------------------------------- end Declaration

---------------------------------------------Definition des views 

------------modifi view

view Place from TRIV to Declarations is
  sort Elt to Place .
endv

view Station from TRIV to Declarations is
  sort Elt to Station .
endv

----------a supprimer lorsque rendre string

view Instance from TRIV to Declarations is
  sort Elt to Instance .
endv

view Transition from TRIV to Declarations is
  sort Elt to Transition .
endv

view Transitions from TRIV to Declarations is
  sort Elt to Transitions .
endv


view TransitionEnding from TRIV to Declarations is
  sort Elt to TransitionEnding .
endv

view Behavior from TRIV to Declarations is
  sort Elt to Behavior .
endv

view GUse from TRIV to Declarations is
sort Elt to GUse .
endv

view GPro from TRIV to Declarations is
 sort Elt to GPro .
endv

view Connection from TRIV to Declarations is
 sort Elt to Connection .
endv
 

------------------------------------------- End definition des views 

fmod ModInstancesAndrComponentType is 

pr Declarations .

protecting STRING .
protecting BOOL .
protecting INT .


pr SET{Transition} .
subsort Set{Transition} < Transitions . 

pr LIST{Behavior} .
subsort List{Behavior} < BehaviorL . 

pr SET{TransitionEnding} .
subsort Set{TransitionEnding} < TransitionEndings . 

---subsort Behavior < Transitions .

pr SET{Behavior} .
subsort Set{Behavior} < Behaviors . 

pr SET{GUse} .
subsort Set{GUse} < GUses .

pr SET{GPro} .
subsort Set{GPro} < GPros .




-----------new modif
-----pr SET{String} . 
--- subsorts Set{String} <  Places Stations . 

pr SET{Place} . 
pr SET{Station} . 

subsort Set{Place} <  Places  . 
subsort Set{Station} <  Stations . 

-----end new modif
--------------------Marking
---subsort Places < Markings . 
---subsort Transitions < Markings . 
---subsort TransitionEndings < Markings .  
---pr SET{Marking} .
---subsort Set{Marking} < Markings . 


pr SET{String} .

pr SET{Instance} .

subsort Set{Instance} < Instances .

pr SET{Connection} .
subsort Set{Connection} < Connections . 


---subsort Transitions <  Behavior .  

-------les autres operation  Pi: la place d'une station, Transition t(,) , transirion ending te(,) ,  Behavior et ComponentType sans port

op Pi(_) : Station -> Place .

eq Pi(s1) = p1 .
eq Pi(s2) = p2 .
eq Pi(s3) = p3 .

eq Pi(r1) = q1 .
eq Pi(r2) = q2 .
eq Pi(r3) = q3 .

eq Pi(w1) = z1 .
eq Pi(w2) = z1 .
eq Pi(w3) = z2 .
eq Pi(w4) = z2 .

op t(_,_) : Place Stations -> Transition .
op te(_,_) : Transition Station -> TransitionEnding .
op b(_) : Transitions -> Behavior .
----------
var trans : Transitions .
op TransBeh(_) : Behavior -> Transitions .
eq TransBeh(b(trans)) = trans .
----------- pour la regle ending behavior on a besoin d'une fonction pour trouver les places des transitions
var pla : Place .
vars S S1 : Stations .
var s : Station .
op PlacesTrans(_) : Transitions -> Places .
eq PlacesTrans(empty) = empty .
eq PlacesTrans(t(pla,S),trans) = pla, PlacesTrans(trans) .

-----------------------
---op m(_,_,_) : SubSetPlace SubSetTransition SubSetTansitionEnding -> Marking .   when we use subset the reduction term is impossble
op m(_,_,_) : Places Transitions TransitionEndings -> Marking .
-------------------
var pls : Places .
var tre : TransitionEndings .
op PlMar : Marking -> Places .
op TrMar : Marking -> Transitions .
op TrEnMar : Marking -> TransitionEndings .

eq PlMar(m(pls,trans,tre)) = pls .
eq TrMar(m(pls,trans,tre)) = trans .
eq TrEnMar(m(pls,trans,tre)) = tre .
---------------------------
op < _,_,_,_,_,_,_ > : Places InitPlace Stations Transitions Behaviors GUses GPros -> ComponentType .

op InitialPlace(_) : ComponentType -> Place .

var q  : Place .
vars p pG : Places .
var st : Stations .
vars t t1  : Transitions . 
vars tes tes1 : TransitionEndings .
var b : Behaviors .
var gu : GUses .
var gp : GPros .

eq InitialPlace (< p,q,st,t,b,gu,gp >) = q .

-----------------------------------------------operation pour les instances

---op Q : -> List{Transitions} .
op M : -> Marking .


op <_,_,_,_> : String ComponentType BehaviorL Marking -> Instance .

--------------------------------------------operations active  et refusing 



----------------------fonctions suplemnetaire
var por : Port . 
vars poru up : UsePort .
vars porp pp : ProPort .
---op (_!_) : UsePort Places -> GUse .
---op (_?_) : ProPort Places -> GPro .

op G(_,_) : Port ComponentType -> Places .
op PlaceUse(_,_) : Port GUses -> Places .
op PlacePro(_,_) : Port GPros -> Places .
eq G(poru,< p,q,st,t,b,gu,gp > ) = PlaceUse(poru,gu)  .
eq G(porp,< p,q,st,t,b,gu,gp > ) = PlacePro(porp,gp)  .

ceq PlaceUse(poru,(up ! p),gu) = p if (poru == up) . 
ceq PlaceUse(poru,(up ! p),gu) = PlaceUse(poru,gu) if (poru =/= up) . 
eq PlaceUse(poru,empty) = empty . 

ceq PlacePro(porp,(pp ? p),gp) = p if (porp == pp) . 
ceq PlacePro(porp,(pp ? p),gp) = PlacePro(porp,gp) if (porp =/= pp) . 
eq PlacePro(porp,empty) = empty . 

-----fonction elements
op elements(_,_) : Places ComponentType -> Marking .
op TranElt(_,_) : Places Transitions -> Transitions .
op TranEndElts(_) : Transitions -> TransitionEndings .
op TranEndElt(_,_) : Transition Stations -> TransitionEndings .
op EndingStationsGroup(_,_) : Stations Places -> Bool .

ceq EndingStationsGroup(s,S,pG) = EndingStationsGroup(S,pG) if (Pi(s) in pG) .
ceq EndingStationsGroup(s,S,pG) = false if (not (Pi(s) in pG)) .
eq EndingStationsGroup(empty,pG) = true .

eq TranEndElt(t(q,S), s,S1)= union(te(t(q,S),s), TranEndElt(t(q,S), S1) ) .
eq TranEndElt(t(q,S),empty) = empty .

eq TranEndElts(t(q,S),t) = union(TranEndElt(t(q,S),S), TranEndElts(t) ) .
eq TranEndElts(empty) = empty .

eq elements(pG,< p,q,st,t,b,gu,gp >) = m( pG, TranElt(pG,t), TranEndElts(TranElt(pG,t)) ) .
ceq TranElt(pG,t(q,S),t) = t(q,S),TranElt(pG,t) if (EndingStationsGroup(S,pG)) .
ceq TranElt(pG,t(q,S),t) = TranElt(pG,t) if (not EndingStationsGroup(S,pG)) .
eq TranElt(pG,empty) = empty .

op  IntersectionMarking(_,_) : Marking Marking -> Marking .
eq  IntersectionMarking( m(p,t,tes),m(pG,t1,tes1)) = m(intersection(p,pG),intersection(t,t1),intersection(tes,tes1)) .

op NotEmptyMarking(_) : Marking -> Bool .
eq NotEmptyMarking(m(p,t,tes)) = (p =/= empty or t =/= empty or tes =/= empty ) .
----------------------------------

op active(_,_) : Instance Port -> Bool . 


vars identI identII : String .
var c : ComponentType .
var bl : BehaviorL .
var mm : Marking .

eq active(< identI, < p,q,st,t,b,gu,gp > ,bl,m(pls,trans,tre) >,por) = NotEmptyMarking(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))) .

------------- fonctions pour refusing

op AllExitGroup(_,_,_) : Places Transitions Places  -> Bool .
op ExitGroupPlace(_,_,_) : Place Transitions Places  -> Bool .
op ExistSourceTranPlace(_,_) : Place Transitions -> Bool .
op AllTranQuitGroupPlace(_,_,_) : Place Transitions Places  -> Bool .
op EndingStationsNotGroup(_,_) : Stations Places -> Bool .
eq AllExitGroup((q,p),t,pG)  = ExitGroupPlace(q,t,pG) and AllExitGroup(p,t,pG) .
eq AllExitGroup(empty,t,pG) = true .
eq ExitGroupPlace(q,t,pG) = ExistSourceTranPlace(q,t) and AllTranQuitGroupPlace(q,t,pG) . 

ceq  ExistSourceTranPlace(q,t(p,S),t1) = true if (p == q ) .
ceq  ExistSourceTranPlace(q,t(p,S),t1) = ExistSourceTranPlace(q,t1) if (p =/= q ) .
eq   ExistSourceTranPlace(q,empty) = false .

ceq AllTranQuitGroupPlace(q,t(p,S),t1,pG) = AllTranQuitGroupPlace(q,t1,pG) if (p =/= q) .
eq AllTranQuitGroupPlace(q,empty,pG) = true .
ceq AllTranQuitGroupPlace(q,t(p,S),t1,pG) = AllTranQuitGroupPlace(q,t(p,S),t1,pG) if (p == q and  EndingStationsNotGroup(S,pG)) .
ceq AllTranQuitGroupPlace(q,t(p,S),t1,pG) = false if (p == q and  not EndingStationsNotGroup(S,pG)) .

ceq EndingStationsNotGroup(s,S,pG) = EndingStationsNotGroup(S,pG) if (not (Pi(s) in pG)) .
ceq EndingStationsNotGroup(s,S,pG) = false if ((Pi(s) in pG)) .
eq EndingStationsNotGroup(empty,pG) = true .


op refusing(_,_) : Instance Port -> Bool .

ceq refusing(< identI, < p,q,st,t,b,gu,gp > ,b(t1) bl,m(pls,trans,tre) >,por) = true if
(
TrMar(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))) == empty and 
TrEnMar(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))) == empty and 
AllExitGroup(PlMar(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))),t1,G(por,< p,q,st,t,b,gu,gp >))

)  .

eq refusing(< identI, < p,q,st,t,b,gu,gp > ,b(t1) bl,m(pls,trans,tre) >,por) = false [owise] .

---------------------------------------operation pour Configuration




op add(_,_) : Ident ComponentType -> Instruction .
op del(_) : Ident -> Instruction .
op pushB(_,_) : Ident Behavior -> Instruction .
op con(_,_,_,_) : Ident UsePort Ident ProPort -> Instruction .
op dcon(_,_,_,_) : Ident UsePort Ident ProPort -> Instruction .
op wait(_) : Ident -> Instruction .
op [] : -> Program [ctor] .
op _._ : Instruction Program -> Program [ctor] .
op < (_,_),_ > : Instances Connections Program -> Configuration . --- conf simplifie a  Instances et Program



----------------------------------------------------operation used in rules ----------------------------------------------

-----------------operations and equations of PushingBehavior
op IsBehaviorOfComponent(_,_) : Behavior ComponentType -> Bool .
vars beh beh1  : Behavior .

eq IsBehaviorOfComponent(beh,< p,q,st,t,b,gu,gp >) = beh in b .
---ceq IsBehaviorOfComponent(beh,< p,q,st,t,beh1,b,gu,gp >) = true if (beh1 == beh)  .
---ceq IsBehaviorOfComponent(beh,< p,q,st,t,beh1,b,gu,gp >) = IsBehaviorOfComponent(beh,< p,q,st,t,b,gu,gp >) if (beh1 =/= beh)  .
---eq IsBehaviorOfComponent(beh,< p,q,st,t,empty,gu,gp >) = false .


---------------operations and equations of ConnectPorts
var  LL : Connections .
vars uus1 uus : UsePort .
var ppr2 : ProPort .
vars iid iid1 iid2 : Ident .
op InConnectionIdentUsePort(_,_,_) :  Ident UsePort Connections -> Bool .

ceq InConnectionIdentUsePort(iid,uus,((iid1,uus1,iid2,ppr2),LL)) = true if (iid1 == iid and uus1 == uus) .
ceq InConnectionIdentUsePort(iid,uus,((iid1,uus1,iid2,ppr2),LL)) = InConnectionIdentUsePort(iid,uus,LL) if (iid1 =/= iid or uus1 =/= uus) .
eq  InConnectionIdentUsePort(iid,uus,empty) = false .

------------operations and equations of DeleteCompoenentInstance

op InConnectionIdent(_,_) :  Ident Connections -> Bool .

ceq InConnectionIdent(iid,((iid1,uus1,iid2,ppr2),LL)) = true if (iid1 == iid or iid2 == iid) .
ceq InConnectionIdent(iid,((iid1,uus1,iid2,ppr2),LL)) = InConnectionIdent(iid,LL) if (iid1 =/= iid and iid2 =/= iid) .
eq  InConnectionIdent(iid,empty) = false .

----------------operations and equation of AddComponentInstance
op IsUsedIdentInstances(_,_) : Ident Instances -> Bool .
var Is : Instances .

ceq IsUsedIdentInstances(identII, < identI,c,bl,mm >, Is) = true if (identII == identI) .
ceq IsUsedIdentInstances(identII, < identI,c,bl,mm >, Is) = IsUsedIdentInstances(identII, Is) if (identII =/= identI) .
eq IsUsedIdentInstances(identII, empty) = false .

-------------- operations and equation of EnteringPlace




endfm 

---con(id1, u, id2, p)
----------------Initialisation

fmod InitMod is

pr ModInstancesAndrComponentType .

ops c1 c2 c3 c4 : -> ComponentType .
ops conf conf0 : -> Configuration .
eq conf = < (empty, empty) , add("id2",c2) . add("id1",c1) . add("id3",c3)  . pushB("id1",b(t(p1, s2), t(p2, s3))) . [] >  .
eq conf0 = < (empty, empty) ,  add("id1",c1) . pushB("id1",b(t(p1, s2), t(p2, s3))) . [] >  .

----op < _,_,_,_,_,_,_ > : Places InitPlace Stations Transitions Behaviors UsePorts ProPorts -> ComponentType .


eq c1 =  < (p1, p2, p3) , p1 , (s1, s2, s3), (t(p1, s2), t(p2, s3)), b(t(p2, s3),t(p1, s2)) , us1 ! (p2, p3), empty > .
eq c2 =  < (q1, q2, q3) , q1 , (r1, r2, r3), (t(q1, r2), t(q2, r3)), b(t(q2, r3),t(q1, r2)) , empty, pr1 ? ( p3) > .
eq c3 =  < (q1, q2, q3) , q1 , (r1, r2, r3), (t(q1, r2), t(q2, r3)), b(t(q2, r3)),b(t(q1, r2)) , empty, pr1 ? ( p3) > .
---- op ins(_,_,_,_) : String ComponentType QueueB Marking -> Instance .
op Q : -> BehaviorL .
op M : -> Marking .



endfm


mod OperationalSemantics is

pr InitMod .



var R : Program .
var I : Instances . 
vars L L1 : Connections .
---var l : Connection .
vars id id1 id2 : Ident .
vars ct ctt : ComponentType .
vars qb : BehaviorL .
var b : Transitions .
var m : Marking .
var inst : Instance .

var ps : Places .
var ts : Transitions .
var tr : Transition .
vars tes tes1 : TransitionEndings .

var us : UsePort .
var pr : ProPort .
---var gu : GUses .
---var gp : GPros .

var p : Place .

---Evolution of Components
---m(p1,empty,empty)
ops i ii : -> Instance .


op mar : -> Marking .
op ccc : -> ComponentType .


op conf1 : -> Configuration .
ops test test1 test2 : -> Configuration .
eq InitialPlace (c2) = p1 .
eq InitialPlace (c3) = p2 .
eq conf1 = < (empty, empty) , add("id1",c1) . add("id2",c2) . con("id1",us1,"id2",pr1).  pushB("id2",b(t(q1, r2), t(q2, r3))) . wait("id2") . pushB("id1",b(t(p1, s2), t(p2, s3))) . wait("id1").  dcon("id1",us1,"id2",pr1) . [] >  .
---eq conf1 = < (empty, empty) , add("id1",c1) . add("id2",c2) . con("id1",us1,"id2",pr1).  pushB("id2",b(t(q1, r2), t(q2, r3))) . wait("id2") . pushB("id1",b(t(p1, s2), t(p2, s3))) . [] >  .
eq test = < (empty, empty) , add("id1",c1) . add("id1",c2) . con("id1",us1,"id2",pr1).  pushB("id2",b(t(q1, r2), t(q2, r3))) . wait("id2")  . wait("id1").  dcon("id1",us1,"id2",pr1) . del("id1") . del("id2") . [] >  .
---eq conf1 = < (empty, empty) , add("id1",c1) . add("id2",c2) . con("id1",us1,"id2",pr1). pushB("id1",b(t(p1, s2), t(p2, s3))) . pushB("id2",b(t(q1, r2), t(q2, r3))) . [] >  .

eq c3 =  < (z1, z2) , z1 , (w1, w2, w3, w4), t(z1, w3, w4 ) , b(t(z1, w3,w4)) , empty, pr1 ? ( z2) >  .


eq test1 = < (empty, empty) , add("idZ",c3) . pushB("idZ",b(t(z1, w3,w4)))  . [] >  .









---on choisit une place p de l'ensemble PlMar(m) tel que {(p S)} de b est different de vide
var q : Place .
var t : Transition .
var S : Stations .
var s : Station .
var Ts : Transitions .
op restrict(_,_) : Transitions Place -> Transitions .
eq restrict(empty,p) = empty .
ceq restrict((t(q,S),Ts),p) = restrict(Ts,p) if (q =/= p) .
ceq restrict(t(q,S),Ts,p) = t(q,S), restrict(Ts,p) if (q == p) .

--- l'ensemble de connexion L' relatives a un ident

op ConnectionProIdent(_,_) : Connections Ident -> Connections .

ceq ConnectionProIdent(((id1,us,id2,pr),L),id) = (id1,us,id2,pr), ConnectionProIdent(L,id) if(id2 == id) .
ceq ConnectionProIdent(((id1,us,id2,pr),L),id) = ConnectionProIdent(L,id) if(id2 =/= id) .
eq ConnectionProIdent(empty,id) = empty .

---- determiner l'instance associe a ident
op InstanceIdent(_,_) : Instances Ident -> Instance . 
var iden : String .
---var ct : ComponentType .
var bl : BehaviorL .
---var m : Marking .

ceq  InstanceIdent((< iden,ct,bl,m > ,I) , id ) = < iden,ct,bl,m > if (iden == id) .
eq  InstanceIdent((< iden,ct,bl,m > ,I) , id ) =  InstanceIdent( I , id ) [owise] .

op ConsistencyPort(_,_,_) : Instance Instances Connections ->  Bool .
eq ConsistencyPort(inst,I,(id1,us,id2,pr),L) = ConsistencyPort(inst,I,L) and (active(InstanceIdent(I,id1),us) implies active(inst,pr)  ).
eq ConsistencyPort(inst,I,empty) = true .





------------------------------------------------------------------------------------------Rules----------------------------------------------------------------------
----------------------------------------------------------------------------------Evolution of Components-------------------------------------------------------------------
---- we don't need to check the intersection the marking with their corresonding net
---------un blocage possible a cause du choix varie de ending station


crl [Firingtransitions] : < ( < id1,ct,b(b) qb,m(p, ps,ts,tes) > , I, L),  R > 
=>   < (  < id1,ct,b(b) qb,m(ps,union(ts, restrict(b,p) ),tes) >, I , L), R > if (restrict(b,p) =/= empty and 
ConsistencyPort(< id1,ct,b(b) qb,m(ps,union(ts, restrict(b,p) ),tes) >,I,ConnectionProIdent(L,id1))) .  




-----------test ok 
crl [EndingTransition] : < ( < id1,ct,qb,m(ps, t(q,s,S), ts,tes) > , I, L),  R > 
=>  < ( < id1,ct,qb,m(ps, ts, te(t(q,s,S),s), RemoveTransitionEndingStation(tes,s)  ) > , I, L),  R > 
if (satisfiedTransitionEndingStation) .  



crl [EnteringPlace] : < ( < id1,ct,b(b) qb,m(ps, ts, te(t(q,s,S),s), tes  ) > , I, L),  R > 
=>  < ( < id1,ct,qb,m(Pi(s),ps, ts, tes  ) > , I, L),  R > if (true) .  

---  test ok
crl [FinishingBehavior] : < ( < id1,ct,b(b) qb,m(ps, empty, empty) > , I, L),  R > 
=>  < ( < id1,ct, qb,m(ps, empty, empty) > , I, L),  R >  if (intersection(ps,PlacesTrans(b)) == empty) .  

------------------------------------------------------------------------------------ Instructions of program------------------------------------------------------------------------- 
---------------test ok .
crl [AddComponentInstance] :  < ( I, L), add(id, ct) . R > 
=>   < (insert( < id, ct, nil, m(InitialPlace(ct) ,empty,empty)  > , I), L), R > if (not IsUsedIdentInstances(id,I)) .  

---------------test ok .
crl [DeleteComponentInstance] : < ( < id1,ct,qb,m > , I, L), del(id) . R > 
=>   < ( I , L), R > if (id == id1 and (not InConnectionIdent(id,L)) ) . 

--- not tested need 3 componenent
crl [ConnectPorts] : < ( I, L), con(id,us,id1,pr) . R > 
=>   < ( I , (id,us,id1,pr),L), R > 
if (id =/= id1 and (InstanceIdent(I,id) in I) and (InstanceIdent(I,id1) in I) and (not InConnectionIdentUsePort(id,us,L)) ) . 

-------------- test ok
crl [DisconnectPorts] : < ( I, L), dcon(id,us,id1,pr) . R > 
=>   < ( I , delete((id,us,id1,pr),L)), R > if (not active(InstanceIdent(I,id),us)) . 

----test ok 
crl [PushingBehavior] : < ( < id1,ct,qb,m > , I, L), pushB(id, b(b)) . R > 
=>   < (  < id1,ct,append(qb,b(b)),m >, I , L), R > if (id == id1 and IsBehaviorOfComponent(b(b),ct)) .  

-----test waiting ok
crl [Waiting] : < ( < id1,ct,nil,m > , I, L), wait(id) . R > 
=>   < ( < id1,ct,nil,m > , I, L), R > if (id1 == id) . 



endm











