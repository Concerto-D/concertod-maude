
mod OPERATIONAL-SEMANTICS is

  inc NET-D-CONFIGURATION .
  inc CONSISTENCY-PORTS-FIRING-TRANSITION .
  inc CONSISTENCY-PORTS-ENTERING-PLACE .
  inc COLLECT-EXTERNAL-FUNCTIONS-FIRING .
  inc COLLECT-EXTERNAL-FUNCTIONS-WAIT .
  inc COLLECT-EXTERNAL-FUNCTIONS-DISCONNECT .
  inc COLLECT-EXTERNAL-FUNCTIONS-ENTERING-PLACE .
  inc COMMUNICATION-FUNCTIONS .

  var lcx lcy : LocalConfiguration .
  vars Rx Ry : Program .
  vars Ix Iy : Instances . 
  vars Lx Ly : Connections .
  vars Fx Fy : MsgToUses .
  vars QSx QSy : Qsend .
  vars QRx QRy : Qreceive .
  vars Wx Wy : SentHistorys .
  var  idf : Msg .
  var valf : BoolWithBot .

  vars ct ctt : ComponentType .
  var inst : Instance .
  var use : UsePort .
  var pro : ProvidePort .

  vars id id1 id2 : IdentInstance .
  vars qb : QBehaviorWithId .
  var behx : Behavior .
  var mrk : Marking .
  var  idbeh : IdentBehavior .
  var b : Transitions .

  vars p q : Place .
  var ps : Places .
  var ts : Transitions .
  vars tes tes1 : TransitionEndings .
  var S : Stations .
  var s : Station .
  vars IdsNodx IdsNody : IdentInstances .  

  -----------------------------------------------------Rules -----------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------Rules of evolution components------------------------------------------------------
--- < ids: _,instances: _,connections: _,program: _,msgs: _,receive: _,send: _,history: _ >
--- < id: _,type: _,queueBehavior: _,marking: _ >
  crl [FiringTransitions] :  < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(p, ps,ts,tes) > , Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >  =>
  < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(ps,union(ts, RestrictTransitionsToPlace(b,p) ),tes) >, Ix , connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx > 
  if (RestrictTransitionsToPlace(b,p) =/= empty and 
  NotActUseWhenLeavinGroupProvide(IdsNodx,m(ps,union(ts, RestrictTransitionsToPlace(b,p) ),tes) ,< id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(p, ps,ts,tes) > ,Ix,Fx,ConnectionProIdent(id1, Lx))) . 

  rl [EndingTransition] : < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: qb,marking: m(ps, t(q,s,S), ts,tes) > , Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >  =>
  < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: qb,marking: m(ps, ts, te(t(q,s,S),s), tes ) > , Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >  .

  crl [EnteringPlace] : < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >  =>
  < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionEndingStation(tes,s) ) > , Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx > 
  if 
  (IsSatisfiedTransitionEndingStation(s,b,te(t(q,s,S),s), tes) 
  and 
  ConnectedAndAllowed(IdsNodx,Pi(s,GetStationPlaces(ct)), GetUsePorts(ct), < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(ps, ts, te(t(q,s,S),s), tes  ) >,
  < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionEndingStation(tes,s) ) >,Ix, Lx,Fx)
  ) .  

  crl [FinishingBehavior] : < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(ps,empty,empty) > , Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >   =>
  < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: qb,marking: m(ps,empty,empty) > , Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >  
  if (intersection(ps,PlacesSourceOfTransitions(b)) == empty) .

  -------------------------------------------------- Instructions of program------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------
  crl [AddComponentInstance] :   < ids: IdsNodx,instances: Ix,connections: Lx,program: add(id, ct) Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >     =>
  < ids: IdsNodx,instances: insert( < id: id,type: ct,queueBehavior: nil,marking: m(InitialPlace(ct) ,empty,empty)  > , Ix),connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >    
  if (not IsUsedIdentInstances(id,Ix))   .  

  crl [DeleteComponentInstance] : < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: qb,marking: mrk > ,Ix,connections: Lx,program: del(id) Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >     =>   
  < ids: IdsNodx,instances: Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >  
  if (id == id1 and (not InConnectionIdent(id,Lx)) ) . 

  crl [ConnectPorts] : < ids: IdsNodx,instances: Ix,connections: Lx,program: con(id,use,id1,pro) Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >    =>   
  < ids: IdsNodx,instances: Ix,connections: (id,use,id1,pro), Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx > 
  if (id =/= id1 and ((InstanceOfIdent(Ix,id) in Ix) or (InstanceOfIdent(Ix,id1) in Ix)) and (not InConnectionIdentUsePort(id,use,Lx)) ) . 

  crl [DisconnectPorts] : < ids: IdsNodx,instances: Ix,connections: Lx, program: dcon(id,use,id1,pro) Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >     =>  
  < ids: IdsNodx,instances: Ix,connections: delete((id,use,id1,pro),Lx),program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >  
  if
  (  
  (id,use,id1,pro) in Lx
  and
  Evaluation(IdsNodx,ExprDisconnect(id,(id,use,id1,pro)),Fx,Ix,Lx,dcon(id,use,id1,pro) Rx) == true
  and
  Evaluation(IdsNodx,ExprDisconnect(id1,(id,use,id1,pro)),Fx,Ix,Lx,dcon(id,use,id1,pro) Rx) == true
  and
  Evaluation(IdsNodx,ExprActive(id,use),Fx,Ix,Lx,dcon(id,use,id1,pro) Rx) == false
  ) .

  crl [PushingBehavior] : < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: qb,marking: mrk >,Ix,connections: Lx, program: pushB(id, behx, idbeh) Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx > 
  =>   < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: append(qb,(idbeh ; behx)),marking: mrk >,Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >  
  if (id == id1 and IsBehaviorOfComponent(behx,ct)) .
    
  crl [Waiting] : < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: qb,marking: mrk > ,Ix,connections: Lx, program: wait(id,idbeh) Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx > 
  =>   < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: qb,marking: mrk > ,Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx > 
  if (Evaluation(IdsNodx,ExprCompleted(id,idbeh),Fx,Ix,Lx, Rx) == true ) .

  -----------------------------------------------Rules  for collecting the evaluation of external functions----------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------

  crl [MsgToUsesForFiringTransitions] : < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(p, ps,ts,tes) > , Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >  =>
  < ids: IdsNodx, instances: < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(p, ps,ts,tes) > , Ix ,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: append(QSx,CollectFunctionFiring(IdsNodx,m(ps,union(ts, RestrictTransitionsToPlace(b,p) ),tes),< id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(p, ps,ts,tes) > , Ix,ConnectionProIdent(id1,Lx),Fx,Wx,QSx)),history: Wx >  
  if (RestrictTransitionsToPlace(b,p) =/= empty and CollectFunctionFiring(IdsNodx,m(ps,union(ts, RestrictTransitionsToPlace(b,p) ),tes),< id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(p, ps,ts,tes) > , Ix,ConnectionProIdent(id1,Lx ),Fx,Wx,QSx) =/= nil) . 

  crl [MsgToUsesForEnteringPlace] : < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx > =>
  < ids: IdsNodx,instances: < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: append(QSx,CollectFunctionsEnteringPlace(IdsNodx,Pi(s,GetStationPlaces(ct)), GetUsePorts(ct), < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(ps, ts, te(t(q,s,S),s), tes  ) >,
  < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionEndingStation(tes,s) ) >,Ix,Lx,Fx,Wx,QSx)), history: Wx > 
  if 
  (
    IsSatisfiedTransitionEndingStation(s,b,te(t(q,s,S),s), tes) 
    and
    (CollectFunctionsEnteringPlace(IdsNodx,Pi(s,GetStationPlaces(ct)), GetUsePorts(ct), < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(ps, ts, te(t(q,s,S),s), tes  ) >,
    < id: id1,type: ct,queueBehavior: (idbeh ; b(b)) qb,marking: m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionEndingStation(tes,s) ) >,Ix, Lx,Fx,Wx,QSx) =/= nil )
  ) .

  crl [MsgToUsesForDisconnectPorts] : 
  < ids: IdsNodx,instances: Ix,connections: Lx,program: dcon(id1,use,id2,pro) Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >    =>  
  < ids: IdsNodx,instances: Ix,connections: Lx,program: dcon(id1,use,id2,pro) Rx,msgs: Fx,receive: QRx,send: append(QSx,CollectFunctionsDiscon(IdsNodx,(id1,use,id2,pro),Fx,Wx,QSx)),history: Wx >   
  if (((id1,use,id2,pro) in Lx)  and (CollectFunctionsDiscon(IdsNodx,(id1,use,id2,pro),Fx,Wx,QSx) =/= nil) ) .

  crl [MsgToUsesForWait] :
  < ids: IdsNodx,instances: Ix,connections: Lx,program: wait(id1,idbeh) Rx,msgs: Fx,receive: QRx,send: QSx,history: Wx >     =>  
  < ids: IdsNodx,instances: Ix,connections: Lx,program: wait(id1,idbeh) Rx,msgs: Fx,receive: QRx,send: append(QSx,CollectFunctionWait(IdsNodx,id1,idbeh,Fx,Wx,QSx)),history: Wx >    
  if (CollectFunctionWait(IdsNodx,id1,idbeh,Fx,Wx,QSx) =/= nil ) .

  --------------------------------------------------------------Rules for communication---------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------

  crl [SendRequest] : 
  < ids: IdsNodx,instances: Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: idf QSx,history: Wx > , < ids: IdsNody,instances: Iy,connections: Ly,program: Ry,msgs: Fy,receive: QRy,send: QSy,history: Wy >  =>
  < ids: IdsNodx,instances: Ix,connections: Lx,program: Rx,msgs: AddFunctionExtern(idf,Fx),receive: QRx,send: QSx, history: (Wx, idf) >  ,  < ids: IdsNody,instances: Iy,connections: Ly,program: Ry,msgs: Fy,receive: append(QRy, (idf ; bot) ),send: QSy,history: Wy > 
  if ( (not LocalFunction(idf,IdsNodx)) and LocalFunction(idf,IdsNody) ) .

  crl [SendEvaluationFunction] : 
  < ids: IdsNodx,instances: Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: idf QSx,history: Wx > , < ids: IdsNody,instances: Iy,connections: Ly,program: Ry,msgs: Fy,receive: QRy,send: QSy,history: Wy >   =>
  < ids: IdsNodx,instances: Ix,connections: Lx,program: Rx,msgs: UpDateMsgToUsesSend(Fx,IdentInstanceonnectionWhenSendActive(Lx,idf,LocalEvaluation(idf,Ix,Lx,Rx))),receive: QRx,send: QSx,history: Wx > , 
  < ids: IdsNody,instances: Iy,connections: Ly,program: Ry,msgs: Fy,receive: append(QRy, (idf ; LocalEvaluation(idf,Ix,Lx,Rx)) ),send: QSy,history: Wy >  
  if ( LocalFunction(idf,IdsNodx) and ((idf in Wy) and (not ExistMsgInReceiveQueue(idf,QRy) )  ) ) .

  crl [ReceivesRequest] : 
  < ids: IdsNodx,instances: Ix,connections: Lx,program: Rx,msgs: Fx,receive: (idf ; valf ) QRx,send: QSx,history: Wx >   =>
  < ids: IdsNodx,instances: Ix,connections: Lx,program: Rx,msgs: Fx,receive: QRx,send: append(QSx, idf  ),history: Wx > 
  if ( LocalFunction(idf,IdsNodx) ) .  

  crl [ReceivesEvaluationFunction] : 
  < ids: IdsNodx,instances: Ix,connections: Lx,program: Rx,msgs: Fx,receive: (idf ; valf ) QRx,send: QSx,history: Wx >   =>
  < ids: IdsNodx,instances: Ix,connections: Lx,program: Rx,msgs: SubstitueEvaluationOfFunction(Fx,idf,valf),receive: QRx,send: QSx,history: delete(idf,Wx) >  
  if ( not LocalFunction(idf,IdsNodx) ) .  

endm

  