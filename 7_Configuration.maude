***(fmod CONCERTO-D-CONFIGURATION is 

  inc ANSWER .
  inc INSTANCE .
  inc PROGRAM .
  inc CONNECTION .
  inc DECLARATION-SORTS . 

  pr SET{Request} . 
  pr MAP{Request,ExpectedValue} .
  pr LIST{Request} . 
  pr LIST{Answer} .

  sorts  Qrequests Qanswers  .  --- define new sorts of queues
  subsort List{Request} < Qrequests . 
  subsort List{Answer} < Qanswers . 
  
  --- Pas sûr pour les noms des différents ensembles et files
  op < nodeInventory: _, instances: _, 
       connections: _, program: _, 
       receivedAnswers: _, outgoingAnswers: _, outgoingRequests: _, 
       history: _ > : 
  IdentInstances Instances Connections Program 
  Map{Request,ExpectedValue} Qanswers Qrequests 
  Set{Request} -> LocalConfiguration 
  [ctor format(n s s d n++i s d ni s d ni s d ni s d ni s d ni s d ni s d s--i) ] .   

endfm

)
fmod CONCERTO-D-CONFIGURATION is 

  inc ANSWER .
  inc INSTANCE .
  inc PROGRAM .
  inc CONNECTION .
  inc DECLARATION-SORTS . 
***(
  sorts  Map{Request,ExpectedValue} SentHistorys . ---define new sorts of type set
  sorts  Qsend Qreceive  . ---define new sorts of type list
  subsort Request  < SentHistory . --- Request is also an element of W 
  subsort Request  < Send . ---- Request is also an element of the send 
  pr SET{MsgToUse} .
    subsort Set{MsgToUse} < Map{Request,ExpectedValue} . 
  pr SET{SentHistory} .
    subsort Set{SentHistory} < SentHistorys . 
  pr LIST{Send} .
    subsort List{Send} < Qsend . 
  pr LIST{Receive} .
    subsort List{Receive} < Qreceive . 
)

  pr SET{Request} . 
  pr MAP{Request,ExpectedValue} .
  pr LIST{Request} . 
  pr LIST{Answer} .

  sorts  Qrequests Qanswers  .  --- define new sorts of queues
  subsort List{Request} < Qrequests . 
  subsort List{Answer} < Qanswers . 




***(
  vars  [ dst: Id , query: Q ] M2 : Request .
  
 
  var QRx : Qreceive .
) 
  var Ix : Instances .
  var Id1 : IdentInstance .
  var IdIx : IdentInstances .
  var IdBeh : IdentBehavior .
  var Ct : ComponentType .
  var Port : Port .
  var Lx : Connections .
  var Rx : Program .
  var L : Connection .
  var Qb : QBehaviorWithId .
  var Mark : Marking .
  var Q : Query .
  var Id : IdentInstance .
  vars R1 R2 : Request .
  
  var Mx : Map{Request,ExpectedValue} .
  vars NewVal val : ExpectedValue .

  --- Pas sûr pour les noms des différents ensembles et files
  op < nodeInventory: _, instances: _, 
       connections: _, program: _, 
       receivedAnswers: _, outgoingAnswers: _, outgoingRequests: _, 
       history: _ > : 
  IdentInstances Instances Connections Program 
  Map{Request,ExpectedValue} Qanswers Qrequests 
  Set{Request} -> LocalConfiguration 
  [ctor format(n s s d n++i s d ni s d ni s d ni s d ni s d ni s d ni s d s--i) ] .   




  ---op _;_) : Request ExpectedValue ->   MsgToUse .  
  ---defines a Request as external (relted to external function) with an evaluation, to be used locally . 

  ---op (_;_) :  Request ExpectedValue  -> Receive .  
  --- a message to receive when communicating
  
  ---op < ids: _,instances: _,connections: _,program: _,msgs: _,receive: _,send: _,history: _ > : 
  ---IdentInstances Instances Connections Program Map{Request,ExpectedValue} Qreceive Qsend  SentHistorys -> LocalConfiguration .   

  --- some ops on configuration
 op isMsgProcessedLocally(_,_) : Request IdentInstances -> Bool .  
  --- determine whether a Request is related to a local treatement.
 eq isMsgProcessedLocally([ dst: Id , query: Q ], IdIx) = Id in IdIx .


  op isMsgConsidredProcessedExternally(_,_) : Request Map{Request,ExpectedValue} -> Bool . 
  --- determine whether a message is considered external
  eq isMsgConsidredProcessedExternally(R1,empty) = false .
  eq isMsgConsidredProcessedExternally(R1,(R1 |-> val,Mx) ) = true  .
  eq isMsgConsidredProcessedExternally(R1,(R2 |-> val,Mx) ) = isMsgConsidredProcessedExternally(R1,Mx) [owise] .
  


  op addMsgExternProcess(_,_) : Request Map{Request,ExpectedValue} -> Map{Request,ExpectedValue} .
  --- add Request related to an external function with a noValueYet evaluation to Map{Request,ExpectedValue} if it is not already in this set.
  ceq addMsgExternProcess([ dst: Id , query: Q ],Mx) =  [ dst: Id , query: Q ] |-> noValueYet,Mx if (not isMsgConsidredProcessedExternally([ dst: Id , query: Q ], Mx )) .  
  eq addMsgExternProcess([ dst: Id , query: Q ],Mx) = Mx [owise] . 


  op externEvaluationMsg(_,_) : Request Map{Request,ExpectedValue}  -> ExpectedValue .  
  ---obtain the evalaution of an external function related to a Request from Map{Request,ExpectedValue}
  eq externEvaluationMsg(R1, empty) = noValueYet . 
  eq externEvaluationMsg(R1, R1 |-> val, Mx ) = val  .
  eq externEvaluationMsg(R1, R2 |-> val, Mx ) = externEvaluationMsg(R1, Mx ) [owise] .

  op substitueEvaluationMsg(_,_,_) : Map{Request,ExpectedValue} Request ExpectedValue -> Map{Request,ExpectedValue} .  
  --- substitutes the evaluation related to an external function of Request in the set of Map{Request,ExpectedValue}.
  eq substitueEvaluationMsg(empty,R1,NewVal) = empty . 
  eq substitueEvaluationMsg((R1 |-> val, Mx),R1,NewVal) = R1 |-> NewVal, Mx  .
  eq substitueEvaluationMsg((R1 |-> val, Mx),R2,NewVal) = R1 |-> val, substitueEvaluationMsg(Mx,R2,NewVal) [owise] .
 
  op localEvaluationMsg(_,_,_,_) : Request Instances Connections Program -> ExpectedValue .  
  ---- gives the evaluation of a local function related to Request according to certain parameters of a given configuration
  eq localEvaluationMsg ([ dst: Id , query: isActive(Port) ], Ix,Lx,Rx) =  if (not isUsedIdentInstances(Id,Ix)) then false else active(instanceOfIdent(Ix,Id),Port) fi .   
  ---if the instance does not yet exist, then the active local function: active(Id1,Port) = false, otherwise it is the local active function within the instance. 
  eq localEvaluationMsg ([ dst: Id , query: isRefusing(Port) ], Ix,Lx,Rx) =  if (not isUsedIdentInstances(Id,Ix)) then true else refusing(instanceOfIdent(Ix,Id),Port) fi .
   ---if the instance does not yet exist, then the refusing local function: refusing(Id1,Port) = true, otherwise it is the local refusing function within the instance.   
  eq localEvaluationMsg ([ dst: Id , query: isConnected(L) ], Ix,Lx,Rx) = L in Lx . 
  eq localEvaluationMsg ([ dst: Id , query: isDisconnect(L) ], Ix,Lx,Rx) = disconnect(L,Rx) . 
  eq localEvaluationMsg ([ dst: Id , query: isCompleted(IdBeh) ], (Id |-> { type: Ct,queueBehavior: Qb,marking: Mark },Ix),Lx,Rx) =  
  (not existIdentBehaviorehListBeh(IdBeh,Qb) ) and notPushBProg(Id,IdBeh,Rx) .
  --- the evaluation of completed of an IdBeh depends on whether the push IdBeh exists in the program or in the behavior list.
  eq localEvaluationMsg ([ dst: Id , query: isCompleted(IdBeh) ], Ix,Lx,Rx) =  if ((not isUsedIdentInstances(Id,Ix) ) and notPushBProg(Id,IdBeh,Rx)) then true else false fi . 
  --- special case the instance doesn't exist and even the push of IdBeh in the program. this is the case when a program is executed and its instance is deleted.

  op evaluationMsg(_,_,_,_,_,_) :  Request IdentInstances Map{Request,ExpectedValue} Instances Connections Program -> ExpectedValue . 
  --- gives the evaluation of a function related to Request according to the two cases, the function is local or external
  eq evaluationMsg(R1,IdIx,Mx, Ix,Lx,Rx ) = if (isMsgProcessedLocally(R1,IdIx)) then localEvaluationMsg(R1,Ix,Lx,Rx) else externEvaluationMsg(R1,Mx) fi .
***(
  op existMsgInReceiveQueue(_,_) : Request Qreceive -> Bool .
  --- determine whether a Request related to a function is already in the queue of messages received. 
  eq existMsgInReceiveQueue([ dst: Id , query: Q ],nil) = false .
  ceq existMsgInReceiveQueue([ dst: Id , query: Q ],(M2 ; val) QRx) = true if ([ dst: Id , query: Q ] == M2)  .
  eq existMsgInReceiveQueue([ dst: Id , query: Q ],(M2 ; val) QRx) =  existMsgInReceiveQueue([ dst: Id , query: Q ], QRx) [owise] .
)
endfm