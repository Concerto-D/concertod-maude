fmod Declarations is  ----------------------------------------------------------------------------------------declarations  

-----------------------new declaration
pr BOOL .
sort BoolWithBot .
sort Bot .
subsorts Bool  Bot < BoolWithBot .

sort Site .

sorts  IdentC IdentB IdentCs .

sort Function .
sorts ElementFunctionL ElementFunctionE .
sorts ElementFunctionLs ElementFunctionEs .

sorts Instance Instances .
sorts Connection Connections .
sorts LocalConfiguration LocalConfigurations  .




sorts  F  Qsend Qrec Ws .
sort send rec W .

sort typeFunction .

sort ComponentType .
sorts Instruction  Behavior UsePort ProPort Program Port .
subsorts UsePort ProPort < Port .


sort IdFunction .
---subsorts IdFunctionL IdFunctionE < IdFunction .

subsort IdFunction  < W . ---id de fonction est un element de W
subsort IdFunction  < send . ---- the same 

------------pour ComponentType
sorts InitPlace Places Stations StationPlaces . --- identifiers for Transitionns and places
sorts Place Station StationPlace .

subsort InitPlace < Place .


sort Transitionn .
sort TransitionnEnding .
sort Transitionns .
sort Behaviors .
sort TransitionnEndings .
---sort TransitionnsL .
sorts BehaviorL BehaviorLs .

sort Marking .
sort Markings .



sort ProPorts .
sort UsePorts .
sorts GUse GPro .
sorts GUses GPros . 
-------------------------------------

----------------subset
***(
sort SubSetStation .
subsort SubSetStation < Stations .

sort SubSetTransitionn .
subsort SubSetTransitionn < Transitionns .

sort SubSetPlace .
subsort SubSetPlace < Places .

sort SubSetTansitionEnding .
subsort SubSetTansitionEnding < TransitionnEndings .
)
-------------------------

ops idc1 idc2 idc3 idc4 : -> IdentC .

ops p1 q1 : -> InitPlace .
ops p2 p3 p4 p5 p6 p7 p8 p9 p10 q2 q3 q4 q5 q6 q7 q8 q9 q10 : -> Place .



ops s1 s2 s3 s4 s5 s6 s7 s8 s9 s10   : -> Station .

ops r1 r2 r3 r4 r5 r6 r7 r8 r9 r10   : -> Station .

ops us1 us2 us3 us4 : -> UsePort .

ops pr1 pr2 pr3 pr4 : -> ProPort .

op(_;_) : Station Place -> StationPlace . 
op (_!_) : UsePort Places -> GUse .
op (_?_) : ProPort Places -> GPro .

op (_,_,_,_) : IdentC UsePort IdentC ProPort -> Connection .

ops site1 site2 : -> Site . 
ops idc1 idc2 : -> IdentC .

op @(_) : IdentC -> Site .
eq @(idc1) = site1 .
eq @(idc2) = site2 .



endfm



---------------------------------------------------------------------The used view

view ElementFunctionL from TRIV to Declarations is
  sort Elt to ElementFunctionL .
endv

view ElementFunctionE from TRIV to Declarations is
  sort Elt to ElementFunctionE .
endv


view send from TRIV to Declarations is
  sort Elt to send .
endv

view rec from TRIV to Declarations is
  sort Elt to rec .
endv

view W from TRIV to Declarations is
  sort Elt to W .
endv

view Connection from TRIV to Declarations is
 sort Elt to Connection .
endv
 

view Instance from TRIV to Declarations is
  sort Elt to Instance .
endv

view LocalConfiguration from TRIV to Declarations is
  sort Elt to LocalConfiguration .
endv


view Place from TRIV to Declarations is
  sort Elt to Place .
endv

view StationPlace from TRIV to Declarations is
  sort Elt to StationPlace .
endv

view Station from TRIV to Declarations is
  sort Elt to Station .
endv


view Transitionn from TRIV to Declarations is
  sort Elt to Transitionn .
endv

view Transitionns from TRIV to Declarations is
  sort Elt to Transitionns .
endv


view TransitionnEnding from TRIV to Declarations is
  sort Elt to TransitionnEnding .
endv

view Behavior from TRIV to Declarations is
  sort Elt to Behavior .
endv

view BehaviorL from TRIV to Declarations is
  sort Elt to BehaviorL .
endv

view GUse from TRIV to Declarations is
sort Elt to GUse .
endv

view GPro from TRIV to Declarations is
 sort Elt to GPro .
endv

view IdentC from TRIV to Declarations is
 sort Elt to IdentC .
endv



-------------------------------------------------------------------------------------------------End view 

fmod Operations is

pr Declarations .

pr SET{ElementFunctionL} .
subsort Set{ElementFunctionL} < ElementFunctionLs . 

pr SET{ElementFunctionE} .
subsort Set{ElementFunctionE} < ElementFunctionEs . 

pr SET{Connection} .
subsort Set{Connection} < Connections . 

pr SET{Instance} .
subsort Set{Instance} < Instances . 

pr LIST{send} .
subsort List{send} < Qsend . 

pr LIST{rec} .
subsort List{rec} < Qrec . 

pr SET{W} .
subsort Set{W} < Ws . 

pr SET{IdentC} .
subsort Set{IdentC} < IdentCs . 

pr SET{LocalConfiguration} .
subsort Set{LocalConfiguration} < LocalConfigurations . 




-----------------------id of functions
-----ou bien id(_,_,_) : type oprtation (op acti,ref ...) identc port
---ops act ref iscon discon compl : -> typeFunction .  to modifier pour les type different

sorts IdFuncAct IdFunRef IdFunIscon IdFunDis IdFunComp .
subsorts IdFuncAct IdFunRef IdFunIscon IdFunDis IdFunComp < IdFunction .

op idAct(_,_) : IdentC Port -> IdFuncAct .
op idRef(_,_) : IdentC Port -> IdFunRef .
op idIsCon(_,_) : IdentC Connection -> IdFunIscon .
op idDiscon(_,_) : IdentC Connection -> IdFunDis .
op idComp(_,_) : IdentC IdentB -> IdFunComp .





--------------------------------------
op el(_) : IdFunction  ->   ElementFunctionL .
op ee(_;_) : IdFunction BoolWithBot ->   ElementFunctionE .

op bot : -> Bot .

ops idb1 idb2 idb3 idb4 : -> IdentB .

op (_;_) :  IdFunction BoolWithBot  -> rec . ------a voir reduction avec ElementFunctionE .



op F(_,_) :  ElementFunctionLs ElementFunctionEs -> F .

---------------------------------------operation pour Configuration

op add(_,_) : IdentC ComponentType -> Instruction .
op del(_) : IdentC -> Instruction .
op pushB(_,_,_) : IdentC Behavior IdentB -> Instruction .
op con(_) : Connection -> Instruction .
op dcon(_) : Connection -> Instruction .
op wait(_,_) : IdentC IdentB -> Instruction .
op [] : -> Program [ctor] .
op _._ : Instruction Program -> Program [ctor] .


op < (_,_),_,_,_,_,_ > : Instances Connections Program F Qrec Qsend  Ws -> LocalConfiguration . 




---------------------------------------operation pour Configuration

-------------------------------------fonction utilisee pour les regles

op LocalFun(_,_) : IdFunction F -> Bool .
op ExternFun(_,_) : IdFunction F -> Bool .

vars idf lf ef : IdFunction .
var Fx : F .
var lfs : ElementFunctionLs .
var efs : ElementFunctionEs .
var bwb : BoolWithBot .

ceq LocalFun(idf, F((el(lf),lfs),efs )) = true if (idf == lf) .
ceq LocalFun(idf, F((el(lf),lfs),efs )) = LocalFun(idf, F(lfs,efs )) if (idf =/= lf) .
eq LocalFun(idf, F(empty,efs )) = false .

ceq ExternFun(idf, F(lfs,ee(ef ; bwb),efs )) = true if (idf == ef) .
ceq ExternFun(idf, F(lfs,ee(ef ; bwb),efs)) = ExternFun(idf, F(lfs,efs)) if (idf =/= ef) .
eq ExternFun(idf, F(empty,efs )) = false .





endfm
     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


fmod ModInstancesAndrComponentType is 

pr Operations .

protecting STRING .
protecting BOOL .
protecting INT .


pr SET{Transitionn} .
subsort Set{Transitionn} < Transitionns . 

pr LIST{BehaviorL} .
subsort List{BehaviorL} < BehaviorLs . 

pr SET{TransitionnEnding} .
subsort Set{TransitionnEnding} < TransitionnEndings . 

---subsort Behavior < Transitionns .

pr SET{Behavior} .
subsort Set{Behavior} < Behaviors . 

pr SET{GUse} .
subsort Set{GUse} < GUses .

pr SET{GPro} .
subsort Set{GPro} < GPros .

-----------new modif
-----pr SET{String} . 
--- subsorts Set{String} <  Places Stations . 

pr SET{Place} . 
pr SET{Station} . 
pr SET{StationPlace} . 

subsort Set{Place} <  Places  . 
subsort Set{Station} <  Stations  . 
subsort Set{StationPlace} <  StationPlaces . 

-----end new modif
--------------------Marking
---subsort Places < Markings . 
---subsort Transitionns < Markings . 
---subsort TransitionnEndings < Markings .  
---pr SET{Marking} .
---subsort Set{Marking} < Markings . 


---pr SET{String} .

pr SET{Instance} .

subsort Set{Instance} < Instances .

pr SET{Connection} .
subsort Set{Connection} < Connections . 


---subsort Transitionns <  Behavior .  

-------les autres operation  Pi: la place d'une station, Transitionn t(,) , transirion ending te(,) ,  Behavior et ComponentType sans port

op Pi(_,_) : Station StationPlaces -> Place .
vars s ss2 ss1 : Station .
var SPs : StationPlaces .
var q : Place .

ceq Pi(ss1, ((ss2 ; q),SPs)) = q if(ss1 == ss2) .
ceq Pi(ss1, ((ss2 ; q),SPs)) = Pi(ss1,SPs) if(ss1 =/= ss2) .




op t(_,_) : Place Stations -> Transitionn .
op te(_,_) : Transitionn Station -> TransitionnEnding .
op b(_) : Transitionns -> Behavior .
op (_;_) : IdentB Behavior -> BehaviorL .
----------
var trans : Transitionns .
op TransBeh(_) : Behavior -> Transitionns .
eq TransBeh(b(trans)) = trans .
----------- pour la regle ending behavior on a besoin d'une fonction pour trouver les places des Transitionns
var pla : Place .
vars S S1 : Stations .

op PlacesTrans(_) : Transitionns -> Places .
eq PlacesTrans(empty) = empty .
eq PlacesTrans(t(pla,S),trans) = pla, PlacesTrans(trans) .

-----------------------
---op m(_,_,_) : SubSetPlace SubSetTransitionn SubSetTansitionEnding -> Marking .   when we use subset the reduction term is impossble
op m(_,_,_) : Places Transitionns TransitionnEndings -> Marking .
-------------------
var pls : Places .
var tre : TransitionnEndings .
op PlMar : Marking -> Places .
op TrMar : Marking -> Transitionns .
op TrEnMar : Marking -> TransitionnEndings .

eq PlMar(m(pls,trans,tre)) = pls .
eq TrMar(m(pls,trans,tre)) = trans .
eq TrEnMar(m(pls,trans,tre)) = tre .
---------------------------
op < _,_,_,_,_,_,_ > : Places InitPlace StationPlaces Transitionns Behaviors GUses GPros -> ComponentType .

op InitialPlace(_) : ComponentType -> Place .


vars p pG : Places .
var st : StationPlaces .
vars t t1  : Transitionns . 
vars tes tes1 : TransitionnEndings .
var b : Behaviors .
var gu : GUses .
var gp : GPros .

eq InitialPlace (< p,q,st,t,b,gu,gp >) = q .

op GetStationPlaces(_) : ComponentType -> StationPlaces .

eq GetStationPlaces (< p,q,st,t,b,gu,gp >) = st .
-----------------------------------------------operation pour les instances

---op Q : -> List{Transitionns} .
op M : -> Marking .


op <_,_,_,_> : IdentC ComponentType BehaviorLs Marking -> Instance .

--------------------------------------------operations active  et refusing 



----------------------fonctions suplemnetaire
var por : Port . 
vars poru up : UsePort .
vars porp pp : ProPort .
var use : UsePort .
var pro : ProPort .
---op (_!_) : UsePort Places -> GUse .
---op (_?_) : ProPort Places -> GPro .

op G(_,_) : Port ComponentType -> Places .
op PlaceUse(_,_) : Port GUses -> Places .
op PlacePro(_,_) : Port GPros -> Places .
eq G(poru,< p,q,st,t,b,gu,gp > ) = PlaceUse(poru,gu)  .
eq G(porp,< p,q,st,t,b,gu,gp > ) = PlacePro(porp,gp)  .

ceq PlaceUse(poru,(up ! p),gu) = p if (poru == up) . 
ceq PlaceUse(poru,(up ! p),gu) = PlaceUse(poru,gu) if (poru =/= up) . 
eq PlaceUse(poru,empty) = empty . 

ceq PlacePro(porp,(pp ? p),gp) = p if (porp == pp) . 
ceq PlacePro(porp,(pp ? p),gp) = PlacePro(porp,gp) if (porp =/= pp) . 
eq PlacePro(porp,empty) = empty . 

-----fonction elements
op elements(_,_) : Places ComponentType -> Marking .
op TranElt(_,_,_) : Places Transitionns Stations -> Transitionns .        
op TranEndElts(_) : Transitionns -> TransitionnEndings .
op TranEndElt(_,_) : Transitionn Stations -> TransitionnEndings .
op EndingStationsGroup(_,_) : Stations  Stations -> Bool .

ceq EndingStationsGroup((s,S),S1) = EndingStationsGroup(S,S1) if (s in S1) .
ceq EndingStationsGroup((s,S),S1) = false if (not (s in S1)) .
eq EndingStationsGroup(empty,S1) = true .

eq TranEndElt(t(q,S), s,S1)= union(te(t(q,S),s), TranEndElt(t(q,S), S1) ) .
eq TranEndElt(t(q,S),empty) = empty .

eq TranEndElts(t(q,S),t) = union(TranEndElt(t(q,S),S), TranEndElts(t) ) .
eq TranEndElts(empty) = empty .
------------selection only station that end in the eleent of ExitGroupPlac
op StationsGplaces(_,_) : Places StationPlaces -> Stations .

ceq StationsGplaces(p,(s ; q),st) = s, StationsGplaces(p,st) if(q in p) .
ceq StationsGplaces(p,(s ; q),st) =  StationsGplaces(p,st) if(not(q in p)) .
eq StationsGplaces(p,empty) = empty .
------------------------------------------------------------------
eq elements(pG,< p,q,st,t,b,gu,gp >) = m( pG, TranElt(pG,t,StationsGplaces(pG,st)), TranEndElts(TranElt(pG,t,StationsGplaces(pG,st))) ) .
ceq TranElt(pG,t(q,S),t,S1) = t(q,S),TranElt(pG,t,S1) if (q in pG and (EndingStationsGroup(S,S1))) .
ceq TranElt(pG,t(q,S),t,S1) = TranElt(pG,t,S1) if (not (q in pG and (EndingStationsGroup(S,S1)))) .
eq TranElt(pG,empty,S1) = empty .

op  IntersectionMarking(_,_) : Marking Marking -> Marking .
eq  IntersectionMarking( m(p,t,tes),m(pG,t1,tes1)) = m(intersection(p,pG),intersection(t,t1),intersection(tes,tes1)) .

op NotEmptyMarking(_) : Marking -> Bool .
eq NotEmptyMarking(m(p,t,tes)) = (p =/= empty or t =/= empty or tes =/= empty ) .
----------------------------------

op active(_,_) : Instance Port -> Bool . 
op activeMarking(_,_,_) : Instance Port Marking -> Bool . 

vars identI identII : IdentC .
var c : ComponentType .
var bl : BehaviorLs .
var mm : Marking .
var idbeh : IdentB .

op IdentInstance(_) : Instance -> IdentC .
eq IdentInstance(< identI,c,bl,mm > ) = identI .

eq active(< identI, < p,q,st,t,b,gu,gp > ,bl,m(pls,trans,tre) >,por) = NotEmptyMarking(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))) .
eq activeMarking(< identI, < p,q,st,t,b,gu,gp > ,bl,m(pls,trans,tre) >,por,mm) = NotEmptyMarking(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),mm)) .
------------- fonctions pour refusing

op AllExitGroup(_,_,_,_) : Places Transitionns Places StationPlaces -> Bool .
op ExitGroupPlace(_,_,_,_) : Place Transitionns Places StationPlaces -> Bool .
op ExistSourceTranPlace(_,_) : Place Transitionns -> Bool .
op AllTranQuitGroupPlace(_,_,_,_) : Place Transitionns Places StationPlaces -> Bool .
op EndingStationsNotGroup(_,_,_) : Stations Places StationPlaces -> Bool .
eq AllExitGroup((q,p),t,pG,st)  = ExitGroupPlace(q,t,pG,st) and AllExitGroup(p,t,pG,st) .
eq AllExitGroup(empty,t,pG,st) = true .
eq ExitGroupPlace(q,t,pG,st) = ExistSourceTranPlace(q,t) and AllTranQuitGroupPlace(q,t,pG,st) . 

ceq  ExistSourceTranPlace(q,t(p,S),t1) = true if (p == q ) .
ceq  ExistSourceTranPlace(q,t(p,S),t1) = ExistSourceTranPlace(q,t1) if (p =/= q ) .
eq   ExistSourceTranPlace(q,empty) = false .

ceq AllTranQuitGroupPlace(q,t(p,S),t1,pG,st) = AllTranQuitGroupPlace(q,t1,pG,st) if (p =/= q) .
eq AllTranQuitGroupPlace(q,empty,pG,st) = true .
ceq AllTranQuitGroupPlace(q,t(p,S),t1,pG,st) = AllTranQuitGroupPlace(q,t(p,S),t1,pG,st) if (p == q and  EndingStationsNotGroup(S,pG,st)) .
ceq AllTranQuitGroupPlace(q,t(p,S),t1,pG,st) = false if (p == q and  not EndingStationsNotGroup(S,pG,st)) .

ceq EndingStationsNotGroup(s,S,pG,st) = EndingStationsNotGroup(S,pG,st) if (not (Pi(s,st) in pG)) .
ceq EndingStationsNotGroup(s,S,pG,st) = false if ((Pi(s,st) in pG)) .
eq EndingStationsNotGroup(empty,pG,st) = true .


op refusing(_,_) : Instance Port -> Bool .

ceq refusing(< identI, < p,q,st,t,b,gu,gp > , (idbeh ; b(t1)) bl,m(pls,trans,tre) >,por) = true if
(
TrMar(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))) == empty and 
TrEnMar(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))) == empty and 
AllExitGroup(PlMar(IntersectionMarking(elements(G(por, < p,q,st,t,b,gu,gp >),< p,q,st,t,b,gu,gp >),m(pls,trans,tre))),t1,G(por,< p,q,st,t,b,gu,gp >),st)

)  .

eq refusing(< identI, < p,q,st,t,b,gu,gp > , bl,m(pls,trans,tre) >,por) = false [owise] .




---- determiner l'instance associe a ident
op InstanceIdent(_,_) : Instances IdentC -> Instance . 
vars iden id : IdentC .
var contcomp : ComponentType .
var behL : BehaviorLs .
var mark : Marking .
var I : Instances .
ceq  InstanceIdent((< iden,contcomp,behL,mark > ,I) , id ) = < iden,contcomp,behL,mark > if (iden == id) .
eq  InstanceIdent((< iden,contcomp,behL,mark > ,I) , id ) =  InstanceIdent(I,id) [owise] .



----------------------------------------------------operation used in rules ----------------------------------------------

-----------------operations and equations of PushingBehavior
op IsBehaviorOfComponent(_,_) : Behavior ComponentType -> Bool .
vars beh beh1  : Behavior .

eq IsBehaviorOfComponent(beh,< p,q,st,t,b,gu,gp >) = beh in b .
---ceq IsBehaviorOfComponent(beh,< p,q,st,t,beh1,b,gu,gp >) = true if (beh1 == beh)  .
---ceq IsBehaviorOfComponent(beh,< p,q,st,t,beh1,b,gu,gp >) = IsBehaviorOfComponent(beh,< p,q,st,t,b,gu,gp >) if (beh1 =/= beh)  .
---eq IsBehaviorOfComponent(beh,< p,q,st,t,empty,gu,gp >) = false .


---------------operations and equations of ConnectPorts
var  LL : Connections .
vars uus1 uus : UsePort .
var ppr2 : ProPort .
vars iid iid1 iid2 : IdentC .
op InConnectionIdentUsePort(_,_,_) :  IdentC UsePort Connections -> Bool .

ceq InConnectionIdentUsePort(iid,uus,((iid1,uus1,iid2,ppr2),LL)) = true if (iid1 == iid and uus1 == uus) .
ceq InConnectionIdentUsePort(iid,uus,((iid1,uus1,iid2,ppr2),LL)) = InConnectionIdentUsePort(iid,uus,LL) if (iid1 =/= iid or uus1 =/= uus) .
eq  InConnectionIdentUsePort(iid,uus,empty) = false .

------------operations and equations of DeleteCompoenentInstance

op InConnectionIdent(_,_) :  IdentC Connections -> Bool .

ceq InConnectionIdent(iid,((iid1,uus1,iid2,ppr2),LL)) = true if (iid1 == iid or iid2 == iid) .
ceq InConnectionIdent(iid,((iid1,uus1,iid2,ppr2),LL)) = InConnectionIdent(iid,LL) if (iid1 =/= iid and iid2 =/= iid) .
eq  InConnectionIdent(iid,empty) = false .

----------------operations and equation of AddComponentInstance
op IsUsedIdentInstances(_,_) : IdentC Instances -> Bool .
var Is : Instances .

ceq IsUsedIdentInstances(identII, < identI,c,bl,mm >, Is) = true if (identII == identI) .
ceq IsUsedIdentInstances(identII, < identI,c,bl,mm >, Is) = IsUsedIdentInstances(identII, Is) if (identII =/= identI) .
eq IsUsedIdentInstances(identII, empty) = false .

-------------- operations and equation of EnteringPlace


op RemoveTransitionnEndingStation(_,_) : TransitionnEndings Station -> TransitionnEndings .
op IsSatisfiedTransitionnEndingStation(_,_,_) : Station Transitionns TransitionnEndings -> Bool .

var ss : Station .
ceq IsSatisfiedTransitionnEndingStation(s,t(q,S),t,tes) = false 
if( (s in S) and (not(te(t(q,S),s) in tes)) ) .
ceq IsSatisfiedTransitionnEndingStation(s,t(q,S),t,tes) = IsSatisfiedTransitionnEndingStation(s,t,tes) 
if(not(s in S) or (te(t(q,S),s) in tes) ) .
eq IsSatisfiedTransitionnEndingStation(s,empty,tes) = true .

ceq RemoveTransitionnEndingStation(te(t(q,S),s),tes,ss) = te(t(q,S),s),RemoveTransitionnEndingStation(tes,ss)
if (s =/= ss) .
ceq RemoveTransitionnEndingStation(te(t(q,S),s),tes,ss) = RemoveTransitionnEndingStation(tes,ss)
if (s == ss) .
eq RemoveTransitionnEndingStation(empty,ss) = empty .



op GetUsePort(_) : ComponentType -> GUses .
eq GetUsePort (< p,q,st,t,b,gu,gp >) = gu .

op ConnectedProvidedAllowed(_,_,_,_,_,_,_) : Place GUses Instance Instance Instances Connections F -> Bool . 
vars i1 i2 : Instance .
---vars poru up : UsePort . 
eq ConnectedProvidedAllowed(q,empty,i1,i2,Is,LL,F(lfs,efs)) = true .
ceq ConnectedProvidedAllowed(q,(up ! p),gu,i1,i2,Is,LL,F(lfs,efs)) = 
Connected(up,IdentInstance(i1),LL,F(lfs,efs))
and 
Provided(up,IdentInstance(i1),i1,Is,LL,F(lfs,efs)) 
and 
Allowed(up,IdentInstance(i1),i1,Is,LL,F(lfs,efs)) 
and ConnectedProvidedAllowed(q,gu,i1,i2,Is,LL,F(lfs,efs)) if  ((q in p) and active(i1,up) == false and active(i2,up) == true  ).     ----------active puisque c local traitement directe
eq ConnectedProvidedAllowed(q,(up ! p),gu,i1,i2,Is,LL,F(lfs,efs)) = ConnectedProvidedAllowed(q,gu,i1,i2,Is,LL,F(lfs,efs)) [owise] .

op Connected(_,_,_,_) : UsePort IdentC Connections F -> Bool . 
op Provided(_,_,_,_,_) : UsePort IdentC  Instances Connections F -> Bool . 
op Allowed(_,_,_,_,_) : UsePort  IdentC Instances Connections F -> Bool . 
---var prou : UsePort
var IdentIns : IdentC .



eq Connected(poru,IdentIns,empty,F(lfs,efs)) = false .
ceq Connected(poru,IdentIns,(iid1,up,iid2,pp),LL,F(lfs,efs)) = true 
if(poru == up and iid1 == IdentIns and Eval(idIsCon(iid2,(iid1,up,iid2,pp)),F(lfs,efs),empty,(iid1,up,iid2,pp),LL,[] )   == true ) .
eq Connected(poru,IdentIns,(iid1,up,iid2,pp),LL,F(lfs,efs)) = Connected(poru,IdentIns,LL,F(lfs,efs)) [owise] .

ceq Provided(poru,IdentIns,Is,(iid1,up,iid2,pp),LL,F(lfs,efs)) = Provided(poru,IdentIns,Is,LL,F(lfs,efs))
if (poru =/= up or iid1 =/= IdentIns) .
ceq Provided(poru,IdentIns,Is,(iid1,up,iid2,pp),LL,F(lfs,efs)) = (Eval(idAct(iid2,pp),F(lfs,efs),Is,(iid1,up,iid2,pp),LL,[] ) == true) 
if (poru == up and iid1 == IdentIns) .
eq Provided(poru,IdentIns,Is,empty,F(lfs,efs)) = false .

ceq Allowed(poru,IdentIns,Is,(iid1,up,iid2,pp),LL,F(lfs,efs)) = Allowed(poru,IdentIns,Is,LL,F(lfs,efs))
if (poru =/= up or iid1 =/= IdentIns) .
ceq Allowed(poru,IdentIns,Is,(iid1,up,iid2,pp),LL,F(lfs,efs)) = (Eval(idRef(iid2,pp),F(lfs,efs),Is,(iid1,up,iid2,pp),LL,[] ) == false) 
if (poru == up and iid1 == IdentIns) .
eq Allowed(poru,IdentIns,Is,empty,F(lfs,efs)) = false .


----on suppose que F existe est correcte pour la conf on peut le construire par op ConstruireF(_) : Program -> F .

---------------------------functionn SubValExtern
----op F(_,_) :  ElementFunctionLs ElementFunctionEs -> F .
op SubValExtern(_,_,_) : ElementFunctionEs IdFunction BoolWithBot -> ElementFunctionEs .
var efes : ElementFunctionEs .
var efe :  ElementFunctionE .
vars valfNew valfOld : BoolWithBot .
vars idf1 idf2 : IdFunction .
ceq SubValExtern((ee(idf1 ; valfOld),efes),idf2,valfNew) = ee(idf1 ; valfNew),efes if(idf1 == idf2) .
ceq SubValExtern((ee(idf1 ; valfOld),efes),idf2,valfNew) = ee(idf1 ; valfOld),SubValExtern(efes,idf2,valfNew) if(idf1 =/= idf2) .
eq SubValExtern(empty,idf2,valfNew) = empty . 

------------------------------function disconnect used in dcon  : not the same as formal definition
op disconnect(_,_) : Connection Program -> Bool .
op NotDcon(_,_) :  Connection Program -> Bool .
vars Prog1 Prog2 : Program .
var l : Connection .
var inst : Instruction .

eq disconnect(l,[]) = true .
eq disconnect(l,inst . Prog1) = NotDcon(l,Prog1) .
eq NotDcon(l,[]) = true .
eq NotDcon(l,inst . Prog1) = (inst =/= dcon(l) and NotDcon(l,Prog1)) .



------------------------------------------------------------- functions used in operational semantics Messages 
-------------------------------------------------------------------------LocalEval(idf,Ix,Lx,Rx)
---op idAct(_,_) : IdentC Port -> IdFuncAct .
---op idRef(_,_) : IdentC Port -> IdFunRef .


op LocalEval(_,_,_,_) : IdFunction Instances Connections Program -> BoolWithBot .

vars idcx idcy : IdentC .
var idbehx : IdentB .
var idbehy : IdentB .
var ctx : ComponentType .
var behlx : BehaviorLs .
var Mx : Marking .
var porx : Port .
var Isx : Instances .
var Ls : Connections .
var pg : Program .


---eq LocalEval (idRef(idcx,por), Is,Ls,pg) = false . 
--------------------------------------------------------------------evalution des fonctions locales

op ExistIdentInstances(_,_) : IdentC Instances -> Bool .
eq ExistIdentInstances(idcx,empty) = false .
eq ExistIdentInstances(idcx, < idcx,ctx,behlx,Mx >, Isx) = true  .
ceq ExistIdentInstances(idcx, < idcy,ctx,behlx,Mx >, Isx) = ExistIdentInstances(idcy,Isx) if (idcy =/= idcx) .





op ExistIdentBehListBeh(_,_) : IdentB BehaviorLs -> Bool .

ceq ExistIdentBehListBeh(idbehx, (idbehy ; beh) behL) = true if (idbehx == idbehy) .
ceq ExistIdentBehListBeh(idbehx, (idbehy ; beh) behL) = ExistIdentBehListBeh(idbehx,behL) if (idbehx =/= idbehy) .
eq ExistIdentBehListBeh(idbehx, nil) = false .

op NotPushBProg(_,_,_) : IdentC IdentB Program -> Bool .
op InstructionIspushB(_,_,_) : Instruction IdentC IdentB -> Bool .

eq InstructionIspushB(pushB(idcx,beh,idbehx), idcx,idbehx ) = true .
eq InstructionIspushB(inst, idcx,idbehx ) = false [owise] .

ceq NotPushBProg(idcx,idbehx,inst . Prog1) = NotPushBProg(idcx,idbehx,Prog1) if (not InstructionIspushB(inst,idcx,idbehx)) .
ceq NotPushBProg(idcx,idbehx,inst . Prog1) = false if (InstructionIspushB(inst,idcx,idbehx)) .
eq NotPushBProg(idcx,idbehx, []) = true .

------------traitement des fonction une par une------------------changement IdentC par IdentI pour dire id d'une instance
---op idAct(_,_) : IdentC Port -> IdFuncAct .
---op idRef(_,_) : IdentC Port -> IdFunRef .
---op idIsCon(_,_) : IdentC Connection -> IdFunIscon .
---op idDiscon(_,_) : IdentC Connection -> IdFunDis .
---op idComp(_,_) : IdentC IdentB -> IdFunComp .

ceq LocalEval (idAct(idcx,porx), Isx,Ls,pg) = bot if (not ExistIdentInstances(idcx,Isx)) . 
ceq LocalEval (idAct(idcx,porx), Isx,Ls,pg) = active(InstanceIdent(Isx,idcx),porx) if (ExistIdentInstances(idcx,Isx)) . 

ceq LocalEval (idRef(idcx,porx), Isx,Ls,pg) = bot if (not ExistIdentInstances(idcx,Isx)) . 
ceq LocalEval (idRef(idcx,porx), Isx,Ls,pg) = refusing(InstanceIdent(Isx,idcx),porx) if (ExistIdentInstances(idcx,Isx)) . 

eq LocalEval (idIsCon(idcx,l), Isx,Ls,pg) = l in Ls . 

eq LocalEval (idDiscon(idcx,l), Isx,Ls,pg) = disconnect(l,pg) . 

eq LocalEval (idComp(idcx,idbehx), < idcx,contcomp,behL,mark >,Isx,Ls,pg) =  (not ExistIdentBehListBeh(idbehx,behL) ) and NotPushBProg(idcx,idbehx,pg) .
ceq LocalEval (idComp(idcx,idbehx), Isx,Ls,pg) = true if ((not ExistIdentInstances(idcx,Isx) ) and NotPushBProg(idcx,idbehx,pg)) .
eq LocalEval (idComp(idcx,idbehx), Isx,Ls,pg) = false [owise] .
---eq LocalEval (idComp(idcx,idbehx), Isx,Ls,pg) = true . 
-------------------------extern evaluation
op ExternEval(_,_) : IdFunction ElementFunctionEs -> BoolWithBot .
var bwb : BoolWithBot .
ceq ExternEval(idf1, ee(idf2 ; bwb), efs ) = bwb if (idf1 == idf2) .
ceq ExternEval(idf1, ee(idf2 ; bwb), efs ) = ExternEval(idf1, efs ) if (idf1 =/= idf2) .

---------------global evaluation
op Eval(_,_,_,_,_) : IdFunction F Instances Connections Program -> BoolWithBot .
var lfs : ElementFunctionLs . 
var efs : ElementFunctionEs .
var ff : F .
ceq Eval(idf1,ff, Isx,Ls,pg ) = LocalEval(idf1,Isx,Ls,pg) if (LocalFun(idf1,ff)) .
ceq Eval(idf1,F(lfs,efs), Isx,Ls,pg ) = ExternEval(idf1,efs) if (ExternFun(idf1,F(lfs,efs))) .
eq Eval(idf1,ff, Isx,Ls,pg ) = bot [owise] .   -----------------------------------cas normaelement ne se produit jamais

-----------------------------------------------------------------des fonctions pour collecter les information externes

-----------function pour pouvoir executer disconnect
----,red CollectFunctionsDiscon( (idc1,us1,idc2,pr1),(ee(idAct(idc1,us1) ; bot), ee(idDiscon(idc1,idc1,us1,idc2,pr1) ; bot),empty,nil) .

op CollectFunctionsDiscon(_,_,_,_) : Connection ElementFunctionEs Ws Qsend -> Qsend .
---op IsFunctionActive(_,_) : IdFunction IdentC -> Bool .
var ws : Ws .
var qsen : Qsend .

---ceq IsFunctionActive(idAct(idcx,up),idcy) = true if (idcx == idcy) .
---eq IsFunctionActive(idf1,idcx) = false [owise] .


eq CollectFunctionsDiscon((idcx,use,idcy,pro),empty,ws,qsen) = nil .

ceq CollectFunctionsDiscon((idcx,use,idcy,pro),ee(idf1 ; bwb),efs,ws,qsen) = append(idf1,CollectFunctionsDiscon((idcx,use,idcy,pro),efs,ws,qsen)) 
if
( 
 (not (idf1 in ws)) and 
 (not (occurs(idf1,qsen))) 
 and 
 ( 
     ( idf1 == idAct(idcx,use)   and (bwb == true or bwb == bot)  ) 
   or
    ( (idf1 == idDiscon(idcy,(idcx,use,idcy,pro)) or idf1 ==  idDiscon(idcx,(idcx,use,idcy,pro)) ) and (bwb == false or bwb == bot) )
 ) 
) .
eq CollectFunctionsDiscon((idcx,use,idcy,pro),ee(idf1 ; bwb),efs,ws,qsen) = CollectFunctionsDiscon((idcx,use,idcy,pro),efs,ws,qsen) [owise] . 

-----------------------------------------------fonction pour la fonction wait
---CollectFunctionWait(idd1,idbeh,efes,Wx,QSx);

op CollectFunctionWait(_,_,_,_,_) : IdentC IdentB ElementFunctionEs Ws Qsend -> Qsend .

eq CollectFunctionWait(idcx,idbeh,empty,ws,qsen) = nil .
ceq CollectFunctionWait(idcx,idbeh,ee(idf1 ; bwb),efs,ws,qsen) = idf1 
if 
(
  (not (idf1 in ws)) and 
 (not (occurs(idf1,qsen))) 
 and
  (idf1 == idComp(idcx,idbeh)   and (bwb == false or bwb == bot))
) .
eq CollectFunctionWait(idcx,idbeh,ee(idf1 ; bwb),efs,ws,qsen) = CollectFunctionWait(idcx,idbeh,efs,ws,qsen) [owise] . 


--------------------------CollectFunctionFiring
op CollectFunctionFiring(_,_,_,_,_,_) : Marking Instances Connections ElementFunctionEs Ws Qsend -> Qsend .

eq CollectFunctionFiring(mm,I,empty,efs,ws,qsen) = nil .
ceq CollectFunctionFiring(mm,I,(idd1,use,idd2,pro),L,ee(idAct(idd1,use) ; bwb),efs,ws,qsen) = append(idAct(idd1,use),CollectFunctionFiring(mm,I,L,efs,ws,qsen))
if
(
(not (idAct(idd1,use) in ws)) and 
 (not (occurs(idAct(idd1,use),qsen))) and
 (bwb == true or bwb == bot) and
 ( (LocalEval(idAct(idd2,pro),I,empty,[] ) == true) and (activeMarking(InstanceIdent(I,idd2),pro,mm) == false ))   --- local eval puisque c local on l'applique directement
) .

eq CollectFunctionFiring(mm,I,(idd1,use,idd2,pro),L,efs,ws,qsen) = CollectFunctionFiring(mm,I,L,efs,ws,qsen) [owise] .

----------------------------------------------CollectFunction Entering Place
---CollectFunctionsEnteringPlace(Pi(s,GetStationPlaces(ct)), GetUsePort(ct), < idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >,
---< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) >,Ix, Lx,Fx,Wx,QSx)

op CollectFunctionsEnteringPlace(_,_,_,_,_,_,_,_,_) : Place GUses Instance Instance Instances Connections F Ws Qsend -> Qsend .

eq CollectFunctionsEnteringPlace(q,empty,i1,i2,Is,LL,F(lfs,efs),ws,qsen) = nil .
ceq CollectFunctionsEnteringPlace(q,(up ! p),gu,i1,i2,Is,LL,F(lfs,efs),ws,qsen) = 
append(CollectConnected(up,IdentInstance(i1),LL,F(lfs,efs),ws,qsen),append(CollectProvided(up,IdentInstance(i1),i1,Is,LL,F(lfs,efs),ws,qsen), 
append(CollectAllowed(up,IdentInstance(i1),i1,Is,LL,F(lfs,efs),ws,qsen), CollectFunctionsEnteringPlace(q,gu,i1,i2,Is,LL,F(lfs,efs),ws,qsen)))) 


if  ((q in p) and active(i1,up) == false and active(i2,up) == true  ).     ----------active puisque c local traitement directe
eq CollectFunctionsEnteringPlace(q,(up ! p),gu,i1,i2,Is,LL,F(lfs,efs),ws,qsen) = CollectFunctionsEnteringPlace(q,gu,i1,i2,Is,LL,F(lfs,efs),ws,qsen) [owise] .


op CollectConnected(_,_,_,_,_,_) : UsePort IdentC Connections F Ws Qsend -> Qsend . 
op CollectProvided(_,_,_,_,_,_,_) : UsePort IdentC  Instances Connections F Ws Qsend -> Qsend . 
op CollectAllowed(_,_,_,_,_,_,_) : UsePort  IdentC Instances Connections F Ws Qsend -> Qsend . 


------------------op Eval(_,_,_,_,_) : IdFunction F Instances Connections Program -> BoolWithBot .

eq CollectConnected(poru,IdentIns,empty,F(lfs,efs),ws,qsen) = nil .
ceq CollectConnected(poru,IdentIns,(iid1,up,iid2,pp),LL,F(lfs,efs),ws,qsen) = idIsCon(iid2,(iid1,up,iid2,pp))
if(
  (not (idIsCon(iid2,(iid1,up,iid2,pp)) in ws)) and 
 (not (occurs(idIsCon(iid2,(iid1,up,iid2,pp)),qsen)))  and
  ExternFun(idIsCon(iid2,(iid1,up,iid2,pp)),F(lfs,efs)) and
(poru == up and iid1 == IdentIns) and 
( Eval(idIsCon(iid2,(iid1,up,iid2,pp)),F(lfs,efs),empty,(iid1,up,iid2,pp),LL,[] )   == false  or Eval(idIsCon(iid2,(iid1,up,iid2,pp)),F(lfs,efs),empty,(iid1,up,iid2,pp),LL,[] )   == bot )
  
 ) .
eq CollectConnected(poru,IdentIns,(iid1,up,iid2,pp),LL,F(lfs,efs),ws,qsen) = CollectConnected(poru,IdentIns,LL,F(lfs,efs),ws,qsen) [owise] .



ceq CollectProvided(poru,IdentIns,Is,(iid1,up,iid2,pp),LL,F(lfs,efs),ws,qsen) = idAct(iid2,pp)
if (
    (not idAct(iid2,pp) in ws) and 
 (not (occurs(idAct(iid2,pp),qsen)))  and
  ExternFun(idAct(iid2,pp),F(lfs,efs)) and
(poru == up and iid1 == IdentIns) and 
( Eval(idAct(iid2,pp),F(lfs,efs),Is,(iid1,up,iid2,pp),LL,[] )   == false  or Eval(idAct(iid2,pp),F(lfs,efs),Is,(iid1,up,iid2,pp),LL,[] )   == bot )   
   ) .
eq CollectProvided(poru,IdentIns,Is,empty,F(lfs,efs),ws,qsen) = nil .
eq CollectProvided(poru,IdentIns,Is,(iid1,up,iid2,pp),LL,F(lfs,efs),ws,qsen) = CollectProvided(poru,IdentIns,Is,LL,F(lfs,efs),ws,qsen) [owise] .


ceq CollectAllowed(poru,IdentIns,Is,(iid1,up,iid2,pp),LL,F(lfs,efs),ws,qsen) = idRef(iid2,pp)
if (
    (not idRef(iid2,pp) in ws) and 
 (not (occurs(idRef(iid2,pp),qsen)))  and
  ExternFun(idRef(iid2,pp),F(lfs,efs)) and
(poru == up and iid1 == IdentIns) and 
( Eval(idRef(iid2,pp),F(lfs,efs),Is,(iid1,up,iid2,pp),LL,[] )   == true  or Eval(idRef(iid2,pp),F(lfs,efs),Is,(iid1,up,iid2,pp),LL,[] )   == bot )   
   ) .
eq CollectAllowed(poru,IdentIns,Is,empty,F(lfs,efs),ws,qsen) = nil .
eq CollectAllowed(poru,IdentIns,Is,(iid1,up,iid2,pp),LL,F(lfs,efs),ws,qsen) = CollectAllowed(poru,IdentIns,Is,LL,F(lfs,efs),ws,qsen) [owise] .


--------------------------------fonction supplementaire lors d'envoie de message on doit assurer la consistence des port

***(
op AllIdentInstances(_) : Instances -> IdentCs .   ---- return the set of ident of instances
eq AllIdentInstances(< iden,ct,bl,mm > ,I) = iden, AllIdentInstances(I)    .
eq AllIdentInstances(empty) = empty .
)


op EmptyorIdentforActive(_,_,_) : Connections IdFunction BoolWithBot -> IdentCs .
eq EmptyorIdentforActive((idd1,use,idd2,pro),Ls,idAct(idd1,use),false) = idd2 . 
eq EmptyorIdentforActive(empty,idf1,bwb) = empty . 
eq EmptyorIdentforActive((idd1,use,idd2,pro),Ls,idf1,bwb) = EmptyorIdentforActive(Ls,idf1,bwb) [owise] . 


op UpDateExternalFunctionsSend(_,_) : ElementFunctionEs IdentCs -> ElementFunctionEs .  -----------IdentCs contain one or 0 element
var identIs : IdentCs .
eq  UpDateExternalFunctionsSend(efs,empty) = efs .
eq  UpDateExternalFunctionsSend(empty,identIs) = empty .
ceq UpDateExternalFunctionsSend(ee(idRef(idd1,pro) ; bwb),efs,identIs) = ee(idRef(idd1,pro) ; bot), efs if (idd1 in identIs ) .
eq  UpDateExternalFunctionsSend(ee(idf1 ; bwb),efs,identIs) = ee(idf1 ; bwb), UpDateExternalFunctionsSend(efs,identIs) [owise] .


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


----------------------functions for evolution componenets
vars px py  : Place .

var Ts : Transitionns .
vars idd1 idd2 : IdentC .
var L : Connections .
var ct : ComponentType .
op restrict(_,_) : Transitionns Place -> Transitionns .
eq restrict(empty,px) = empty .
ceq restrict((t(px,S),Ts),py) = restrict(Ts,py) if (px =/= py) .
ceq restrict((t(px,S),Ts),py) = t(px,S), restrict(Ts,py) if (px == py) .

--- l'ensemble de connexion L' relatives a un ident de type provider

op ConnectionProIdent(_,_) : Connections IdentC -> Connections .

ceq ConnectionProIdent(((idd1,use,idd2,pro),L),id) = (idd1,use,idd2,pro), ConnectionProIdent(L,id) if(idd2 == id) .
ceq ConnectionProIdent(((idd1,use,idd2,pro),L),id) = ConnectionProIdent(L,id) if(idd2 =/= id) .
eq ConnectionProIdent(empty,id) = empty .


---- determiner l'instance associe a ident
op InstanceIdent(_,_) : Instances IdentC -> Instance . 

ceq  InstanceIdent((< iden,ct,bl,mm > ,I) , id ) = < iden,ct,bl,mm > if (iden == id) .
eq  InstanceIdent((< iden,ct,bl,mm > ,I) , id ) =  InstanceIdent( I , id ) [owise] .

----------New fonction  ConsistencyPort(m(ps,union(ts, restrict(b,p) ),tes) ,Ix,Fx,ConnectionProIdent(Lx, idd1 ))) .  for distributed Concerto
---op activeMarking(_,_,_) : Instance Port Marking -> Bool .
---Eval
----Eval(idAct(idd2,pro),ff, Isx,empty,[] )

op ConsistencyPort(_,_,_,_) : Marking Instances F Connections ->  Bool .


eq ConsistencyPort(mm,I,ff,(idd1,use,idd2,pro),L) = ConsistencyPort(mm,I,ff,L) and 
(
  ( (Eval(idAct(idd2,pro),ff, I,empty,[] ) == true) and (activeMarking(InstanceIdent(I,idd2),pro,mm) == false )) implies  (Eval(idAct(idd1,use),ff, I,empty,[] ) == false) ).

eq ConsistencyPort(mm,I,ff,empty) = true .





------------------a supprimer


op E(_) : Instance -> IdentC .
vars idcxxx idcyy : IdentC .
var behlxx : BehaviorLs .

---vars idcxx idcyy : IdentC .
---eq E(empty) = idc4 .
---ceq E(idcxx, < idcyy,ctx,behlx,Mx >, Isx) = E(idcyy,Isx) if (idcyy =/= idcxx) .
------------------endsup

op Itest : -> Instance .
op Ctest : -> ComponentType .
op Markk : -> Marking .
op bih : -> BehaviorLs .
op kz : -> IdentC .
eq E(< idcxxx,ctx,behlxx,Mx >) = idcxxx  .
---eq Ctest = < (q1, q2, q3),q1,r1 ; q1, r2 ; q2, r3 ; q3,t(q1,r2), t(q2,r3),b(t(q1,r2), t(q2,r3)),empty,pr1 ? (q2, q3) >     .
eq Itest = < kz,Ctest,nil,Markk > . 



------------------a supprimer c un test
***(
op E(_) : Instance -> IdentC .
var ctxx : ComponentType .
var behlxx : BehaviorLs .
var Mxx : Marking .
vars idcxxx idcyyy : IdentC .
---eq E(empty) = idc4 .
op Itest : -> Instance .
op Ctest : -> ComponentType .
op Markk : -> Marking .
op bih : -> BehaviorL .
op kz : -> IdentC .
eq E(< idcxxx,ctxx,behlxx,Mxx >) = idcxxx  .
eq Itest = < kz,Ctest,bih,Markk > . 

)

------------------endsup



-----------------endTest












endfm 
----------------Initialisation

fmod InitMod is

pr ModInstancesAndrComponentType .

ops c11 c22 : -> ComponentType .
ops confx confy : -> LocalConfiguration .
op gconf1 : -> LocalConfigurations .

eq c11 =  < (p1, p2, p3) , p1 , (s1 ; p1, s2 ; p2, s3 ; p3), (t(p1, s2), t(p2, s3) ), (b(t(p2, s3),t(p1, s2))) , us1 ! (p2, p3), empty   > .
eq c22 =  < (q1, q2, q3) , q1 , (r1 ; q1, r2 ; q2, r3 ; q3), (t(q1, r2), t(q2, r3) ), (b(t(q2, r3),t(q1, r2))) , empty, pr1 ? (q2,q3) > .


eq confx = < (empty, empty) , add(idc1,c11)  . con(idc1,us1,idc2,pr1) .  pushB(idc1,b(t(p1, s2), t(p2, s3)),idb1) . wait(idc2,idb2) . [], F(el(idIsCon(idc1,(idc1,us1,idc2,pr1))),el(idComp(idc1,idb1)),el(idAct(idc1,us1)),el(idDiscon(idc1,idc1,us1,idc2,pr1) ) , ee(idIsCon(idc2,(idc1,us1,idc2,pr1)) ; bot), ee(idComp(idc2,idb2) ; bot ) , ee(idRef(idc2,pr1) ; bot), ee(idAct(idc2,pr1) ; bot),ee(idDiscon(idc2,idc1,us1,idc2,pr1) ; bot)), nil, nil  , empty >  .

eq confy = < (empty, empty) , add(idc2,c22)  . con(idc1,us1,idc2,pr1) .  pushB(idc2,b(t(q1, r2), t(q2, r3)),idb2) .  wait(idc1,idb1) . [], F(el(idIsCon(idc2,(idc1,us1,idc2,pr1))),el(idComp(idc2,idb2)), el(idAct(idc2,pr1)),el(idRef(idc2,pr1)),el(idDiscon(idc2,idc1,us1,idc2,pr1))  ,ee(idIsCon(idc1,(idc1,us1,idc2,pr1)) ; bot), ee(idComp(idc1,idb1) ; bot ) , ee(idAct(idc1,us1) ; bot),ee(idDiscon(idc1,idc1,us1,idc2,pr1) ; bot)), nil, nil , empty >  .

eq gconf1 = confx, confy .

----eq confx = < (empty, empty) , add(idc1,c11)  . con(idc1,us1,idc2,pr1) .  pushB(idc1,b(t(p1, s2), t(p2, s3)),idb1) . dcon(idc1,us1,idc2,pr1) . [], F(el(idAct(idc1,us1)),el(idDiscon(idc1,idc1,us1,idc2,pr1) ) , ee(idAct(idc2,pr1) ; bot),ee(idDiscon(idc2,idc1,us1,idc2,pr1) ; bot)), nil, nil  , empty >  .

----eq confy = < (empty, empty) , add(idc2,c22)  . con(idc1,us1,idc2,pr1) .  pushB(idc2,b(t(q1, r2), t(q2, r3)),idb2) . dcon(idc1,us1,idc2,pr1) . [], F(el(idAct(idc2,pr1)),el(idDiscon(idc2,idc1,us1,idc2,pr1))  , ee(idAct(idc1,us1) ; bot),ee(idDiscon(idc1,idc1,us1,idc2,pr1) ; bot)), nil, nil , empty >  .

---eq confx = < (empty, empty) , add(idc1,c11)  . con(idc1,us1,idc2,pr1) .  pushB(idc1,b(t(p1, s2), t(p2, s3)),idb1) . [], F(el(idAct(idc1,us1) ) , ee(idAct(idc2,pr1) ; bot)), nil, nil  , empty >  .

---eq confy = < (empty, empty) , add(idc2,c22)  . con(idc1,us1,idc2,pr1) .  pushB(idc2,b(t(q1, r2), t(q2, r3)),idb2) . [], F(el(idAct(idc2,pr1) ) , ee(idAct(idc1,us1) ; bot)), nil, nil , empty >  .

---eq gconf1 = confx, confy .

---op idAct(_,_) : IdentC Port -> IdFuncAct .
---op idRef(_,_) : IdentC Port -> IdFunRef .
---op idIsCon(_,_) : IdentC Connection -> IdFunIscon .
---op idDiscon(_,_) : IdentC Connection -> IdFunDis .
---op idComp(_,_) : IdentC IdentB -> IdFunComp .
---Eval

endfm



------------------------------------------------------------------------------------------------------------------------------------------------
mod OperationalSemantics is

pr InitMod .

--- op < (_,_),_,_,_,_,_ > : Instances Connections Program F Qrec Qsend  Ws -> LocalConfiguration . 

var lcx lcy : LocalConfiguration .
var gconfig : LocalConfigurations .

vars Rx Ry : Program .
vars Ix Iy : Instances . 
vars Lx Ly : Connections .
vars Fx Fy : F .
vars QSx QSy : Qsend .
vars QRx QRy : Qrec .
vars Wx Wy : Ws .
var  idf : IdFunction .
var valf : BoolWithBot .

vars ct ctt : ComponentType .
var inst : Instance .
var use : UsePort .
var pro : ProPort .

var efls : ElementFunctionLs .
var efes : ElementFunctionEs .


ops i ii : -> Instance .
op ccc : -> ComponentType .

vars id idd1 idd2 : IdentC .
vars qb : BehaviorLs .
var behx : Behavior .
var mrk : Marking .
var  idbeh : IdentB .
var b : Transitionns .

vars p q : Place .
var ps : Places .
var ts : Transitionns .
var tr : Transitionn .
vars tes tes1 : TransitionnEndings .
var S : Stations .
var s : Station .
---- determiner l'instance associe a ident
---op InstanceIdent(_,_) : Instances Ident -> Instance . 
----var iden : Ident .
---var bl : BehaviorL .
-------------------------------------------------------------------------------------------------fonctions utilise dans les regles


--------------------------------------------Rules for communication----------------------------------------------------------------------

--------------a supprimer gconfig


crl [SendRequest] : 
< (Ix,Lx),Rx,Fx, QRx, idf QSx, Wx > , < (Iy,Ly),Ry,Fy,QRy,QSy,Wy >, gconfig  =>
< (Ix,Lx),Rx,Fx,QRx,QSx, (Wx, idf) > , < (Iy,Ly),Ry,Fy,append(QRy, (idf ; bot) ),QSy,Wy >, gconfig 
if ( ExternFun(idf,Fx) and LocalFun(idf,Fy) ) .


crl [SendEvalFun] : 
< (Ix,Lx),Rx,F(efls,efes), QRx, idf QSx, Wx > , < (Iy,Ly),Ry,Fy,QRy,QSy,Wy >, gconfig  =>
< (Ix,Lx),Rx,F(efls,UpDateExternalFunctionsSend(efes,EmptyorIdentforActive(Lx,idf,LocalEval(idf,Ix,Lx,Rx)))),QRx,QSx, Wx > , < (Iy,Ly),Ry,Fy,append(QRy, (idf ; LocalEval(idf,Ix,Lx,Rx)) ),QSy,Wy >, gconfig 
if ( LocalFun(idf,F(efls,efes)) and (idf in Wy) ) .

crl [ReceivesRequest] : 
< (Ix,Lx),Rx,Fx, (idf ; valf ) QRx,  QSx, Wx >, gconfig   =>
< (Ix,Lx),Rx,Fx,QRx,append(QSx, idf  ), Wx > , gconfig
if ( LocalFun(idf,Fx) ) .

crl [ReceivesEvalFun] : 
< (Ix,Lx),Rx,F(efls,efes), (idf ; valf ) QRx,  QSx, Wx >,  gconfig  =>
< (Ix,Lx),Rx,F(efls,SubValExtern(efes,idf,valf)),QRx,QSx, delete(idf,Wx) >,  gconfig 
if ( ExternFun(idf,F(efls,efes)) ) .  
---------------------------------------------end of communication rules---------------------------------------------
-------------------------------------------------Rules of evolution components

crl [FiringTransitionns] :  < (< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,Lx),Rx,Fx, QRx,  QSx, Wx > , gconfig  =>
< (  < idd1,ct,(idbeh ; b(b)) qb,m(ps,union(ts, restrict(b,p) ),tes) >, Ix , Lx),Rx,Fx, QRx, QSx, Wx > , gconfig 
if (restrict(b,p) =/= empty and ConsistencyPort(m(ps,union(ts, restrict(b,p) ),tes) ,Ix,Fx,ConnectionProIdent(Lx, idd1 ))) .  

rl [EndingTransitionn] : < (< idd1,ct, qb,m(ps, t(q,s,S), ts,tes) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig =>
< (< idd1,ct, qb,m(ps, ts, te(t(q,s,S),s), tes  ) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig .



crl [EnteringPlace] : < (< idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig  =>
 < (< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) > , Ix,Lx),Rx,Fx, QRx,  QSx, Wx > , gconfig  

if 
(IsSatisfiedTransitionnEndingStation(s,b,te(t(q,s,S),s), tes) 
and 

ConnectedProvidedAllowed (Pi(s,GetStationPlaces(ct)), GetUsePort(ct), < idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >,
< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) >,Ix, Lx,Fx)) 
.  

crl [FinishingBehavior] : < (< idd1,ct,(idbeh ; b(b)) qb,m(ps,empty,empty) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig  =>
< (< idd1,ct, qb,m(ps,empty,empty) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig if (intersection(ps,PlacesTrans(b)) == empty) .


------------------------------------------------------End collecting rules-------------------------------
-----------------------------------------------------Rules  for collecting the evaluation of external functions------------



crl [ExternalFunctionsFiringTransitionns] : < (< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,Lx),Rx,F(efls,efes), QRx,  QSx, Wx > , gconfig  =>
< (  < idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix , Lx),Rx,F(efls,efes), QRx, append(QSx,CollectFunctionFiring(m(ps,union(ts, restrict(b,p) ),tes),< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,ConnectionProIdent(Lx, idd1 ),efes,Wx,QSx)), Wx > , gconfig 
if (restrict(b,p) =/= empty and CollectFunctionFiring(m(ps,union(ts, restrict(b,p) ),tes),< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,ConnectionProIdent(Lx, idd1 ),efes,Wx,QSx) =/= nil) . 



crl [ExternalFunctionsEnteringPlace] : < (< idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig =>
 < (< idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,Lx),Rx,Fx, QRx, append(QSx,CollectFunctionsEnteringPlace(Pi(s,GetStationPlaces(ct)), GetUsePort(ct), < idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >,
< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) >,Ix, Lx,Fx,Wx,QSx)), Wx > , gconfig

if 
(
  IsSatisfiedTransitionnEndingStation(s,b,te(t(q,s,S),s), tes) 
  and
  (CollectFunctionsEnteringPlace(Pi(s,GetStationPlaces(ct)), GetUsePort(ct), < idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >,
< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) >,Ix, Lx,Fx,Wx,QSx) =/= nil )
) .


crl [ExternalFunctionsForDisconnectPorts] : 
< (Ix,Lx), dcon(idd1,use,idd2,pro) . Rx,F(efls,efes), QRx, QSx, Wx > , gconfig    =>  
< (Ix,Lx), dcon(idd1,use,idd2,pro) . Rx,F(efls,efes), QRx, append(QSx,CollectFunctionsDiscon((idd1,use,idd2,pro),efes,Wx,QSx)), Wx > , gconfig   
if (((idd1,use,idd2,pro) in Lx)  and (CollectFunctionsDiscon((idd1,use,idd2,pro),efes,Wx,QSx) =/= nil) ) .

crl [ExternalFunctionsForWait] :
< (Ix,Lx), wait(idd1,idbeh) . Rx,F(efls,efes), QRx, QSx, Wx > , gconfig    =>  
< (Ix,Lx), wait(idd1,idbeh) . Rx,F(efls,efes), QRx, append(QSx,CollectFunctionWait(idd1,idbeh,efes,Wx,QSx)), Wx > , gconfig   
if (CollectFunctionWait(idd1,idbeh,efes,Wx,QSx) =/= nil ) .

--------------------------------------------------------End of evolution components---------------------------------------------------------------
------------------------------------------------------- Instructions of program------------------------------------------------------------------------- 

crl [AddComponentInstance] :   < (Ix,Lx), add(id, ct) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>
 < (insert( < id, ct, nil, m(InitialPlace(ct) ,empty,empty)  > , Ix),Lx),  Rx,Fx, QRx, QSx, Wx > ,gconfig if not IsUsedIdentInstances(id,Ix)   .  


crl [DeleteComponentInstance] : < (< idd1,ct,qb,mrk > ,Ix,Lx), del(id) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>   
< (Ix,Lx), Rx,Fx, QRx, QSx, Wx > , gconfig  if (id == idd1 and (not InConnectionIdent(id,Lx)) ) . 

crl [ConnectPorts] : < (Ix,Lx), con(id,use,idd1,pro) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>   
< (Ix,(id,use,idd1,pro),Lx), Rx,Fx, QRx, QSx, Wx > , gconfig  
if (id =/= idd1 and ((InstanceIdent(Ix,id) in Ix) or (InstanceIdent(Ix,idd1) in Ix)) and (not InConnectionIdentUsePort(id,use,Lx)) ) . ---peut etre reduit la condition comme dans les règles


crl [DisconnectPorts] : < (Ix,Lx), dcon(id,use,idd1,pro) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>  
< (Ix,delete((id,use,idd1,pro),Lx)), Rx,Fx, QRx, QSx, Wx > , gconfig  
if
(  ((id,use,idd1,pro) in Lx)
  and
Eval(idDiscon(id,(id,use,idd1,pro)),Fx,Ix,Lx,dcon(id,use,idd1,pro) . Rx) == true
and
Eval(idDiscon(idd1,(id,use,idd1,pro)),Fx,Ix,Lx,dcon(id,use,idd1,pro) . Rx) == true
and
Eval(idAct(id,use),Fx,Ix,Lx,dcon(id,use,idd1,pro) . Rx) == false

) .


crl [PushingBehavior] : < (< idd1,ct,qb,mrk >,Ix,Lx), pushB(id, behx, idbeh) . Rx,Fx, QRx, QSx, Wx > , gconfig
=>   < (< idd1,ct,append(qb,(idbeh ; behx)),mrk >,Ix,Lx),  Rx,Fx, QRx, QSx, Wx > , gconfig 
if (id == idd1 and IsBehaviorOfComponent(behx,ct)) .
  

crl [Waiting] : < ( < idd1,ct,qb,mrk > ,Ix,Lx), wait(id,idbeh) . Rx,Fx, QRx, QSx, Wx > , gconfig
=>   < ( < idd1,ct,qb,mrk > ,Ix,Lx), Rx,Fx, QRx, QSx, Wx > , gconfig
if (Eval(idComp(id,idbeh),Fx,Ix,Lx, Rx) == true ) . 


-----------------------------------------------rule for Global Configuration
---crl [GlobalConfiguration] : gconfig, lcx => gconfig, lcy if lcx => lcy /\  gconfig =/= empty .


endm




