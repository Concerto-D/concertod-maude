
***(

  This file contains the Maude program for Concerto-D
    content: 
    A - several functional modules to describe mainly data types and operations on these types
    B - a system module to describe operational rules.

    A - Functional modules (FM) :
    
    () FM-1- a functional module called DECLARATION-SORTS that defines only a few sorts. 
        Defining these sorts first enables us to create views on them, which allows us to use the views to 
        create predefined Maude structures for our sorts. 
        Example: we need to create a set on our sort Place, so we start with the following steps:
            * declare Place in the first module.
            * build a view `Place` which is mapping from the module `TRIV` to the module `DECLARATION-SORTS`.
              The `TRIV` module is a trivial module which has a single sort Elt. the view will be:

                      view Place from TRIV to DECLARATION-SORTS is
                        sort Elt to Place .
                      endv
              
            * we can then import pr SET{Place} .  
            which allows you to parameterize the predefined module SET{X :: TRIV} by Place and thus define a set structure on Place
    
      Module DECLARATION-SORTS is followed by a view declarations to use 

    () From FM-2 to FM-14  gives the definition of our used sorts ant its equations, starting from basic sorts such as place, station, port ...etc. 
       to the Configuration module for our configuration sort
    
    () From FM-15 to FM22 Some principal functions used in the operating rules are modeled separately. 
       These functions are mainly related to :
       * modules for port consistency during the execution of rules releted to firing transition or entering place
       * modules to select the external functions required in the rules
       * modules for defining communication operations
    
    () FM23 contains the operational rules of Concert-D         
)

-------------------------------------------------- fonctional module FM1 -------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
fmod DECLARATION-SORTS is 

sorts Place StationPlace Station IdentC ElementFunctionL ElementFunctionE send rec W Connection Instance LocalConfiguration .
sorts Transitionn TransitionnEnding Behavior BehaviorId GUse GPro .


endfm

--------------------------------------------------------view definitions -----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
view Place from TRIV to DECLARATION-SORTS is

  sort Elt to Place .

endv

view StationPlace from TRIV to DECLARATION-SORTS is
  sort Elt to StationPlace .
endv

view Station from TRIV to DECLARATION-SORTS is
  sort Elt to Station .
endv

view IdentC from TRIV to DECLARATION-SORTS is
 sort Elt to IdentC .
endv

view ElementFunctionL from TRIV to DECLARATION-SORTS is
  sort Elt to ElementFunctionL .
endv

view ElementFunctionE from TRIV to DECLARATION-SORTS is
  sort Elt to ElementFunctionE .
endv

view send from TRIV to DECLARATION-SORTS is
  sort Elt to send .
endv

view rec from TRIV to DECLARATION-SORTS is
  sort Elt to rec .
endv

view W from TRIV to DECLARATION-SORTS is
  sort Elt to W .
endv


view Connection from TRIV to DECLARATION-SORTS is
 sort Elt to Connection .
endv
 
view Instance from TRIV to DECLARATION-SORTS is
  sort Elt to Instance .
endv

view LocalConfiguration from TRIV to DECLARATION-SORTS is
  sort Elt to LocalConfiguration .
endv


view Transitionn from TRIV to DECLARATION-SORTS is
  sort Elt to Transitionn .
endv


view TransitionnEnding from TRIV to DECLARATION-SORTS is
  sort Elt to TransitionnEnding .
endv

view Behavior from TRIV to DECLARATION-SORTS is
  sort Elt to Behavior .
endv

view BehaviorId from TRIV to DECLARATION-SORTS is
  sort Elt to BehaviorId .
endv

view GUse from TRIV to DECLARATION-SORTS is
sort Elt to GUse .
endv

view GPro from TRIV to DECLARATION-SORTS is
 sort Elt to GPro .
endv

-------------------------------------------------------------- fonctional modules from FM-2 to FM-14 --------------------------
--------------------------------------------------------------------Concerto-D Data types--------------------------------------

fmod PLACE is
  inc DECLARATION-SORTS . ---to include the defined sort "Place"
  sorts InitPlace Places . --- definie two sorts
  subsort InitPlace < Place . --- InitPlace is a subsort of Place
  pr SET{Place} .  --- Import the parameterized module of SET of Place 
  subsort Set{Place} <  Places  .  --- declare the Place set as a sub-type of Places. 
  ----So, Places with s represents the sort for the set of Places 

---Places are defined here as operations without parameters
--- for each system to be analyzed, the corresponding operations must be generated for its Places
--- The same reasoning then applies to the stations, use ports and port ports of the system.
--- An alternative way to avoid modifying the code relating to Place operations for each system
--- is to declare places as strings:
--- pr STRING
---subsort String < Place . in this case, the following code will not be necessary
  op p1 : -> InitPlace .
  op q1 : -> InitPlace .
  ops p2 p3 p4 p5 p6 p7 p8 p9 p10 : -> Place .
  ops q2 q3 q4 q5 q6 q7 q8 q9 q10 : -> Place .

endfm

fmod STATION is
  inc DECLARATION-SORTS . ------to include the defined sort "Station"
  sort Stations .
  pr SET{Station} . 
  subsort Set{Station} <  Stations  . 

  ---Like Places, explicit stations of system
  ops s1 s2 s3 s4 s5 s6 s7 s8 s9 s10   : -> Station .
  ops r1 r2 r3 r4 r5 r6 r7 r8 r9 r10   : -> Station .
  

endfm

fmod STATION-PLACE is
  inc DECLARATION-SORTS . ---to include the defined sort "StationPlace"
  inc PLACE .
  inc STATION .

  sort StationPlaces .
  pr SET{StationPlace} . 
  subsort Set{StationPlace} <  StationPlaces . --- StationPlaces define a set of elements of sort StationPlace

  vars st1 st2 : Station .
  var S : Stations .
  var SPs : StationPlaces .
  var q : Place .
  var ps : Places .

  op(_;_) : Station Place -> StationPlace . --- an element StationPlace is a tuple (Station;Place)
  
  op Pi(_,_) : Station StationPlaces -> Place . --- gives the corresponding place for a station according to the "StationPlaces" set
 
  ceq Pi(st1, ((st2 ; q),SPs)) = q if (st1 == st2) .
  eq Pi(st1, ((st2 ; q),SPs)) = Pi(st1,SPs) [owise] .  ---otherwise

  op StationsGplaces(_,_) : Places StationPlaces -> Stations .  --- gives the stations associated to a Places group

  ceq StationsGplaces(ps,(st1 ; q),SPs) = st1, StationsGplaces(ps,SPs) if(q in ps) .
  ceq StationsGplaces(ps,(st1 ; q),SPs) =  StationsGplaces(ps,SPs) if(not(q in ps)) .
  eq StationsGplaces(ps,empty) = empty .


 
endfm

fmod IDENT-COMPENENT-BEHAVIOR is
  inc DECLARATION-SORTS . ---to include the defined sort "IdentC"
  
  sorts IdentCs IdentB  .  ---defines two sorts : a set of IdentCs for component IDs (IdentC) and a sort for behavior IDs (IdentB) 
  
  pr SET{IdentC} .
  subsort Set{IdentC} < IdentCs . 
  
  --- description of previously defined sorts IdentC and IdentB
  ops idc1 idc2 idc3 idc4 : -> IdentC .
  ops idb1 idb2 idb3 idb4 : -> IdentB .
  
endfm


fmod PORT is
  sort Port .

  sorts UsePort ProPort .
  subsorts UsePort ProPort < Port .

  ops us1 us2 us3 us4 : -> UsePort .
  ops pr1 pr2 pr3 pr4 : -> ProPort .

endfm

fmod BOOL-WITH-BOT is  --- a new sort to represent the 3 values : true, false and bot based on predefined sort bool
  pr BOOL . --- importation of sort BOOL
  
  sort Bot .
  sort BoolWithBot .
  subsorts Bool  Bot < BoolWithBot .

  op bot : -> Bot .
endfm

fmod CONNECTION is
  inc DECLARATION-SORTS . --- ---to include the defined sort "Connection"
  inc IDENT-COMPENENT-BEHAVIOR .
  inc PORT .
  
  sort  Connections . 
  
  pr SET{Connection} .  
  subsort Set{Connection} < Connections . 

  op (_,_,_,_) : IdentC UsePort IdentC ProPort -> Connection .  --- Define a new operator to create a Connection

  var  L : Connections .  
  vars poru up : UsePort .
  var pp : ProPort . 
  vars id id1 id2 : IdentC .  

  --- some operations related to the connections used later

  op InConnectionIdentUsePort(_,_,_) :  IdentC UsePort Connections -> Bool . --- checks whether an IdentC of a UsePort is in Connections

  eq  InConnectionIdentUsePort(id,poru,empty) = false . 
  eq InConnectionIdentUsePort(id1,up,((id1,up,id2,pp),L)) = true  .  
  eq InConnectionIdentUsePort(id,poru,((id1,up,id2,pp),L)) = InConnectionIdentUsePort(id,poru,L) [owise] .  

  op InConnectionIdent(_,_) :  IdentC Connections -> Bool .   --- checks whether an IdentC of a UsePort is in Connections 

  eq  InConnectionIdent(id,empty) = false .  
  ceq InConnectionIdent(id,((id1,up,id2,pp),L)) = true if (id1 == id or id2 == id) .  
  eq InConnectionIdent(id,((id1,up,id2,pp),L)) = InConnectionIdent(id,L) [owise] .  

  op ConnectionProIdent(_,_) :  IdentC Connections -> Connections .  --- checks if an IdentC is in role Provide Port within connections

  eq ConnectionProIdent(id,empty) = empty .
  eq ConnectionProIdent(id2,((id1,up,id2,pp),L)) = (id1,up,id2,pp), ConnectionProIdent(id2,L)  .  
  eq ConnectionProIdent(id,((id1,up,id2,pp),L)) = ConnectionProIdent(id,L) [owise] .  

endfm

fmod ID-FUNCTIONS-COMMUNICATED is

  inc IDENT-COMPENENT-BEHAVIOR .
  inc PORT .
  inc CONNECTION .

  sort IdFunction .
  sorts IdFuncAct IdFunRef IdFunIscon IdFunDis IdFunComp .
  subsorts IdFuncAct IdFunRef IdFunIscon IdFunDis IdFunComp < IdFunction .

  --- we have 5 types of functions to communicate
  op idAct(_,_) : IdentC Port -> IdFuncAct .  ---for active
  op idRef(_,_) : IdentC Port -> IdFunRef .    --- for refusing
  op idIsCon(_,_) : IdentC Connection -> IdFunIscon .  --- for a connection if it is established
  op idDiscon(_,_) : IdentC Connection -> IdFunDis .  --- for diconnect instruction
  op idComp(_,_) : IdentC IdentB -> IdFunComp .  --- for complete execution of behavior
  
endfm


fmod TRANSITION-TRANSITION-ENDING is
  inc PLACE .
  inc STATION .
  inc DECLARATION-SORTS . --- to include the defined sorts  Transitionn and TransitionnEnding .
  sorts Transitionns TransitionnEndings .  --- Transitionn is used  as sort beacause Transition is reserved 
   
  pr SET{Transitionn} .
  subsort Set{Transitionn} < Transitionns .
  
  pr SET{TransitionnEnding} .
  subsort Set{TransitionnEnding} < TransitionnEndings . 
 
  op t(_,_) : Place Stations -> Transitionn .   --- define Transition
  op te(_,_) : Transitionn Station -> TransitionnEnding . --- define Transition Ending

  var pla1 pla2 : Place .
  var ps : Places .
  vars S1 S2 : Stations .
  vars st1 st2 : Station .
  var trans : Transitionns .
  var tes : TransitionnEndings .

  --- some operations related to Transitionn and TransitionnEnding used later

  op PlacesTrans(_) : Transitionns -> Places .  --- recupere l'ensemble de places liés a certaines transitions
  eq PlacesTrans(empty) = empty .
  eq PlacesTrans(t(pla1,S1),trans) = pla1, PlacesTrans(trans) .

  op RestrictTransToPlace(_,_) : Transitionns Place -> Transitionns . --- restriction des transitions liée à une place
  
  eq RestrictTransToPlace(empty,pla1) = empty .
  eq RestrictTransToPlace((t(pla1,S1),trans),pla1) = t(pla1,S1), RestrictTransToPlace(trans,pla1)  .
  eq RestrictTransToPlace((t(pla2,S1),trans),pla1) = RestrictTransToPlace(trans,pla1) [owise] .
 
  op RemoveTransitionnEndingStation(_,_) : TransitionnEndings Station -> TransitionnEndings . 
  --- delete transition endings of a station 
  
  eq RemoveTransitionnEndingStation(empty,st1) = empty .
  eq RemoveTransitionnEndingStation(te(t(pla1,S1),st1),tes,st1) = RemoveTransitionnEndingStation(tes,st1) .
  eq RemoveTransitionnEndingStation(te(t(pla1,S1),st1),tes,st2) = te(t(pla1,S1),st1),RemoveTransitionnEndingStation(tes,st2) [owise] .
  
  op TranElt(_,_,_) : Places Transitionns Stations -> Transitionns .   
 ---retrieve transitions starting from a place of a set of places and ending in stations included in a set of stations.
  
  eq TranElt(ps,empty,S1) = empty .
  ceq TranElt(ps,t(pla1,S2),trans,S1) = t(pla1,S2),TranElt(ps,trans,S1) if (pla1 in ps and (S2 subset S1)) .
  eq TranElt(ps,t(pla1,S2),trans,S1) = TranElt(ps,trans,S1) [owise] .
 
  op TranEndElt(_,_) : Transitionn Stations -> TransitionnEndings .  
  ---Construct the transition endings of a transition according to a set of Stations

  eq TranEndElt(t(pla1,S2), st1,S1)= union(te(t(pla1,S2),st1), TranEndElt(t(pla1,S2), S1) ) .
  eq TranEndElt(t(pla1,S2),empty) = empty . 

  op TranEndElts(_) : Transitionns -> TransitionnEndings .  
  ---Construct the transition endings of a set of transitions
  
  eq TranEndElts(t(pla1,S1),trans) = union(TranEndElt(t(pla1,S1),S1), TranEndElts(trans) ) .
  eq TranEndElts(empty) = empty .


  op IsSatisfiedTransitionnEndingStation(_,_,_) : Station Transitionns TransitionnEndings -> Bool .
  ----is used in the entering place rule
  ---- the parameters used are : a chosen station, the current transitions of a behavior and the trnasition endings of the instance concerned
  --- the principale is : if a station is chosen as a station of the ending of a transition 
  ---then for all transitions of the current behavior for which the chosen station is one of its stations
  ----the transition endings of these transitions according to this station must be included in the trnasition endings of the instances.
  eq IsSatisfiedTransitionnEndingStation(st1,empty,tes) = true .
  ceq IsSatisfiedTransitionnEndingStation(st1,t(pla1,S1),trans,tes) = IsSatisfiedTransitionnEndingStation(st1,trans,tes) 
  if(not(st1 in S1) or (te(t(pla1,S1),st1) in tes) ) .
  ceq IsSatisfiedTransitionnEndingStation(st1,t(pla1,S1),trans,tes) = false 
  if( (st1 in S1) and (not(te(t(pla1,S1),st1) in tes)) ) .
  ---- if we consider that each place has only one station, we can propose a simplified version

endfm 

fmod MARKING is
  inc TRANSITION-TRANSITION-ENDING .
  sort Marking . --- Define a new sort Marking
  
  vars ps1 ps2 : Places .
  vars trans1 trans2 : Transitionns .
  vars tre1 tre2 : TransitionnEndings .
  
  op m(_,_,_) : Places Transitionns TransitionnEndings -> Marking .  --- Define a new operator to create a Marking
  
  op PlMar : Marking -> Places . ---- gives the places of a marking
  eq PlMar(m(ps1,trans1,tre1)) = ps1 .

  op TrMar : Marking -> Transitionns . --- gives the transitions of a marking
  eq TrMar(m(ps1,trans1,tre1)) = trans1 .

  op TrEnMar : Marking -> TransitionnEndings . --- gives the transition endings of a marking
  eq TrEnMar(m(ps1,trans1,tre1)) = tre1 .

  op  IntersectionMarking(_,_) : Marking Marking -> Marking . --- intersection of two markings
  eq  IntersectionMarking(m(ps1,trans1,tre1),m(ps2,trans2,tre2)) = 
  m(intersection(ps1,ps2),intersection(trans1,trans2),intersection(tre1,tre2)) .

  op NotEmptyMarking(_) : Marking -> Bool .  ---to check if a given Marking is empty
  eq NotEmptyMarking(m(ps1,trans1,tre1)) = (ps1 =/= empty or trans1 =/= empty or tre1 =/= empty ) .

endfm

fmod BEHAVIOR is
  inc TRANSITION-TRANSITION-ENDING .
  inc IDENT-COMPENENT-BEHAVIOR .

  pr DECLARATION-SORTS . --- to include the defined sorts Behavior BehaviorId .

  sorts Behaviors QBehavoirId .  ---define new sorts 

  pr SET{Behavior} .
  subsort Set{Behavior} < Behaviors .  --- Behaviors is set of Behavior
    
  pr LIST{BehaviorId} .
  subsort List{BehaviorId} < QBehavoirId . --- QBehaviorId est une liste pour les element de sort BehaviorId 

  op b(_) : Transitionns -> Behavior .   ---un behavoir est un ensemble de transitions
  op (_;_) : IdentB Behavior -> BehaviorId . ---BehaviorId est un Behavior avec Identification

  vars idbehx idbehy : IdentB .
  var behL : QBehavoirId .
  var beh : Behavior .

  op ExistIdentBehListBeh(_,_) : IdentB QBehavoirId -> Bool .  ---to check if a behavior identifier is used in the behavior list  

  eq ExistIdentBehListBeh(idbehx, nil) = false .
  eq ExistIdentBehListBeh(idbehx, (idbehx ; beh) behL) = true .
  eq ExistIdentBehListBeh(idbehx, (idbehy ; beh) behL) = ExistIdentBehListBeh(idbehx,behL) [owise] .

endfm


fmod COMPENENT-TYPE is
  
  inc STATION-PLACE .
  inc TRANSITION-TRANSITION-ENDING .
  inc BEHAVIOR .
  inc PORT .
  inc DECLARATION-SORTS . --- to include the defined sorts GUse GPro 
  inc MARKING . 
  
  sorts ComponentType GUses GPros .  ---define new sorts
  
  pr SET{GUse} .
  subsort Set{GUse} < GUses . --- Guses is a set of GUse

  pr SET{GPro} .
  subsort Set{GPro} < GPros . ---GPros is a set of GPro  

  vars ps pG : Places .
  var q : InitPlace .
  var sps : StationPlaces .
  var ts  : Transitionns . 
  var bs : Behaviors .
  var gu : GUses .
  var gp : GPros .
  vars poru up : UsePort .
  vars porp pp : ProPort .
  var beh  : Behavior .

  op (_!_) : UsePort Places -> GUse . --- GUse is defined as tuple : the use port and a group (set) of places
  op (_?_) : ProPort Places -> GPro . --- GPro is defined as tuple : the provide port and a group (set) of places
  op < _,_,_,_,_,_,_ > : Places InitPlace StationPlaces Transitionns Behaviors GUses GPros -> ComponentType . ---Component type definition

  --- some operations related to ComponentType used later
  op InitialPlace(_) : ComponentType -> Place .  --- to get the initial place of component type
  
  eq InitialPlace (< ps,q,sps,ts,bs,gu,gp >) = q .

  op GetStationPlaces(_) : ComponentType -> StationPlaces . --- to get the set of tuples (station; place)
  
  eq GetStationPlaces (< ps,q,sps,ts,bs,gu,gp >) = sps .

  op GetUsePort(_) : ComponentType -> GUses . --- to get the set of the use ports of the component

  eq GetUsePort (< ps,q,sps,ts,bs,gu,gp >) = gu .

  op PlaceUse(_,_) : UsePort GUses -> Places . --- to get places of a use port from a set of use ports
 
  eq PlaceUse(up,empty) = empty .
  eq PlaceUse(up,(up ! ps),gu) = ps . 
  eq PlaceUse(up,(poru ! ps),gu) = PlaceUse(up,gu) [owise] . 
   
  op PlacePro(_,_) : ProPort GPros -> Places . --- to get places of a provide port from a set of use ports

  eq PlacePro(pp,empty) = empty .
  eq PlacePro(pp,(pp ? ps),gp) = ps  . 
  eq PlacePro(pp,(porp ? ps),gp) = PlacePro(pp,gp) [owise] . 
   
  op G(_,_) : Port ComponentType -> Places . --- to get places of a port use or provide
  
  eq G(up,< ps,q,sps,ts,bs,gu,gp >) = PlaceUse(up,gu)  .
  eq G(pp,< ps,q,sps,ts,bs,gu,gp > ) = PlacePro(pp,gp)  .

  op IsBehaviorOfComponent(_,_) : Behavior ComponentType -> Bool . 
  --- to check whether a behavior is used in ComponentType, in particular in its behaviors

  eq IsBehaviorOfComponent(beh,< ps,q,sps,ts,bs,gu,gp >) = beh in bs .
  
  op elements(_,_) : Places ComponentType -> Marking .   
  --- gives the elements of Marking (places, transitions, transitionendings) of group of places depending a ComponentType

  eq elements(pG,< ps,q,sps,ts,bs,gu,gp >) = m( pG, TranElt(pG,ts,StationsGplaces(pG,sps)), TranEndElts(TranElt(pG,ts,StationsGplaces(pG,sps))) ) .

endfm

fmod PROGRAM is
  
  inc COMPENENT-TYPE .
  inc IDENT-COMPENENT-BEHAVIOR .
  inc CONNECTION .
  sorts Program Instruction . ---define new sorts

  var Prog : Program .
  var l : Connection .
  var inst : Instruction .
  var idcx : IdentC .
  var idbehx : IdentB .
  var beh : Behavior .

  op add(_,_) : IdentC ComponentType -> Instruction .
  op del(_) : IdentC -> Instruction .
  op pushB(_,_,_) : IdentC Behavior IdentB -> Instruction .
  op con(_) : Connection -> Instruction .
  op dcon(_) : Connection -> Instruction .
  op wait(_,_) : IdentC IdentB -> Instruction .
  op [] : -> Program [ctor] .  ---operator is a constructor
  op _._ : Instruction Program -> Program [ctor] . ---operator is a constructor

 --- some operations related to Program used later
  op NotDcon(_,_) :  Connection Program -> Bool .  
  ---check for a given connection, there is no dcon instrcution in a given program
 
  eq NotDcon(l,[]) = true .
  eq NotDcon(l,inst . Prog) = (inst =/= dcon(l) and NotDcon(l,Prog)) .

  op disconnect(_,_) : Connection Program -> Bool .  
  --- used to check that the dcon instruction is the current instruction or has already been executed
  ---then it is the same as checking that the remaining program does not contain dcon after the current instruction
  --- this reasoning is correct if we assume that Concerto programs are well constructed.
  eq disconnect(l,[]) = true .
  eq disconnect(l,inst . Prog) = NotDcon(l,Prog) .
  
  op InstructionIspushB(_,_,_) : Instruction IdentC IdentB -> Bool .  
  --- checks whether the current instruction is a push instruction for a given IdentC and IdentB

  eq InstructionIspushB(pushB(idcx,beh,idbehx), idcx,idbehx ) = true .
  eq InstructionIspushB(inst, idcx,idbehx ) = false [owise] .

  op NotPushBProg(_,_,_) : IdentC IdentB Program -> Bool .  
  ---checks that in a given program there is no push behavior instruction for IdentC and IdentB
  
  eq NotPushBProg(idcx,idbehx, []) = true .
  ceq NotPushBProg(idcx,idbehx,inst . Prog) = NotPushBProg(idcx,idbehx,Prog) if (not InstructionIspushB(inst,idcx,idbehx)) .
  ceq NotPushBProg(idcx,idbehx,inst . Prog) = false if (InstructionIspushB(inst,idcx,idbehx)) .
  
endfm

fmod INSTANCE is
  
  inc COMPENENT-TYPE .
  inc BEHAVIOR .
  inc IDENT-COMPENENT-BEHAVIOR .
  inc MARKING . 
  inc DECLARATION-SORTS . ------ to include the defined sort instance
  sort Instances .
  pr SET{Instance} .
  subsort Set{Instance} < Instances . 

  vars pla1 pla2 : Place . 
  var ps : Places .
  vars  idcx idcy : IdentC .
  var idbeh : IdentB .
  vars S1 S2 : Stations .
  var bl : QBehavoirId .
  vars mark mm : Marking .
  var por : Port . 
  vars t1 trans : Transitionns .
  var tre : TransitionnEndings .
  var ct : ComponentType .
  var Is : Instances .

  op <_,_,_,_> : IdentC ComponentType QBehavoirId Marking -> Instance . ---Instance definition

  op IdentInstance(_) : Instance -> IdentC .  --- gives the id of an instance

  eq IdentInstance(< idcx,ct,bl,mark > ) = idcx .

  op IsUsedIdentInstances(_,_) : IdentC Instances -> Bool . ---to check if an id of instance is used in the set of instances

  eq IsUsedIdentInstances(idcx, empty) = false .
  eq IsUsedIdentInstances(idcx, < idcx,ct,bl,mark >, Is) = true  .
  eq IsUsedIdentInstances(idcx, < idcy,ct,bl,mark >, Is) = IsUsedIdentInstances(idcx, Is) [owise] .

  op InstanceIdent(_,_) : Instances IdentC -> Instance . ---gives the instance identified by a given Id
  --- applied only when we are sure that the instance exists. 
  --- So the problem of empty instances doesn't occur.
  eq  InstanceIdent((< idcx,ct,bl,mark >  ,Is) , idcx ) = < idcx,ct,bl,mark >  .
  eq  InstanceIdent((< idcy,ct,bl,mark > ,Is) , idcx ) =  InstanceIdent(Is,idcx) [owise] .

  op AllTranQuitGroupPlace(_,_,_) : Place Transitionns Stations -> Bool .  
  --- check that for a given place and for all its transitions, the stations of its transitions are different from the stations given as parameters
  --- used later to express that places in a group necessarily leave the group according to current behavior
  eq  AllTranQuitGroupPlace(pla1,empty,S1) = true .
  ceq AllTranQuitGroupPlace(pla1,t(pla2,S1),t1,S2) = AllTranQuitGroupPlace(pla1,t1,S2) if ((pla1 =/= pla2)  or   intersection(S1,S2) == empty ) .  
  eq  AllTranQuitGroupPlace(pla1,t(pla2,S1),t1,S2) = false [owise] .

  op ExistSourceTranPlace(_,_) : Place Transitionns -> Bool .  
  --- check whether for a place and a set of transitions there is a transition among these transitions whose source place is the place in question .
  eq  ExistSourceTranPlace(pla1,empty) = false .
  eq  ExistSourceTranPlace(pla1,t(pla1,S1),t1) = true .
  eq  ExistSourceTranPlace(pla1,t(pla2,S1),t1) = ExistSourceTranPlace(pla1,t1)  [owise].

  op ExitGroupPlace(_,_,_) : Place QBehavoirId Stations -> Bool .  
  --- check if a place leaves a group according to the current behavior and the stations associated with the places of the group.
  eq ExitGroupPlace(pla1,nil,S1) = false . ---a place "puit" does not leave the group
  eq ExitGroupPlace(pla1,(idbeh ; b(t1)) bl,S1) = ExistSourceTranPlace(pla1,t1) and AllTranQuitGroupPlace(pla1,t1,S1) . 

  op AllExitGroup(_,_,_) : Places QBehavoirId Stations -> Bool .  
  --- check whether for certain places and according to the current transitions in the behavior list 
  ---the transitions of these places necessarily leave the group. this last condition is determined on the stations associated with the places (3rd parameter).
  eq AllExitGroup(empty,bl,S1) = true .  --- empty places satisfay all transitions of empty exit group
  eq AllExitGroup((pla1,ps),bl,S1)  = ExitGroupPlace(pla1,bl,S1) and AllExitGroup(ps,bl,S1) .  

  op active(_,_) : Instance Port -> Bool .   --- active function
  ---valid when at least the places, tansitions or transition endings marking is non-empty for a given port
  eq active(< idcx,ct,bl,m(ps,trans,tre) >,por) = NotEmptyMarking(IntersectionMarking(elements(G(por,ct),ct),m(ps,trans,tre))) .

  op activeMarking(_,_,_) : Instance Port Marking -> Bool . --- special case of active with 3 parameters

  eq activeMarking(< idcx,ct,bl,m(ps,trans,tre) >,por,mm) = NotEmptyMarking(IntersectionMarking(elements(G(por,ct),ct),mm)) .

  op refusing(_,_) : Instance Port -> Bool .  --- refusing function
  --- a port is refused when only places are marked, 
  ---and all marked places are ready to leave the group of places of the port according to the current behavior.
  ceq refusing(< idcx,ct,bl,m(ps,trans,tre) >,por) = true if  
  (AllExitGroup(PlMar(IntersectionMarking(elements(G(por, ct),ct),m(ps,trans,tre))),bl,StationsGplaces(G(por,ct),GetStationPlaces(ct))) and
  TrMar(IntersectionMarking(elements(G(por,ct),ct),m(ps,trans,tre))) == empty and 
  TrEnMar(IntersectionMarking(elements(G(por,ct),ct),m(ps,trans,tre))) == empty 
   )  .

  eq refusing(< idcx,ct,bl,m(ps,trans,tre) >,por) = false [owise] .

endfm

fmod CONCERTO-D-CONFIGURATION is 

  inc ID-FUNCTIONS-COMMUNICATED .
  inc INSTANCE .
  inc PROGRAM .
  inc CONNECTION .
  inc BOOL-WITH-BOT .
  inc DECLARATION-SORTS . ------ to include the defined sorts LocalConfiguration ElementFunctionL ElementFunctionE send rec W

  sorts  LocalConfigurations  ElementFunctionLs ElementFunctionEs Ws . ---define new sorts of type set
  sorts  Qsend Qrec  . ---define new sorts of type list
  sort  F . --- define the new sort F
  subsort IdFunction  < W . --- Idfunction is also an element of W 
  subsort IdFunction  < send . ---- Idfunction is also an element of the send 

  --- define lists and sets for the included sorts
  pr SET{ElementFunctionL} .
    subsort Set{ElementFunctionL} < ElementFunctionLs . 

  pr SET{ElementFunctionE} .
    subsort Set{ElementFunctionE} < ElementFunctionEs . 
  
  pr SET{W} .
    subsort Set{W} < Ws . 

  pr SET{LocalConfiguration} .
    subsort Set{LocalConfiguration} < LocalConfigurations . 

  pr LIST{send} .
    subsort List{send} < Qsend . 

  pr LIST{rec} .
    subsort List{rec} < Qrec . 

  vars  idf1 idf2 : IdFunction .
  var ff : F .
  var lfs : ElementFunctionLs .
  var efs : ElementFunctionEs .
  vars Newbwb bwb : BoolWithBot .
  var Is : Instances .
  var idcx : IdentC .
  var idbeh : IdentB .
  var ct : ComponentType .
  var por : Port .
  var Ls : Connections .
  var pg : Program .
  var l : Connection .
  var behL : QBehavoirId .
  var mark : Marking .

  op el(_) : IdFunction  ->   ElementFunctionL .  --- local functions of configuration to send their evaluation
  op ee(_;_) : IdFunction BoolWithBot ->   ElementFunctionE .  ---external function to receive their evaluation with current evaluation. 
  ---initially the current evaluation is bot
  op F(_,_) :  ElementFunctionLs ElementFunctionEs -> F .  --- all functions to be communicated local or external
  op (_;_) :  IdFunction BoolWithBot  -> rec .  --- an element to receive
  op < (_,_),_,_,_,_,_ > : Instances Connections Program F Qrec Qsend  Ws -> LocalConfiguration .   --- definition of local configuration

  --- some functions on configuration
  op LocalFun(_,_) : IdFunction F -> Bool .  --- determine whether an Id of a function is local to a configuration
  eq LocalFun(idf1, F(empty,efs )) = false .
  eq LocalFun(idf1, F((el(idf1),lfs),efs )) = true .
  eq LocalFun(idf1, F((el(idf2),lfs),efs )) = LocalFun(idf1, F(lfs,efs )) [owise].
  
  op ExternFun(_,_) : IdFunction F -> Bool . --- determine whether an Id of a function is extern to a configuration
  eq ExternFun(idf1, F(lfs,empty )) = false .
  eq ExternFun(idf1, F(lfs,ee(idf1 ; bwb),efs )) = true  .
  eq ExternFun(idf1, F(lfs,ee(idf2 ; bwb),efs )) = ExternFun(idf1, F(lfs,efs)) [owise] .

  op ExternEval(_,_) : IdFunction ElementFunctionEs -> BoolWithBot .  
  ---obtain the evalaution of an external function from a set of external functions
  eq ExternEval(idf1, ee(idf1 ; bwb), efs ) = bwb  .
  eq ExternEval(idf1, ee(idf2 ; bwb), efs ) = ExternEval(idf1, efs ) [owise] .

  op SubValExtern(_,_,_) : ElementFunctionEs IdFunction BoolWithBot -> ElementFunctionEs .  
  --- substitutes the evaluation of an external function from a set of external functions
  eq SubValExtern(empty,idf1,Newbwb) = empty . 
  eq SubValExtern((ee(idf1 ; bwb),efs),idf1,Newbwb) = ee(idf1 ; Newbwb), efs  .
  eq SubValExtern((ee(idf1 ; bwb),efs),idf2,Newbwb) = ee(idf1 ; bwb), SubValExtern(efs,idf2,Newbwb) [owise] .
 
  op LocalEval(_,_,_,_) : IdFunction Instances Connections Program -> BoolWithBot .  
  ---- gives the evaluation of a local function according to certain parameters of a given configuration

  ceq LocalEval (idAct(idcx,por), Is,Ls,pg) = false if (not IsUsedIdentInstances(idcx,Is)) .   ---if the instance does not yet exist, then the active function = false
  eq LocalEval (idAct(idcx,por), Is,Ls,pg) = active(InstanceIdent(Is,idcx),por) [owise] . 

  ceq LocalEval (idRef(idcx,por), Is,Ls,pg) = true if (not IsUsedIdentInstances(idcx,Is)) . ---if the instance does not yet exist, then the refusing function = true 
  eq LocalEval (idRef(idcx,por), Is,Ls,pg) = refusing(InstanceIdent(Is,idcx),por) [owise] . 

  eq LocalEval (idIsCon(idcx,l), Is,Ls,pg) = l in Ls . 

  eq LocalEval (idDiscon(idcx,l), Is,Ls,pg) = disconnect(l,pg) . 

  eq LocalEval (idComp(idcx,idbeh), < idcx,ct,behL,mark >,Is,Ls,pg) =  (not ExistIdentBehListBeh(idbeh,behL) ) and NotPushBProg(idcx,idbeh,pg) .
 --- the corresponding instance of a wait behavior exists. Then, the evaluation depends on whether or not push idbeh exists in the program or in the behavior list.
  ceq LocalEval (idComp(idcx,idbeh), Is,Ls,pg) = true if ((not IsUsedIdentInstances(idcx,Is) ) and NotPushBProg(idcx,idbeh,pg)) .
  --- special case the instance doesn't exist and even the push of idbeh in the program. this is the case when a program is executed and its instance is deleted.
  eq LocalEval (idComp(idcx,idbeh), Is,Ls,pg) = false [owise] .

  op Eval(_,_,_,_,_) : IdFunction F Instances Connections Program -> BoolWithBot .  --- gives the evaluation according to the two cases local or external
  ceq Eval(idf1,ff, Is,Ls,pg ) = LocalEval(idf1,Is,Ls,pg) if (LocalFun(idf1,ff)) .
  ceq Eval(idf1,F(lfs,efs), Is,Ls,pg ) = ExternEval(idf1,efs) if (ExternFun(idf1,F(lfs,efs))) .
  eq Eval(idf1,ff,Is,Ls,pg ) = bot [owise] .  -------case normally never occurs a function is local or extern

endfm

--------------------------------------some principal functions used in the operating rules ------------------------------------------------
---------------------------------------------------------modeled separately  ------------------------------------------------

fmod CONSISTENCY-PORTS-FIRING-TRANSITION is

  inc CONCERTO-D-CONFIGURATION .

  var newMark : Marking .
  var I : Instances .
  vars id1 id2 : IdentC .
  var up : UsePort .
  var pp : ProPort .
  var L : Connections .
  var f : F .

  op NotActUseWhenLeavingPro(_,_,_,_) : Marking Instances F Connections ->  Bool .
  ---   is used to ensure consistency when firing transitions
  ---   it takes as parameters when used in the firing transition rule: 
  ----  the new marking after firing, the instances of the concerned local configuration,
  ---   F for the evaluation of functions and a subset of Connections relted to the local configuration where the instance concerned by firing is a provider.
  ---   so for each connection it checks that the firing of the concerned instance (provider) does not affect the corresponding user
  ---   i.e., if the provider for each connection after a firing goes from active to inactive, this implies that the user must be inactive.

  eq NotActUseWhenLeavingPro(newMark,I,f,(id1,up,id2,pp),L) = NotActUseWhenLeavingPro(newMark,I,f,L) and 
  (
    ( (Eval(idAct(id2,pp),f, I,empty,[] ) == true) and 
    (activeMarking(InstanceIdent(I,id2),pp,newMark) == false )) 
    implies  (Eval(idAct(id1,up),f, I,empty,[] ) == false) 
  ) .

  eq NotActUseWhenLeavingPro(newMark,I,f,empty) = true .

endfm


fmod CONSISTENCY-PORTS-ENTERING-PLACE is

  inc CONCERTO-D-CONFIGURATION .

  var pla : Place .
  var ps : Places .
  var gu :  GUses .
  vars i i' : Instance .
  var Is : Instances .
  var L : Connections .
  var f : F .
  vars poru up : UsePort .
  var pp : ProPort .
  vars IdentIns id1 id2 : IdentC .

  op ConnectedProvidedAllowed(_,_,_,_,_,_,_) : Place GUses Instance Instance Instances Connections F -> Bool . 
  ---  for the entreing place rule, in addition to the IsSatisfiedTransitionnEndingStation condition modeled earlier on 
  ---  the choice of a station as an ending for a transition, we need the satifaction of ConnectedProvidedAllowed

  ---  this function takes as parameters: the place concerned by the station chosen for the rule, 
  ---  the uses ports of the instance concerned by the rule, the instance itself before the rule is fired and after the rule is fired, 
  ---  the other instances of the configuration as well as its connections and the tuple F of communication functions.

  ---  so for each use port of the instance concerned by the rule, we perform the following check:
  ---  if, by applying the rule, the status of this port is changed from inactive to active, 
  ---  knowing that the place of the function belongs to this use port, then
  ---  three conditions must be met Connected, provided and allowed
  eq ConnectedProvidedAllowed(pla,empty,i,i',Is,L,f) = true .
  ceq ConnectedProvidedAllowed(pla,(up ! ps),gu,i,i',Is,L,f) = 
  Connected(up,IdentInstance(i),L,f)  and 
  Provided(up,IdentInstance(i),i,Is,L,f)   and 
  Allowed(up,IdentInstance(i),i,Is,L,f)   and 
  ConnectedProvidedAllowed(pla,gu,i,i',Is,L,f) 
  if  ((pla in ps) and active(i,up) == false and active(i',up) == true  ).     
  ----------in the previous condition we use active directly since it's a local treatment for the concerned configuration
  eq ConnectedProvidedAllowed(pla,(up ! ps),gu,i,i',Is,L,f) = ConnectedProvidedAllowed(pla,gu,i,i',Is,L,f) [owise] .

  op Connected(_,_,_,_) : UsePort IdentC Connections F -> Bool . 
  ---  connection must be verified on both user and provider instances
  eq Connected(up,id1,empty,f) = false .
  ceq Connected(up,id1,(id1,up,id2,pp),L,f) = true 
  if(Eval(idIsCon(id2,(id1,up,id2,pp)),f,empty,(id1,up,id2,pp),L,[] )   == true ) .
  eq Connected(poru,IdentIns,(id1,up,id2,pp),L,f) = Connected(poru,IdentIns,L,f) [owise] .

  op Provided(_,_,_,_,_) : UsePort IdentC  Instances Connections F -> Bool .
  --- there is an active provide port connected to this use port of the instance concerned
  eq Provided(up,id1,Is,empty,f) = false .
  eq Provided(up,id1,Is,(id1,up,id2,pp),L,f) = (Eval(idAct(id2,pp),f,Is,empty,[] ) == true) .
  eq Provided(poru,IdentIns,Is,(id1,up,id2,pp),L,f) = Provided(poru,IdentIns,Is,L,f) [owise] .

  op Allowed(_,_,_,_,_) : UsePort  IdentC Instances Connections F -> Bool . 
  --- also theprovide port connected to this use port of the instance must not be refused
  eq Allowed(up,id1,Is,empty,f) = false .
  eq Allowed(up,id1,Is,(id1,up,id2,pp),L,f) = (Eval(idRef(id2,pp),f,Is,empty,[] ) == false) . 
  eq Allowed(poru,IdentIns,Is,(id1,up,id2,pp),L,f) = Allowed(poru,IdentIns,Is,L,f) [owise] .

endfm



fmod COLLECT-EXTERNAL-FUNCTIONS-FIRING is

  inc CONCERTO-D-CONFIGURATION .

  var Is : Instances .
  var L : Connections .
  var bwb : BoolWithBot .
  var up : UsePort .
  var pp : ProPort .
  vars  id1 id2 : IdentC .
  var newMark : Marking .
   var f : F .
  var ws : Ws .
  var qsend : Qsend .

        

  op CollectFunctionFiring(_,_,_,_,_,_) : Marking Instances Connections F Ws Qsend -> Qsend .
  --- used to determine the information of external functions that allow to apply the rule firing transition. 
  --- it aims to build a list of external idAct functions for use ports whose current value does not allow the rule to be applied; in other words,
  --- its evaluation = true or bot knowing that the provide port linked to this use port wants to change the status of its provide port from active to inactive.
  --- in this case, we add the function idAct of this use port to the list of external information, on condition that the request for this function is not currently being processed.
  --- this last condition is verified if idAct doesn't belong to either Ws or Qsend, therefore this function also takes these two parameters into account
  eq CollectFunctionFiring(newMark,Is,empty,f,ws,qsend) = nil .
  ceq CollectFunctionFiring(newMark,Is,(id1,up,id2,pp),L,f,ws,qsend) = 
  append(idAct(id1,up),CollectFunctionFiring(newMark,Is,L,f,ws,qsend))
  if
  (   
  (not idAct(id1,up) in ws) and 
  (not (occurs(idAct(id1,up),qsend)))  and
    ExternFun(idAct(id1,up),f) and
  ( Eval(idAct(id1,up),f,empty,empty,[] )   == true  or Eval(idAct(id1,up),f,empty,empty,[] )   == bot ) and
  ( (LocalEval(idAct(id2,pp),Is,empty,[] ) == true) and (activeMarking(InstanceIdent(Is,id2),pp,newMark) == false ))  
  ) .

  eq CollectFunctionFiring(newMark,Is,(id1,up,id2,pp),L,f,ws,qsend) = CollectFunctionFiring(newMark,Is,L,f,ws,qsend) [owise] .


endfm

fmod COLLECT-EXTERNAL-FUNCTIONS-ENTERING-PLACE is

  inc CONCERTO-D-CONFIGURATION .

  var p : Place .
  var ps : Places .
  var gu :  GUses .
  vars i i' : Instance .
  var Is : Instances .
  var L : Connections .
  var f : F .
  vars poru up : UsePort .
  var pp : ProPort .
  vars IdentIns id1 id2 : IdentC .
  var ws : Ws .
  var qsend : Qsend .
  var idf1 : IdFunction .

  op CollectFunctionsEnteringPlace(_,_,_,_,_,_,_,_,_) : Place GUses Instance Instance Instances Connections F Ws Qsend -> Qsend .
  --- we follow the same reasoning used to collect external functions for firing
  eq CollectFunctionsEnteringPlace(p,empty,i,i',Is,L,f,ws,qsend) = nil .
  ceq CollectFunctionsEnteringPlace(p,(up ! ps),gu,i,i',Is,L,f,ws,qsend) = 
  append(CollectConnected(up,IdentInstance(i),L,f,ws,qsend),append(CollectProvided(up,IdentInstance(i),i,Is,L,f,ws,qsend), 
  append(CollectAllowed(up,IdentInstance(i),i,Is,L,f,ws,qsend), CollectFunctionsEnteringPlace(p,gu,i,i',Is,L,f,ws,qsend)))) 
  if  ((p in ps) and active(i,up) == false and active(i',up) == true  ).   
  eq CollectFunctionsEnteringPlace(p,(up ! ps),gu,i,i',Is,L,f,ws,qsend) = CollectFunctionsEnteringPlace(p,gu,i,i',Is,L,f,ws,qsend) [owise] .

  op CollectConnected(_,_,_,_,_,_) : UsePort IdentC Connections F Ws Qsend -> Qsend . 
  op CollectProvided(_,_,_,_,_,_,_) : UsePort IdentC  Instances Connections F Ws Qsend -> Qsend . 
  op CollectAllowed(_,_,_,_,_,_,_) : UsePort  IdentC Instances Connections F Ws Qsend -> Qsend . 

  eq CollectConnected(poru,IdentIns,empty,f,ws,qsend) = nil .
  ceq CollectConnected(poru,IdentIns,(id1,up,id2,pp),L,f,ws,qsend) = idIsCon(id2,(id1,up,id2,pp))
  if(
    (not (idIsCon(id2,(id1,up,id2,pp)) in ws)) and 
  (not (occurs(idIsCon(id2,(id1,up,id2,pp)),qsend)))  and
    ExternFun(idIsCon(id2,(id1,up,id2,pp)),f) and
  (poru == up and id1 == IdentIns) and 
  ( Eval(idIsCon(id2,(id1,up,id2,pp)),f,empty,empty,[] )   == false  or Eval(idIsCon(id2,(id1,up,id2,pp)),f,empty,empty,[] )   == bot )
    
  ) .
  eq CollectConnected(poru,IdentIns,(id1,up,id2,pp),L,f,ws,qsend) = CollectConnected(poru,IdentIns,L,f,ws,qsend) [owise] .


  eq CollectProvided(poru,IdentIns,Is,empty,f,ws,qsend) = nil .
  ceq CollectProvided(poru,IdentIns,Is,(id1,up,id2,pp),L,f,ws,qsend) = idAct(id2,pp)
  if (
      (not idAct(id2,pp) in ws) and 
  (not (occurs(idAct(id2,pp),qsend)))  and
    ExternFun(idAct(id2,pp),f) and
  (poru == up and id1 == IdentIns) and 
  ( Eval(idAct(id2,pp),f,empty,empty,[] )   == false  or Eval(idAct(id2,pp),f,empty,empty,[] )   == bot )   
    ) .
  eq CollectProvided(poru,IdentIns,Is,(id1,up,id2,pp),L,f,ws,qsend) = CollectProvided(poru,IdentIns,Is,L,f,ws,qsend) [owise] .

  eq CollectAllowed(poru,IdentIns,Is,empty,f,ws,qsend) = nil .
  ceq CollectAllowed(poru,IdentIns,Is,(id1,up,id2,pp),L,f,ws,qsend) = idRef(id2,pp)
  if (
      (not idRef(id2,pp) in ws) and 
  (not (occurs(idRef(id2,pp),qsend)))  and
    ExternFun(idRef(id2,pp),f) and
  (poru == up and id1 == IdentIns) and 
  ( Eval(idRef(id2,pp),f,empty,empty,[] )   == true  or Eval(idRef(id2,pp),f,empty,empty,[])   == bot )   
    ) .

  eq CollectAllowed(poru,IdentIns,Is,(id1,up,id2,pp),L,f,ws,qsend) = CollectAllowed(poru,IdentIns,Is,L,f,ws,qsend) [owise] .

endfm




fmod COLLECT-EXTERNAL-FUNCTIONS-WAIT is

inc CONCERTO-D-CONFIGURATION .


var bwb : BoolWithBot .

var  id1 : IdentC .
var idbeh : IdentB .
var efs : ElementFunctionEs .
var ws : Ws .
var qsend : Qsend .
var idf1 : IdFunction .


op CollectFunctionWait(_,_,_,_,_) : IdentC IdentB ElementFunctionEs Ws Qsend -> Qsend .

eq CollectFunctionWait(id1,idbeh,empty,ws,qsend) = nil .
ceq CollectFunctionWait(id1,idbeh,ee(idf1 ; bwb),efs,ws,qsend) = idf1 
if 
(
  (not (idf1 in ws)) and 
 (not (occurs(idf1,qsend))) 
 and
  (idf1 == idComp(id1,idbeh)   and (bwb == false or bwb == bot))
) .
eq CollectFunctionWait(id1,idbeh,ee(idf1 ; bwb),efs,ws,qsend) = CollectFunctionWait(id1,idbeh,efs,ws,qsend) [owise] . 

endfm

fmod COLLECT-EXTERNAL-FUNCTIONS-DISCONNECT is

inc CONCERTO-D-CONFIGURATION .


op CollectFunctionsDiscon(_,_,_,_) : Connection ElementFunctionEs Ws Qsend -> Qsend .

var bwb : BoolWithBot .

var up : UsePort .
var pp : ProPort .
vars  id1 id2 : IdentC .
var efs : ElementFunctionEs .
var ws : Ws .
var qsend : Qsend .
var idf1 : IdFunction .



eq CollectFunctionsDiscon((id1,up,id2,pp),empty,ws,qsend) = nil .

ceq CollectFunctionsDiscon((id1,up,id2,pp),ee(idf1 ; bwb),efs,ws,qsend) = append(idf1,CollectFunctionsDiscon((id1,up,id2,pp),efs,ws,qsend)) 
if
( 
 (not (idf1 in ws)) and 
 (not (occurs(idf1,qsend))) 
 and 
 ( 
     ( idf1 == idAct(id1,up)   and (bwb == true or bwb == bot)  ) 
   or
    ( (idf1 == idDiscon(id1,(id1,up,id2,pp)) or idf1 ==  idDiscon(id2,(id1,up,id2,pp)) ) and (bwb == false or bwb == bot) )
 ) 
) .
eq CollectFunctionsDiscon((id1,up,id2,pp),ee(idf1 ; bwb),efs,ws,qsend) = CollectFunctionsDiscon((id1,up,id2,pp),efs,ws,qsend) [owise] . 


endfm



fmod COMMUNICATION-FUNCTIONS is

inc CONCERTO-D-CONFIGURATION .


var idents : IdentCs . 
var efs : ElementFunctionEs .
var bwb : BoolWithBot .
var L : Connections .
var up : UsePort .
var pp : ProPort .
var idf1 : IdFunction .
vars id1 id2 : IdentC .

op UpDateExternalFunctionsSend(_,_) : ElementFunctionEs IdentCs -> ElementFunctionEs .  -----------IdentCs contain one or 0 element
eq  UpDateExternalFunctionsSend(efs,empty) = efs .
eq  UpDateExternalFunctionsSend(empty,idents) = empty .
ceq UpDateExternalFunctionsSend(ee(idRef(id1,pp) ; bwb),efs,idents) = ee(idRef(id1,pp) ; bot), efs if (id1 in idents ) .
eq  UpDateExternalFunctionsSend(ee(idf1 ; bwb),efs,idents) = ee(idf1 ; bwb), UpDateExternalFunctionsSend(efs,idents) [owise] .


op IdentConnectionWithActive(_,_,_) : Connections IdFunction BoolWithBot -> IdentCs .
eq IdentConnectionWithActive((id1,up,id2,pp),L,idAct(id1,up),false) = id2 . 
eq IdentConnectionWithActive(empty,idf1,bwb) = empty . 
eq IdentConnectionWithActive((id1,up,id2,pp),L,idf1,bwb) = IdentConnectionWithActive(L,idf1,bwb) [owise] . 

endfm


mod OPERATIONAL-SEMANTICS is

inc CONCERTO-D-CONFIGURATION .

inc CONSISTENCY-PORTS-FIRING-TRANSITION .
inc CONSISTENCY-PORTS-ENTERING-PLACE .
inc COLLECT-EXTERNAL-FUNCTIONS-FIRING .
inc COLLECT-EXTERNAL-FUNCTIONS-WAIT .
inc COLLECT-EXTERNAL-FUNCTIONS-DISCONNECT .
inc COLLECT-EXTERNAL-FUNCTIONS-ENTERING-PLACE .
inc COMMUNICATION-FUNCTIONS .

var lcx lcy : LocalConfiguration .
var gconfig : LocalConfigurations .

vars Rx Ry : Program .
vars Ix Iy : Instances . 
vars Lx Ly : Connections .
vars Fx Fy : F .
vars QSx QSy : Qsend .
vars QRx QRy : Qrec .
vars Wx Wy : Ws .
var  idf : IdFunction .
var valf : BoolWithBot .

vars ct ctt : ComponentType .
var inst : Instance .
var use : UsePort .
var pro : ProPort .

var efls : ElementFunctionLs .
var efes : ElementFunctionEs .


ops i ii : -> Instance .
op ccc : -> ComponentType .

vars id idd1 idd2 : IdentC .
vars qb : QBehavoirId .
var behx : Behavior .
var mrk : Marking .
var  idbeh : IdentB .
var b : Transitionns .

vars p q : Place .
var ps : Places .
var ts : Transitionns .
var tr : Transitionn .
vars tes tes1 : TransitionnEndings .
var S : Stations .
var s : Station .


--------------------------------------------Rules for communication----------------------------------------------------------------------



crl [SendRequest] : 
< (Ix,Lx),Rx,Fx, QRx, idf QSx, Wx > , < (Iy,Ly),Ry,Fy,QRy,QSy,Wy >, gconfig  =>
< (Ix,Lx),Rx,Fx,QRx,QSx, (Wx, idf) > , < (Iy,Ly),Ry,Fy,append(QRy, (idf ; bot) ),QSy,Wy >, gconfig 
if ( ExternFun(idf,Fx) and LocalFun(idf,Fy) ) .


crl [SendEvalFun] : 
< (Ix,Lx),Rx,F(efls,efes), QRx, idf QSx, Wx > , < (Iy,Ly),Ry,Fy,QRy,QSy,Wy >, gconfig  =>
< (Ix,Lx),Rx,F(efls,UpDateExternalFunctionsSend(efes,IdentConnectionWithActive(Lx,idf,LocalEval(idf,Ix,Lx,Rx)))),QRx,QSx, Wx > , < (Iy,Ly),Ry,Fy,append(QRy, (idf ; LocalEval(idf,Ix,Lx,Rx)) ),QSy,Wy >, gconfig 
if ( LocalFun(idf,F(efls,efes)) and (idf in Wy) ) .

crl [ReceivesRequest] : 
< (Ix,Lx),Rx,Fx, (idf ; valf ) QRx,  QSx, Wx >, gconfig   =>
< (Ix,Lx),Rx,Fx,QRx,append(QSx, idf  ), Wx > , gconfig
if ( LocalFun(idf,Fx) ) .

crl [ReceivesEvalFun] : 
< (Ix,Lx),Rx,F(efls,efes), (idf ; valf ) QRx,  QSx, Wx >,  gconfig  =>
< (Ix,Lx),Rx,F(efls,SubValExtern(efes,idf,valf)),QRx,QSx, delete(idf,Wx) >,  gconfig 
if ( ExternFun(idf,F(efls,efes)) ) .  



-------------------------------------------------Rules of evolution components--------------------

crl [FiringTransitionns] :  < (< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,Lx),Rx,Fx, QRx,  QSx, Wx > , gconfig  =>
< (  < idd1,ct,(idbeh ; b(b)) qb,m(ps,union(ts, RestrictTransToPlace(b,p) ),tes) >, Ix , Lx),Rx,Fx, QRx, QSx, Wx > , gconfig 
if (RestrictTransToPlace(b,p) =/= empty and 
NotActUseWhenLeavingPro(m(ps,union(ts, RestrictTransToPlace(b,p) ),tes) ,< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > ,Ix,Fx,ConnectionProIdent(idd1, Lx))) .  

rl [EndingTransitionn] : < (< idd1,ct, qb,m(ps, t(q,s,S), ts,tes) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig =>
< (< idd1,ct, qb,m(ps, ts, te(t(q,s,S),s), tes  ) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig .



crl [EnteringPlace] : < (< idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig  =>
 < (< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) > , Ix,Lx),Rx,Fx, QRx,  QSx, Wx > , gconfig  

if 
(IsSatisfiedTransitionnEndingStation(s,b,te(t(q,s,S),s), tes) 
and 

ConnectedProvidedAllowed (Pi(s,GetStationPlaces(ct)), GetUsePort(ct), < idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >,
< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) >,Ix, Lx,Fx)) 
.  

crl [FinishingBehavior] : < (< idd1,ct,(idbeh ; b(b)) qb,m(ps,empty,empty) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig  =>
< (< idd1,ct, qb,m(ps,empty,empty) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig if (intersection(ps,PlacesTrans(b)) == empty) .




-------------------------------------------Rules  for collecting the evaluation of external functions------------



crl [ExternalFunctionsFiringTransitionns] : < (< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,Lx),Rx,Fx, QRx,  QSx, Wx > , gconfig  =>
< (  < idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix , Lx),Rx,Fx, QRx, append(QSx,CollectFunctionFiring(m(ps,union(ts, RestrictTransToPlace(b,p) ),tes),< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,ConnectionProIdent(idd1,Lx),Fx,Wx,QSx)), Wx > , gconfig 
if (RestrictTransToPlace(b,p) =/= empty and CollectFunctionFiring(m(ps,union(ts, RestrictTransToPlace(b,p) ),tes),< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,ConnectionProIdent(idd1,Lx ),Fx,Wx,QSx) =/= nil) . 



crl [ExternalFunctionsEnteringPlace] : < (< idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig =>
 < (< idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,Lx),Rx,Fx, QRx, append(QSx,CollectFunctionsEnteringPlace(Pi(s,GetStationPlaces(ct)), GetUsePort(ct), < idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >,
< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) >,Ix, Lx,Fx,Wx,QSx)), Wx > , gconfig

if 
(
  IsSatisfiedTransitionnEndingStation(s,b,te(t(q,s,S),s), tes) 
  and
  (CollectFunctionsEnteringPlace(Pi(s,GetStationPlaces(ct)), GetUsePort(ct), < idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >,
< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) >,Ix, Lx,Fx,Wx,QSx) =/= nil )
) .


crl [ExternalFunctionsForDisconnectPorts] : 
< (Ix,Lx), dcon(idd1,use,idd2,pro) . Rx,F(efls,efes), QRx, QSx, Wx > , gconfig    =>  
< (Ix,Lx), dcon(idd1,use,idd2,pro) . Rx,F(efls,efes), QRx, append(QSx,CollectFunctionsDiscon((idd1,use,idd2,pro),efes,Wx,QSx)), Wx > , gconfig   
if (((idd1,use,idd2,pro) in Lx)  and (CollectFunctionsDiscon((idd1,use,idd2,pro),efes,Wx,QSx) =/= nil) ) .

crl [ExternalFunctionsForWait] :
< (Ix,Lx), wait(idd1,idbeh) . Rx,F(efls,efes), QRx, QSx, Wx > , gconfig    =>  
< (Ix,Lx), wait(idd1,idbeh) . Rx,F(efls,efes), QRx, append(QSx,CollectFunctionWait(idd1,idbeh,efes,Wx,QSx)), Wx > , gconfig   
if (CollectFunctionWait(idd1,idbeh,efes,Wx,QSx) =/= nil ) .

------------------------------------------------------- Instructions of program------------------------------------------------------------------------- 

crl [AddComponentInstance] :   < (Ix,Lx), add(id, ct) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>
 < (insert( < id, ct, nil, m(InitialPlace(ct) ,empty,empty)  > , Ix),Lx),  Rx,Fx, QRx, QSx, Wx > ,gconfig if not IsUsedIdentInstances(id,Ix)   .  


crl [DeleteComponentInstance] : < (< idd1,ct,qb,mrk > ,Ix,Lx), del(id) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>   
< (Ix,Lx), Rx,Fx, QRx, QSx, Wx > , gconfig  if (id == idd1 and (not InConnectionIdent(id,Lx)) ) . 

crl [ConnectPorts] : < (Ix,Lx), con(id,use,idd1,pro) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>   
< (Ix,(id,use,idd1,pro),Lx), Rx,Fx, QRx, QSx, Wx > , gconfig  
if (id =/= idd1 and ((InstanceIdent(Ix,id) in Ix) or (InstanceIdent(Ix,idd1) in Ix)) and (not InConnectionIdentUsePort(id,use,Lx)) ) . 


crl [DisconnectPorts] : < (Ix,Lx), dcon(id,use,idd1,pro) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>  
< (Ix,delete((id,use,idd1,pro),Lx)), Rx,Fx, QRx, QSx, Wx > , gconfig  
if
(  ((id,use,idd1,pro) in Lx)
  and
Eval(idDiscon(id,(id,use,idd1,pro)),Fx,Ix,Lx,dcon(id,use,idd1,pro) . Rx) == true
and
Eval(idDiscon(idd1,(id,use,idd1,pro)),Fx,Ix,Lx,dcon(id,use,idd1,pro) . Rx) == true
and
Eval(idAct(id,use),Fx,Ix,Lx,dcon(id,use,idd1,pro) . Rx) == false

) .


crl [PushingBehavior] : < (< idd1,ct,qb,mrk >,Ix,Lx), pushB(id, behx, idbeh) . Rx,Fx, QRx, QSx, Wx > , gconfig
=>   < (< idd1,ct,append(qb,(idbeh ; behx)),mrk >,Ix,Lx),  Rx,Fx, QRx, QSx, Wx > , gconfig 
if (id == idd1 and IsBehaviorOfComponent(behx,ct)) .
  

crl [Waiting] : < ( < idd1,ct,qb,mrk > ,Ix,Lx), wait(id,idbeh) . Rx,Fx, QRx, QSx, Wx > , gconfig
=>   < ( < idd1,ct,qb,mrk > ,Ix,Lx), Rx,Fx, QRx, QSx, Wx > , gconfig
if (Eval(idComp(id,idbeh),Fx,Ix,Lx, Rx) == true ) . 


endm

