

***(

    Ce fichier contient le programme Maude pour Concerto-D
    content: 
    several functional modules for defining data types and operations on these types 
    a system module to describe the writing rules corresponding to the concertoD operational semantics.

    afin d'utiliser la structure List et ensemble pour le type defini
    
   comme exemple: 
   
   si on veut construire un ensemble pour le sort place
   
   view Place from TRIV to DECLARATION-SORTS is
   sort Elt to Place .
   endv
    
   et par la suite :

   pr SET{Place} . 
   subsort Set{Place} <  Places  . 

The selected code is written in Maude, a high-performance reflective language and system supporting both equational and rewriting logic specification and programming for a wide range of applications. Maude has been used in many fields including specification and prototyping, theorem proving, program synthesis and verification, and complex adaptive systems.

This particular code snippet is defining a `view` in Maude. A `view` in Maude is a mapping between two modules. It is used to relate the sorts, subsorts, and operators of one module to those of another module. 

In this case, the view is named `Place` and it is mapping from the module `TRIV` to the module `DECLARATION-SORTS`. The `TRIV` module is a trivial module that is often used as a placeholder in Maude. The `DECLARATION-SORTS` module is likely a module defined elsewhere in the code that contains sorts, subsorts, and operators that are being used in the context of this view.

The line `sort Elt to Place .` within the view definition is specifying that the `Elt` sort in the `TRIV` module is being mapped to the `Place` sort in the `DECLARATION-SORTS` module. This means that wherever `Elt` is used in the context of the `TRIV` module, it can be thought of as `Place` in the context of the `DECLARATION-SORTS` module.

The `endv` at the end of the snippet is simply marking the end of the view definition.
)

*** 

----------views for defining parameterized sets and lists of sorts.
fmod DECLARATION-SORTS is 

sorts Place StationPlace Station IdentC ElementFunctionL ElementFunctionE send rec W Connection Instance LocalConfiguration .
sorts Transitionn TransitionnEnding Behavior BehaviorId GUse GPro .


endfm

--- Define a view named 'Place'
view Place from TRIV to DECLARATION-SORTS is
  --- Map the 'Elt' sort in the 'TRIV' module to the 'Place' sort in the 'DECLARATION-SORTS' module
  sort Elt to Place .
--- End of the view definition
endv

view StationPlace from TRIV to DECLARATION-SORTS is
  sort Elt to StationPlace .
endv

view Station from TRIV to DECLARATION-SORTS is
  sort Elt to Station .
endv

view IdentC from TRIV to DECLARATION-SORTS is
 sort Elt to IdentC .
endv

view ElementFunctionL from TRIV to DECLARATION-SORTS is
  sort Elt to ElementFunctionL .
endv

view ElementFunctionE from TRIV to DECLARATION-SORTS is
  sort Elt to ElementFunctionE .
endv

view send from TRIV to DECLARATION-SORTS is
  sort Elt to send .
endv

view rec from TRIV to DECLARATION-SORTS is
  sort Elt to rec .
endv

view W from TRIV to DECLARATION-SORTS is
  sort Elt to W .
endv


view Connection from TRIV to DECLARATION-SORTS is
 sort Elt to Connection .
endv
 
view Instance from TRIV to DECLARATION-SORTS is
  sort Elt to Instance .
endv

view LocalConfiguration from TRIV to DECLARATION-SORTS is
  sort Elt to LocalConfiguration .
endv


view Transitionn from TRIV to DECLARATION-SORTS is
  sort Elt to Transitionn .
endv


view TransitionnEnding from TRIV to DECLARATION-SORTS is
  sort Elt to TransitionnEnding .
endv

view Behavior from TRIV to DECLARATION-SORTS is
  sort Elt to Behavior .
endv

view BehaviorId from TRIV to DECLARATION-SORTS is
  sort Elt to BehaviorId .
endv

view GUse from TRIV to DECLARATION-SORTS is
sort Elt to GUse .
endv

view GPro from TRIV to DECLARATION-SORTS is
 sort Elt to GPro .
endv



fmod PLACE is
  inc DECLARATION-SORTS . ---to include the defined sort "Place"
  sorts InitPlace Places . --- definie two sorts
  subsort InitPlace < Place . --- InitPlace is a subsort of Place
  pr SET{Place} .  --- Import the parameterized module of SET of Place 
  subsort Set{Place} <  Places  .  --- declare the Place set as a sub-type of Places. 
  ----So, Places with s represents the sort for the set of Places 

---Places are defined here as operations without parameters
--- for each system to be analyzed, the corresponding operations must be generated for its Places
--- The same reasoning then applies to the stations, use ports and port ports of the system.
--- An alternative way to avoid modifying the code relating to Place operations for each system
--- is to declare places as strings:
--- pr STRING
---subsort String < Place . in this case, the following code will not be necessary
  op p1 : -> InitPlace .
  op q1 : -> InitPlace .
  ops p2 p3 p4 p5 p6 p7 p8 p9 p10 : -> Place .
  ops q2 q3 q4 q5 q6 q7 q8 q9 q10 : -> Place .

endfm

fmod STATION is
  inc DECLARATION-SORTS . ------to include the defined sort "Station"
  sort Stations .
  pr SET{Station} . 
  subsort Set{Station} <  Stations  . 

  ---Like Places, explicit stations of system
  ops s1 s2 s3 s4 s5 s6 s7 s8 s9 s10   : -> Station .
  ops r1 r2 r3 r4 r5 r6 r7 r8 r9 r10   : -> Station .
  

endfm

fmod STATION-PLACE is
  inc DECLARATION-SORTS . ---to include the defined sort "StationPlace"
  inc PLACE .
  inc STATION .

  sort StationPlaces .
  pr SET{StationPlace} . 
  subsort Set{StationPlace} <  StationPlaces . --- StationPlaces define a set of elements of sort StationPlace

  vars st1 st2 : Station .
  var S : Stations .
  var SPs : StationPlaces .
  var q : Place .
  var ps : Places .

  op(_;_) : Station Place -> StationPlace . --- an element StationPlace is a tuple (Station;Place)
  
  op Pi(_,_) : Station StationPlaces -> Place . --- gives the corresponding place for a station according to the "StationPlaces" set
 
  ceq Pi(st1, ((st2 ; q),SPs)) = q if (st1 == st2) .
  eq Pi(st1, ((st2 ; q),SPs)) = Pi(st1,SPs) [owise] .  ---otherwise

  op StationsGplaces(_,_) : Places StationPlaces -> Stations .  --- gives the stations associated to a Places group

  ceq StationsGplaces(ps,(st1 ; q),SPs) = st1, StationsGplaces(ps,SPs) if(q in ps) .
  ceq StationsGplaces(ps,(st1 ; q),SPs) =  StationsGplaces(ps,SPs) if(not(q in ps)) .
  eq StationsGplaces(ps,empty) = empty .


 
endfm

fmod IDENT-COMPENENT-BEHAVIOR is
  inc DECLARATION-SORTS . ---to include the defined sort "IdentC"
  
  sorts IdentCs IdentB  .  ---defines two sorts : a set of IdentCs for component IDs (IdentC) and a sort for behavior IDs (IdentB) 
  
  pr SET{IdentC} .
  subsort Set{IdentC} < IdentCs . 
  
  --- description of previously defined sorts IdentC and IdentB
  ops idc1 idc2 idc3 idc4 : -> IdentC .
  ops idb1 idb2 idb3 idb4 : -> IdentB .
  
endfm


fmod PORT is
  sort Port .

  sorts UsePort ProPort .
  subsorts UsePort ProPort < Port .

  ops us1 us2 us3 us4 : -> UsePort .
  ops pr1 pr2 pr3 pr4 : -> ProPort .

endfm

fmod BOOL-WITH-BOT is  --- a new sort to represent the 3 values : true, false and bot based on predefined sort bool
  pr BOOL . --- importation of sort BOOL
  
  sort Bot .
  sort BoolWithBot .
  subsorts Bool  Bot < BoolWithBot .

  op bot : -> Bot .
endfm

fmod CONNECTION is
  inc DECLARATION-SORTS . --- ---to include the defined sort "Connection"
  inc IDENT-COMPENENT-BEHAVIOR .
  inc PORT .
  
  sort  Connections . 
  
  pr SET{Connection} .  
  subsort Set{Connection} < Connections . 

  op (_,_,_,_) : IdentC UsePort IdentC ProPort -> Connection .  --- Define a new operator to create a Connection

  var  LL : Connections .  
  vars uus1 uus : UsePort .  
  var ppr2 : ProPort .  
  vars iid iid1 iid2 : IdentC .  
  
  --- 
  op InConnectionIdentUsePort(_,_,_) :  IdentC UsePort Connections -> Bool .  --- Define a new operator to check if a given IdentC and UsePort are in a Connections

  ceq InConnectionIdentUsePort(iid,uus,((iid1,uus1,iid2,ppr2),LL)) = true if (iid1 == iid and uus1 == uus) .  --- If the IdentC and UsePort match the first element of Connections, return true
  ceq InConnectionIdentUsePort(iid,uus,((iid1,uus1,iid2,ppr2),LL)) = InConnectionIdentUsePort(iid,uus,LL) if (iid1 =/= iid or uus1 =/= uus) .  --- If they don't match, check the rest of the Connections
  eq  InConnectionIdentUsePort(iid,uus,empty) = false .  --- If the Connections is empty, return false

  op InConnectionIdent(_,_) :  IdentC Connections -> Bool .  --- Define a new operator to check if a given IdentC is in a Connections

  ceq InConnectionIdent(iid,((iid1,uus1,iid2,ppr2),LL)) = true if (iid1 == iid or iid2 == iid) .  --- If the IdentC matches either of the IdentCs in the first element of Connections, return true
  ceq InConnectionIdent(iid,((iid1,uus1,iid2,ppr2),LL)) = InConnectionIdent(iid,LL) if (iid1 =/= iid and iid2 =/= iid) .  --- If it doesn't match, check the rest of the Connections
  eq  InConnectionIdent(iid,empty) = false .  --- If the Connections is empty, return false

  op ConnectionProIdent(_,_) : Connections IdentC -> Connections .  --- Define a new operator to get all Connections that have a given IdentC as the ProPort

  ceq ConnectionProIdent(((iid1,uus1,iid2,ppr2),LL),iid) = (iid1,uus1,iid2,ppr2), ConnectionProIdent(LL,iid) if(iid2 == iid) .  --- If the IdentC matches the ProPort of the first element of Connections, keep it and check the rest of the Connections
  ceq ConnectionProIdent(((iid1,uus1,iid2,ppr2),LL),iid) = ConnectionProIdent(LL,iid) if(iid2 =/= iid) .  --- If it doesn't match, discard it and check the rest of the Connections
  eq ConnectionProIdent(empty,iid) = empty .  --- If the Connections is empty, return empty
endfm

fmod ID-FUNCTIONS-COMMUNICATED is

  inc IDENT-COMPENENT-BEHAVIOR .
  inc PORT .
  inc CONNECTION .

  sort IdFunction .
  sorts IdFuncAct IdFunRef IdFunIscon IdFunDis IdFunComp .
  subsorts IdFuncAct IdFunRef IdFunIscon IdFunDis IdFunComp < IdFunction .

  op idAct(_,_) : IdentC Port -> IdFuncAct .
  op idRef(_,_) : IdentC Port -> IdFunRef .
  op idIsCon(_,_) : IdentC Connection -> IdFunIscon .
  op idDiscon(_,_) : IdentC Connection -> IdFunDis .
  op idComp(_,_) : IdentC IdentB -> IdFunComp .
  
endfm


fmod TRANSITION-TRANSITION-ENDING is
  inc PLACE .
  inc STATION .
  inc DECLARATION-SORTS . ---for sort Transitionn TransitionnEnding .
  sorts Transitionns TransitionnEndings .
   
  pr SET{Transitionn} .
  subsort Set{Transitionn} < Transitionns .
  
  pr SET{TransitionnEnding} .
  subsort Set{TransitionnEnding} < TransitionnEndings . 
 
  op t(_,_) : Place Stations -> Transitionn .
  op te(_,_) : Transitionn Station -> TransitionnEnding .


  var pla pla1 : Place .
  var pG : Places .
  vars S S1 : Stations .
  vars ss s : Station .
  var trans : Transitionns .
  var tes : TransitionnEndings .
  op PlacesTrans(_) : Transitionns -> Places .
  eq PlacesTrans(empty) = empty .
  eq PlacesTrans(t(pla,S),trans) = pla, PlacesTrans(trans) .

  op RemoveTransitionnEndingStation(_,_) : TransitionnEndings Station -> TransitionnEndings .
  ceq RemoveTransitionnEndingStation(te(t(pla,S),s),tes,ss) = te(t(pla,S),s),RemoveTransitionnEndingStation(tes,ss)
  if (s =/= ss) .
  ceq RemoveTransitionnEndingStation(te(t(pla,S),s),tes,ss) = RemoveTransitionnEndingStation(tes,ss)
  if (s == ss) .
  eq RemoveTransitionnEndingStation(empty,ss) = empty .


   --------used in entering place pour le choix d'une station
  op IsSatisfiedTransitionnEndingStation(_,_,_) : Station Transitionns TransitionnEndings -> Bool .

  ceq IsSatisfiedTransitionnEndingStation(s,t(pla,S),trans,tes) = false 
  if( (s in S) and (not(te(t(pla,S),s) in tes)) ) .
  ceq IsSatisfiedTransitionnEndingStation(s,t(pla,S),trans,tes) = IsSatisfiedTransitionnEndingStation(s,trans,tes) 
  if(not(s in S) or (te(t(pla,S),s) in tes) ) .
  eq IsSatisfiedTransitionnEndingStation(s,empty,tes) = true .

  op TranElt(_,_,_) : Places Transitionns Stations -> Transitionns .        
  op TranEndElts(_) : Transitionns -> TransitionnEndings .
  op TranEndElt(_,_) : Transitionn Stations -> TransitionnEndings .


  eq TranEndElt(t(pla,S), s,S1)= union(te(t(pla,S),s), TranEndElt(t(pla,S), S1) ) .
  eq TranEndElt(t(pla,S),empty) = empty .

  eq TranEndElts(t(pla,S),trans) = union(TranEndElt(t(pla,S),S), TranEndElts(trans) ) .
  eq TranEndElts(empty) = empty .
  ------------selection only station that end in the eleent of ExitGroupPlac

  ------------------------------------------------------------------
 
  ceq TranElt(pG,t(pla,S),trans,S1) = t(pla,S),TranElt(pG,trans,S1) if (pla in pG and (S subset S1)) .
  ceq TranElt(pG,t(pla,S),trans,S1) = TranElt(pG,trans,S1) if (not (pla in pG and (S subset S1))) .
  eq TranElt(pG,empty,S1) = empty .




  op RestrictTransToPlace(_,_) : Transitionns Place -> Transitionns .
  eq RestrictTransToPlace(empty,pla1) = empty .
  ceq RestrictTransToPlace((t(pla,S),trans),pla1) = RestrictTransToPlace(trans,pla1) if (pla =/= pla1) .
  ceq RestrictTransToPlace((t(pla,S),trans),pla1) = t(pla,S), RestrictTransToPlace(trans,pla1) if (pla == pla1) .

endfm 



fmod MARKING is
  inc TRANSITION-TRANSITION-ENDING .
  sort Marking .
  op m(_,_,_) : Places Transitionns TransitionnEndings -> Marking .
  op PlMar : Marking -> Places .
  op TrMar : Marking -> Transitionns .
  op TrEnMar : Marking -> TransitionnEndings .

  vars pls1 pls2 : Places .
  vars trans1 trans2 : Transitionns .
  vars tre1 tre2 : TransitionnEndings .

  eq PlMar(m(pls1,trans1,tre1)) = pls1 .
  eq TrMar(m(pls1,trans1,tre1)) = trans1 .
  eq TrEnMar(m(pls1,trans1,tre1)) = tre1 .

  op  IntersectionMarking(_,_) : Marking Marking -> Marking .
  eq  IntersectionMarking(m(pls1,trans1,tre1),m(pls2,trans2,tre2)) = 
  m(intersection(pls1,pls2),intersection(trans1,trans2),intersection(tre1,tre2)) .

  op NotEmptyMarking(_) : Marking -> Bool .
  eq NotEmptyMarking(m(pls1,trans1,tre1)) = (pls1 =/= empty or trans1 =/= empty or tre1 =/= empty ) .

endfm

fmod BEHAVIOR is
inc TRANSITION-TRANSITION-ENDING .
inc IDENT-COMPENENT-BEHAVIOR .

pr DECLARATION-SORTS . ---for sorts Behavior BehaviorId .
sorts Behaviors QBehavoirId .
 pr SET{Behavior} .
  subsort Set{Behavior} < Behaviors . 
  
  pr LIST{BehaviorId} .
  subsort List{BehaviorId} < QBehavoirId . 

op b(_) : Transitionns -> Behavior .
op (_;_) : IdentB Behavior -> BehaviorId .

vars idbehx idbehy : IdentB .

var behL : QBehavoirId .
var beh : Behavior .
op ExistIdentBehListBeh(_,_) : IdentB QBehavoirId -> Bool .

ceq ExistIdentBehListBeh(idbehx, (idbehy ; beh) behL) = true if (idbehx == idbehy) .
ceq ExistIdentBehListBeh(idbehx, (idbehy ; beh) behL) = ExistIdentBehListBeh(idbehx,behL) if (idbehx =/= idbehy) .
eq ExistIdentBehListBeh(idbehx, nil) = false .


endfm


fmod COMPENENT-TYPE is
  
  inc STATION-PLACE .
  inc TRANSITION-TRANSITION-ENDING .
  inc BEHAVIOR .
  inc PORT .
  inc DECLARATION-SORTS . ---for sorts  sorts GUse GPro ..
  inc MARKING . ---- pour la definitiion des eq element
  sort ComponentType .
  sorts GUses GPros .
  pr SET{GUse} .
  subsort Set{GUse} < GUses .
  pr SET{GPro} .
  subsort Set{GPro} < GPros .


  op (_!_) : UsePort Places -> GUse .
  op (_?_) : ProPort Places -> GPro .
  op < _,_,_,_,_,_,_ > : Places InitPlace StationPlaces Transitionns Behaviors GUses GPros -> ComponentType .

  op InitialPlace(_) : ComponentType -> Place .


  vars p pG : Places .
  var q : InitPlace .
  var st : StationPlaces .
  vars t t1  : Transitionns . 
  vars tes tes1 : TransitionnEndings .
  var b : Behaviors .
  var gu : GUses .
  var gp : GPros .

  eq InitialPlace (< p,q,st,t,b,gu,gp >) = q .

  op GetStationPlaces(_) : ComponentType -> StationPlaces .

  eq GetStationPlaces (< p,q,st,t,b,gu,gp >) = st .

  var por : Port . 
  vars poru up : UsePort .
  vars porp pp : ProPort .
  var use : UsePort .
  var pro : ProPort .



  op G(_,_) : Port ComponentType -> Places .
  op PlaceUse(_,_) : Port GUses -> Places .
  op PlacePro(_,_) : Port GPros -> Places .
  eq G(poru,< p,q,st,t,b,gu,gp > ) = PlaceUse(poru,gu)  .
  eq G(porp,< p,q,st,t,b,gu,gp > ) = PlacePro(porp,gp)  .

  ceq PlaceUse(poru,(up ! p),gu) = p if (poru == up) . 
  ceq PlaceUse(poru,(up ! p),gu) = PlaceUse(poru,gu) if (poru =/= up) . 
  eq PlaceUse(poru,empty) = empty . 

  ceq PlacePro(porp,(pp ? p),gp) = p if (porp == pp) . 
  ceq PlacePro(porp,(pp ? p),gp) = PlacePro(porp,gp) if (porp =/= pp) . 
  eq PlacePro(porp,empty) = empty . 

  op IsBehaviorOfComponent(_,_) : Behavior ComponentType -> Bool .
  vars beh beh1  : Behavior .

  eq IsBehaviorOfComponent(beh,< p,q,st,t,b,gu,gp >) = beh in b .
  
  op GetUsePort(_) : ComponentType -> GUses .
  eq GetUsePort (< p,q,st,t,b,gu,gp >) = gu .

----element---------------
  op elements(_,_) : Places ComponentType -> Marking .
  eq elements(pG,< p,q,st,t,b,gu,gp >) = m( pG, TranElt(pG,t,StationsGplaces(pG,st)), TranEndElts(TranElt(pG,t,StationsGplaces(pG,st))) ) .


---------------



endfm



fmod PROGRAM is
  sorts Program Instruction .
  inc COMPENENT-TYPE .
  inc IDENT-COMPENENT-BEHAVIOR .
  inc CONNECTION .

  op add(_,_) : IdentC ComponentType -> Instruction .
  op del(_) : IdentC -> Instruction .
  op pushB(_,_,_) : IdentC Behavior IdentB -> Instruction .
  op con(_) : Connection -> Instruction .
  op dcon(_) : Connection -> Instruction .
  op wait(_,_) : IdentC IdentB -> Instruction .
  op [] : -> Program [ctor] .
  op _._ : Instruction Program -> Program [ctor] . 


  op disconnect(_,_) : Connection Program -> Bool .
  op NotDcon(_,_) :  Connection Program -> Bool .
  vars Prog1 Prog2 : Program .
  var l : Connection .
  var inst : Instruction .
  var idcx : IdentC .
  var idbehx : IdentB .
  var beh : Behavior .
  eq disconnect(l,[]) = true .
  eq disconnect(l,inst . Prog1) = NotDcon(l,Prog1) .
  eq NotDcon(l,[]) = true .
  eq NotDcon(l,inst . Prog1) = (inst =/= dcon(l) and NotDcon(l,Prog1)) .

  op NotPushBProg(_,_,_) : IdentC IdentB Program -> Bool .
  op InstructionIspushB(_,_,_) : Instruction IdentC IdentB -> Bool .

  eq InstructionIspushB(pushB(idcx,beh,idbehx), idcx,idbehx ) = true .
  eq InstructionIspushB(inst, idcx,idbehx ) = false [owise] .

  ceq NotPushBProg(idcx,idbehx,inst . Prog1) = NotPushBProg(idcx,idbehx,Prog1) if (not InstructionIspushB(inst,idcx,idbehx)) .
  ceq NotPushBProg(idcx,idbehx,inst . Prog1) = false if (InstructionIspushB(inst,idcx,idbehx)) .
  eq NotPushBProg(idcx,idbehx, []) = true .


endfm


fmod INSTANCE is
  
  inc COMPENENT-TYPE .
  inc BEHAVIOR .
  inc IDENT-COMPENENT-BEHAVIOR .
  inc MARKING . 
  inc DECLARATION-SORTS . ---for sort instance
  sort Instances .
  pr SET{Instance} .
  subsort Set{Instance} < Instances . 

  op <_,_,_,_> : IdentC ComponentType QBehavoirId Marking -> Instance .

  vars identI identII : IdentC .
  var c : ComponentType .
  var bl : QBehavoirId .
  var mark : Marking .

  var S S1 : Stations .
  var s : Station .
  var Pla : Place .
  vars pG ps : Places .
  vars q p : Place .
 var pla : Place .
  var idbeh : IdentB .
  var t1 : Transitionns .


    var gu : GUses .
  var gp : GPros .

  var por : Port . 
  vars poru up : UsePort .
  vars porp pp : ProPort .
  var use : UsePort .
  var pro : ProPort .

  op IdentInstance(_) : Instance -> IdentC .
  eq IdentInstance(< identI,c,bl,mark > ) = identI .

  var Is : Instances .
  op IsUsedIdentInstances(_,_) : IdentC Instances -> Bool .
  ceq IsUsedIdentInstances(identII, < identI,c,bl,mark >, Is) = true if (identII == identI) .
  ceq IsUsedIdentInstances(identII, < identI,c,bl,mark >, Is) = IsUsedIdentInstances(identII, Is) if (identII =/= identI) .
  eq IsUsedIdentInstances(identII, empty) = false .

  op InstanceIdent(_,_) : Instances IdentC -> Instance . ---applied only if we are sure of exist
  ceq  InstanceIdent((< identI,c,bl,mark > ,Is) , identII ) = < identI,c,bl,mark > if (identI == identII) .
  eq  InstanceIdent((< identI,c,bl,mark >,Is) , identII ) =  InstanceIdent(Is,identII) [owise] .

 ----------redondant supprimer un et changer dans le code
  op ExistIdentInstances(_,_) : IdentC Instances -> Bool .
  eq ExistIdentInstances(identII,empty) = false .
  eq ExistIdentInstances(identII, < identI,c,bl,mark >, Is) = true  .
  ceq ExistIdentInstances(identII, < identI,c,bl,mark >, Is) = ExistIdentInstances(identI,Is) if (identI =/= identII) .

-----------------a voir si on modifier l'endroit
----------modifier par exemple Q behaviorID par trenasitionns


op AllExitGroup(_,_,_) : Places QBehavoirId Stations -> Bool .
op ExitGroupPlace(_,_,_) : Place QBehavoirId Stations -> Bool .
op ExistSourceTranPlace(_,_) : Place Transitionns -> Bool .
op AllTranQuitGroupPlace(_,_,_) : Place Transitionns Stations -> Bool .



eq AllExitGroup((q,pG),bl,S)  = ExitGroupPlace(q,bl,S) and AllExitGroup(pG,bl,S) .
eq AllExitGroup(empty,bl,S) = true .

eq ExitGroupPlace(q,nil,S) = false . 
eq ExitGroupPlace(q,(idbeh ; b(t1)) bl,S) = ExistSourceTranPlace(q,t1) and AllTranQuitGroupPlace(q,t1,S) . 

ceq  ExistSourceTranPlace(q,t(p,S),t1) = true if (p == q ) .
ceq  ExistSourceTranPlace(q,t(p,S),t1) = ExistSourceTranPlace(q,t1) if (p =/= q ) .
eq   ExistSourceTranPlace(q,empty) = false .

ceq AllTranQuitGroupPlace(q,t(p,S1),t1,S) = AllTranQuitGroupPlace(q,t1,S) if ((p =/= q)  or   intersection(S1,S) == empty ) .  
eq  AllTranQuitGroupPlace(q,empty,S) = true .
eq  AllTranQuitGroupPlace(q,t(p,S),t1,S) = false [owise] .


----------end endroid


---------------active et refusing

op active(_,_) : Instance Port -> Bool . 
op activeMarking(_,_,_) : Instance Port Marking -> Bool . 


---var bl : QBehavoirId .
var mm : Marking .
---var idbeh : IdentB .
var st : StationPlaces .
var b : Behaviors .
var pls : Places .
vars trans t : Transitionns .
var tre : TransitionnEndings .
var ct : ComponentType .
----------pouquoi en detail CT a voir
eq active(< identI, < ps,q,st,t,b,gu,gp > ,bl,m(pls,trans,tre) >,por) = NotEmptyMarking(IntersectionMarking(elements(G(por, < ps,q,st,t,b,gu,gp >),< ps,q,st,t,b,gu,gp >),m(pls,trans,tre))) .
eq activeMarking(< identI, < ps,q,st,t,b,gu,gp > ,bl,m(pls,trans,tre) >,por,mm) = NotEmptyMarking(IntersectionMarking(elements(G(por, < ps,q,st,t,b,gu,gp >),< ps,q,st,t,b,gu,gp >),mm)) .
------------- fonctions pour refusing




op refusing(_,_) : Instance Port -> Bool .

ceq refusing(< identI, < ps,q,st,t,b,gu,gp > , bl,m(pls,trans,tre) >,por) = true if  --- a changer aussi dans la version centralise la correction (idbeh ; b(t1)) par bl et dans toutes les fonctions liées
(
TrMar(IntersectionMarking(elements(G(por, < ps,q,st,t,b,gu,gp >),< ps,q,st,t,b,gu,gp >),m(pls,trans,tre))) == empty and 
TrEnMar(IntersectionMarking(elements(G(por, < ps,q,st,t,b,gu,gp >),< ps,q,st,t,b,gu,gp >),m(pls,trans,tre))) == empty and 
AllExitGroup(PlMar(IntersectionMarking(elements(G(por, < ps,q,st,t,b,gu,gp >),< ps,q,st,t,b,gu,gp >),m(pls,trans,tre))),bl,StationsGplaces(G(por,< ps,q,st,t,b,gu,gp >),st))

)  .

eq refusing(< identI, < ps,q,st,t,b,gu,gp > , bl,m(pls,trans,tre) >,por) = false [owise] .

----------------------------------


endfm

fmod CONCERTO-D-CONFIGURATION is 

inc ID-FUNCTIONS-COMMUNICATED .
inc INSTANCE .
inc PROGRAM .
inc CONNECTION .
inc BOOL-WITH-BOT .
inc DECLARATION-SORTS . ---for sorts  LocalConfiguration ElementFunctionL ElementFunctionE send rec W

sorts  LocalConfigurations  ElementFunctionLs ElementFunctionEs .
sorts  F  Qsend Qrec Ws .

subsort IdFunction  < W . --- Idfunction is also an element of W 
subsort IdFunction  < send . ---- Idfunction is also an element of the send 

pr SET{ElementFunctionL} .
  subsort Set{ElementFunctionL} < ElementFunctionLs . 

pr SET{ElementFunctionE} .
  subsort Set{ElementFunctionE} < ElementFunctionEs . 

pr LIST{send} .
  subsort List{send} < Qsend . 

pr LIST{rec} .
  subsort List{rec} < Qrec . 

pr SET{W} .
  subsort Set{W} < Ws . 

pr SET{LocalConfiguration} .
  subsort Set{LocalConfiguration} < LocalConfigurations . 

op el(_) : IdFunction  ->   ElementFunctionL .
op ee(_;_) : IdFunction BoolWithBot ->   ElementFunctionE .
op F(_,_) :  ElementFunctionLs ElementFunctionEs -> F .
op (_;_) :  IdFunction BoolWithBot  -> rec .
op < (_,_),_,_,_,_,_ > : Instances Connections Program F Qrec Qsend  Ws -> LocalConfiguration .

op LocalFun(_,_) : IdFunction F -> Bool .
op ExternFun(_,_) : IdFunction F -> Bool .

vars idf lf ef idf1 idf2 : IdFunction .
---var Fx : F .
var lfs : ElementFunctionLs .
var efs : ElementFunctionEs .
var bwb : BoolWithBot .

ceq LocalFun(idf, F((el(lf),lfs),efs )) = true if (idf == lf) .
ceq LocalFun(idf, F((el(lf),lfs),efs )) = LocalFun(idf, F(lfs,efs )) if (idf =/= lf) .
eq LocalFun(idf, F(empty,efs )) = false .

ceq ExternFun(idf, F(lfs,ee(ef ; bwb),efs )) = true if (idf == ef) .
ceq ExternFun(idf, F(lfs,ee(ef ; bwb),efs)) = ExternFun(idf, F(lfs,efs)) if (idf =/= ef) .
eq ExternFun(idf, F(empty,efs )) = false .


op ExternEval(_,_) : IdFunction ElementFunctionEs -> BoolWithBot .
ceq ExternEval(idf1, ee(idf2 ; bwb), efs ) = bwb if (idf1 == idf2) .
ceq ExternEval(idf1, ee(idf2 ; bwb), efs ) = ExternEval(idf1, efs ) if (idf1 =/= idf2) .



op SubValExtern(_,_,_) : ElementFunctionEs IdFunction BoolWithBot -> ElementFunctionEs .
var efes : ElementFunctionEs .
var efe :  ElementFunctionE .
vars valfNew valfOld : BoolWithBot .
var Isx : Instances .
var idcx : IdentC .
--------------
var idbehx : IdentB .
var idbehy : IdentB .
var ctx : ComponentType .
---var behlx : BehaviorLs .
var Mx : Marking .
var porx : Port .

var Ls : Connections .
var pg : Program .

var l : Connection .

var behL : QBehavoirId .

var mark : Marking .
---------------
ceq SubValExtern((ee(idf1 ; valfOld),efes),idf2,valfNew) = ee(idf1 ; valfNew),efes if(idf1 == idf2) .
ceq SubValExtern((ee(idf1 ; valfOld),efes),idf2,valfNew) = ee(idf1 ; valfOld),SubValExtern(efes,idf2,valfNew) if(idf1 =/= idf2) .
eq SubValExtern(empty,idf2,valfNew) = empty . 

op Eval(_,_,_,_,_) : IdFunction F Instances Connections Program -> BoolWithBot .
var ff : F .
ceq Eval(idf1,ff, Isx,Ls,pg ) = LocalEval(idf1,Isx,Ls,pg) if (LocalFun(idf1,ff)) .
ceq Eval(idf1,F(lfs,efs), Isx,Ls,pg ) = ExternEval(idf1,efs) if (ExternFun(idf1,F(lfs,efs))) .
eq Eval(idf1,ff, Isx,Ls,pg ) = bot [owise] .   -----------------------------------cas normaelement ne se produit jamais



op LocalEval(_,_,_,_) : IdFunction Instances Connections Program -> BoolWithBot .

ceq LocalEval (idAct(idcx,porx), Isx,Ls,pg) = false if (not ExistIdentInstances(idcx,Isx)) .   ---if the instance does not exist, then the active function = false
ceq LocalEval (idAct(idcx,porx), Isx,Ls,pg) = active(InstanceIdent(Isx,idcx),porx) if (ExistIdentInstances(idcx,Isx)) . 

ceq LocalEval (idRef(idcx,porx), Isx,Ls,pg) = true if (not ExistIdentInstances(idcx,Isx)) . ---if the instance does not exist, then the refusing function = true 
ceq LocalEval (idRef(idcx,porx), Isx,Ls,pg) = refusing(InstanceIdent(Isx,idcx),porx) if (ExistIdentInstances(idcx,Isx)) . 

eq LocalEval (idIsCon(idcx,l), Isx,Ls,pg) = l in Ls . 

eq LocalEval (idDiscon(idcx,l), Isx,Ls,pg) = disconnect(l,pg) . 

eq LocalEval (idComp(idcx,idbehx), < idcx,ctx,behL,mark >,Isx,Ls,pg) =  (not ExistIdentBehListBeh(idbehx,behL) ) and NotPushBProg(idcx,idbehx,pg) .
ceq LocalEval (idComp(idcx,idbehx), Isx,Ls,pg) = true if ((not ExistIdentInstances(idcx,Isx) ) and NotPushBProg(idcx,idbehx,pg)) .
eq LocalEval (idComp(idcx,idbehx), Isx,Ls,pg) = false [owise] .


endfm









----------------Fonctions utilisee dans les regles operationnelle

fmod CONSISTENCY-PORTS-FIRING-TRANSITION is


***(
  fonction ConsistencyPort utilise pour la consistence lors de tire de transition
  elle prend comme parametre le nouveau marquage apres le tir les instances de la configuration concerne
  son evaluation F des fonction et un sous ensemnle des ses Connection où le compsant  concerne par le tir est un provide
  en chercehe a verifier l'implication pour garder la consitence pour chque sous ensemble de Connection concerne

)



  inc CONCERTO-D-CONFIGURATION .

---NotActiveUseLeavingProvid modifier la fonction suivante

  op ConsistencyPort(_,_,_,_) : Marking Instances F Connections ->  Bool .

  var newMark : Marking .
  var I : Instances .
  vars id1 id2 : IdentC .
  var use : UsePort .
  var pro : ProPort .
  var L : Connections .
  var ff : F .
  eq ConsistencyPort(newMark,I,ff,(id1,use,id2,pro),L) = ConsistencyPort(newMark,I,ff,L) and 
  (
    ( (Eval(idAct(id2,pro),ff, I,empty,[] ) == true) and 
    (activeMarking(InstanceIdent(I,id2),pro,newMark) == false )) 
    implies  (Eval(idAct(id1,use),ff, I,empty,[] ) == false) 
  ) .

  eq ConsistencyPort(newMark,I,ff,empty) = true .


endfm


fmod CONSISTENCY-PORTS-ENTERING-PLACE is

***(

en plus de la condition IsSatisfiedTransitionnEndingStation definie dans 
on a besoin d'aasurer ConnectedProvidedAllowed
les parametre sont 
place pour cocerne par la transition 
les useport du composant de l'instance
l'instance avant le tire
l'instance apres le tir
les autres instances 
F 

)

inc CONCERTO-D-CONFIGURATION .







  var p : Place .
var ps : Places .
var gu :  GUses .
vars i i' : Instance .
var Is : Instances .
var L : Connections .
var f : F .
vars poru up : UsePort .
var pp : ProPort .
vars IdentIns id1 id2 : IdentC .
op ConnectedProvidedAllowed(_,_,_,_,_,_,_) : Place GUses Instance Instance Instances Connections F -> Bool . 

 
eq ConnectedProvidedAllowed(p,empty,i,i',Is,L,f) = true .

ceq ConnectedProvidedAllowed(p,(up ! ps),gu,i,i',Is,L,f) = 
Connected(up,IdentInstance(i),L,f)
and 
Provided(up,IdentInstance(i),i,Is,L,f) 
and 
Allowed(up,IdentInstance(i),i,Is,L,f) 
and ConnectedProvidedAllowed(p,gu,i,i',Is,L,f) 
if  ((p in ps) and active(i,up) == false and active(i',up) == true  ).     ----------active puisque c local traitement directe

eq ConnectedProvidedAllowed(p,(up ! ps),gu,i,i',Is,L,f) = ConnectedProvidedAllowed(p,gu,i,i',Is,L,f) [owise] .

op Connected(_,_,_,_) : UsePort IdentC Connections F -> Bool . 
op Provided(_,_,_,_,_) : UsePort IdentC  Instances Connections F -> Bool . 
op Allowed(_,_,_,_,_) : UsePort  IdentC Instances Connections F -> Bool . 


eq Connected(poru,IdentIns,empty,f) = false .
ceq Connected(poru,IdentIns,(id1,up,id2,pp),L,f) = true 
if(poru == up and id1 == IdentIns and Eval(idIsCon(id2,(id1,up,id2,pp)),f,empty,(id1,up,id2,pp),L,[] )   == true ) .
eq Connected(poru,IdentIns,(id1,up,id2,pp),L,f) = Connected(poru,IdentIns,L,f) [owise] .




eq Provided(poru,IdentIns,Is,empty,f) = false .
ceq Provided(poru,IdentIns,Is,(id1,up,id2,pp),L,f) = (Eval(idAct(id2,pp),f,Is,(id1,up,id2,pp),L,[] ) == true) 
if (poru == up and id1 == IdentIns) .

eq Provided(poru,IdentIns,Is,(id1,up,id2,pp),L,f) = Provided(poru,IdentIns,Is,L,f) [owise] .


eq Allowed(poru,IdentIns,Is,empty,f) = false .
ceq Allowed(poru,IdentIns,Is,(id1,up,id2,pp),L,f) = (Eval(idRef(id2,pp),f,Is,(id1,up,id2,pp),L,[] ) == false) 
if (poru == up and id1 == IdentIns) .
eq Allowed(poru,IdentIns,Is,(id1,up,id2,pp),L,f) = Allowed(poru,IdentIns,Is,L,f) [owise] .


endfm



fmod COLLECT-EXTERNAL-FUNCTIONS-FIRING is

inc CONCERTO-D-CONFIGURATION .

var Is : Instances .
var L : Connections .
var bwb : BoolWithBot .
var up : UsePort .
var pp : ProPort .
vars  id1 id2 : IdentC .
var newMark : Marking .
var efs : ElementFunctionEs .
var ws : Ws .
var qsend : Qsend .

op CollectFunctionFiring(_,_,_,_,_,_) : Marking Instances Connections ElementFunctionEs Ws Qsend -> Qsend .

eq CollectFunctionFiring(newMark,Is,empty,efs,ws,qsend) = nil .
ceq CollectFunctionFiring(newMark,Is,(id1,up,id2,pp),L,ee(idAct(id1,up) ; bwb),efs,ws,qsend) = append(idAct(id1,up),CollectFunctionFiring(newMark,Is,L,efs,ws,qsend))
if
(
 (not (idAct(id1,up) in ws)) and 
 (not (occurs(idAct(id1,up),qsend))) and
 (bwb == true or bwb == bot) and
 ( (LocalEval(idAct(id2,pp),Is,empty,[] ) == true) and (activeMarking(InstanceIdent(Is,id2),pp,newMark) == false ))  
) .

eq CollectFunctionFiring(newMark,Is,(id1,up,id2,pp),L,efs,ws,qsend) = CollectFunctionFiring(newMark,Is,L,efs,ws,qsend) [owise] .


endfm






fmod COLLECT-EXTERNAL-FUNCTIONS-WAIT is

inc CONCERTO-D-CONFIGURATION .


var bwb : BoolWithBot .

var  id1 : IdentC .
var idbeh : IdentB .
var efs : ElementFunctionEs .
var ws : Ws .
var qsend : Qsend .
var idf1 : IdFunction .


op CollectFunctionWait(_,_,_,_,_) : IdentC IdentB ElementFunctionEs Ws Qsend -> Qsend .

eq CollectFunctionWait(id1,idbeh,empty,ws,qsend) = nil .
ceq CollectFunctionWait(id1,idbeh,ee(idf1 ; bwb),efs,ws,qsend) = idf1 
if 
(
  (not (idf1 in ws)) and 
 (not (occurs(idf1,qsend))) 
 and
  (idf1 == idComp(id1,idbeh)   and (bwb == false or bwb == bot))
) .
eq CollectFunctionWait(id1,idbeh,ee(idf1 ; bwb),efs,ws,qsend) = CollectFunctionWait(id1,idbeh,efs,ws,qsend) [owise] . 

endfm

fmod COLLECT-EXTERNAL-FUNCTIONS-DISCONNECT is

inc CONCERTO-D-CONFIGURATION .


op CollectFunctionsDiscon(_,_,_,_) : Connection ElementFunctionEs Ws Qsend -> Qsend .

var bwb : BoolWithBot .

var up : UsePort .
var pp : ProPort .
vars  id1 id2 : IdentC .
var efs : ElementFunctionEs .
var ws : Ws .
var qsend : Qsend .
var idf1 : IdFunction .



eq CollectFunctionsDiscon((id1,up,id2,pp),empty,ws,qsend) = nil .

ceq CollectFunctionsDiscon((id1,up,id2,pp),ee(idf1 ; bwb),efs,ws,qsend) = append(idf1,CollectFunctionsDiscon((id1,up,id2,pp),efs,ws,qsend)) 
if
( 
 (not (idf1 in ws)) and 
 (not (occurs(idf1,qsend))) 
 and 
 ( 
     ( idf1 == idAct(id1,up)   and (bwb == true or bwb == bot)  ) 
   or
    ( (idf1 == idDiscon(id1,(id1,up,id2,pp)) or idf1 ==  idDiscon(id2,(id1,up,id2,pp)) ) and (bwb == false or bwb == bot) )
 ) 
) .
eq CollectFunctionsDiscon((id1,up,id2,pp),ee(idf1 ; bwb),efs,ws,qsend) = CollectFunctionsDiscon((id1,up,id2,pp),efs,ws,qsend) [owise] . 


endfm





fmod COLLECT-EXTERNAL-FUNCTIONS-ENTERING-PLACE is

inc CONCERTO-D-CONFIGURATION .


var p : Place .
var ps : Places .
var gu :  GUses .
vars i i' : Instance .
var Is : Instances .
var L : Connections .
var f : F .
vars poru up : UsePort .
var pp : ProPort .
vars IdentIns id1 id2 : IdentC .
var ws : Ws .
var qsend : Qsend .
var idf1 : IdFunction .




op CollectFunctionsEnteringPlace(_,_,_,_,_,_,_,_,_) : Place GUses Instance Instance Instances Connections F Ws Qsend -> Qsend .

eq CollectFunctionsEnteringPlace(p,empty,i,i',Is,L,f,ws,qsend) = nil .
ceq CollectFunctionsEnteringPlace(p,(up ! ps),gu,i,i',Is,L,f,ws,qsend) = 
append(CollectConnected(up,IdentInstance(i),L,f,ws,qsend),append(CollectProvided(up,IdentInstance(i),i,Is,L,f,ws,qsend), 
append(CollectAllowed(up,IdentInstance(i),i,Is,L,f,ws,qsend), CollectFunctionsEnteringPlace(p,gu,i,i',Is,L,f,ws,qsend)))) 
if  ((p in ps) and active(i,up) == false and active(i',up) == true  ).   
eq CollectFunctionsEnteringPlace(p,(up ! ps),gu,i,i',Is,L,f,ws,qsend) = CollectFunctionsEnteringPlace(p,gu,i,i',Is,L,f,ws,qsend) [owise] .


op CollectConnected(_,_,_,_,_,_) : UsePort IdentC Connections F Ws Qsend -> Qsend . 
op CollectProvided(_,_,_,_,_,_,_) : UsePort IdentC  Instances Connections F Ws Qsend -> Qsend . 
op CollectAllowed(_,_,_,_,_,_,_) : UsePort  IdentC Instances Connections F Ws Qsend -> Qsend . 


eq CollectConnected(poru,IdentIns,empty,f,ws,qsend) = nil .
ceq CollectConnected(poru,IdentIns,(id1,up,id2,pp),L,f,ws,qsend) = idIsCon(id2,(id1,up,id2,pp))
if(
  (not (idIsCon(id2,(id1,up,id2,pp)) in ws)) and 
 (not (occurs(idIsCon(id2,(id1,up,id2,pp)),qsend)))  and
  ExternFun(idIsCon(id2,(id1,up,id2,pp)),f) and
(poru == up and id1 == IdentIns) and 
( Eval(idIsCon(id2,(id1,up,id2,pp)),f,empty,empty,[] )   == false  or Eval(idIsCon(id2,(id1,up,id2,pp)),f,empty,empty,[] )   == bot )
  
 ) .
eq CollectConnected(poru,IdentIns,(id1,up,id2,pp),L,f,ws,qsend) = CollectConnected(poru,IdentIns,L,f,ws,qsend) [owise] .


eq CollectProvided(poru,IdentIns,Is,empty,f,ws,qsend) = nil .
ceq CollectProvided(poru,IdentIns,Is,(id1,up,id2,pp),L,f,ws,qsend) = idAct(id2,pp)
if (
    (not idAct(id2,pp) in ws) and 
 (not (occurs(idAct(id2,pp),qsend)))  and
  ExternFun(idAct(id2,pp),f) and
(poru == up and id1 == IdentIns) and 
( Eval(idAct(id2,pp),f,empty,empty,[] )   == false  or Eval(idAct(id2,pp),f,empty,empty,[] )   == bot )   
   ) .
eq CollectProvided(poru,IdentIns,Is,(id1,up,id2,pp),L,f,ws,qsend) = CollectProvided(poru,IdentIns,Is,L,f,ws,qsend) [owise] .

eq CollectAllowed(poru,IdentIns,Is,empty,f,ws,qsend) = nil .
ceq CollectAllowed(poru,IdentIns,Is,(id1,up,id2,pp),L,f,ws,qsend) = idRef(id2,pp)
if (
    (not idRef(id2,pp) in ws) and 
 (not (occurs(idRef(id2,pp),qsend)))  and
  ExternFun(idRef(id2,pp),f) and
(poru == up and id1 == IdentIns) and 
( Eval(idRef(id2,pp),f,empty,empty,[] )   == true  or Eval(idRef(id2,pp),f,empty,empty,[])   == bot )   
   ) .

eq CollectAllowed(poru,IdentIns,Is,(id1,up,id2,pp),L,f,ws,qsend) = CollectAllowed(poru,IdentIns,Is,L,f,ws,qsend) [owise] .





endfm





fmod COMMUNICATION-FUNCTIONS is

inc CONCERTO-D-CONFIGURATION .


var idents : IdentCs . 
var efs : ElementFunctionEs .
var bwb : BoolWithBot .
var L : Connections .
var up : UsePort .
var pp : ProPort .
var idf1 : IdFunction .
vars id1 id2 : IdentC .

op UpDateExternalFunctionsSend(_,_) : ElementFunctionEs IdentCs -> ElementFunctionEs .  -----------IdentCs contain one or 0 element
eq  UpDateExternalFunctionsSend(efs,empty) = efs .
eq  UpDateExternalFunctionsSend(empty,idents) = empty .
ceq UpDateExternalFunctionsSend(ee(idRef(id1,pp) ; bwb),efs,idents) = ee(idRef(id1,pp) ; bot), efs if (id1 in idents ) .
eq  UpDateExternalFunctionsSend(ee(idf1 ; bwb),efs,idents) = ee(idf1 ; bwb), UpDateExternalFunctionsSend(efs,idents) [owise] .


op IdentConnectionWithActive(_,_,_) : Connections IdFunction BoolWithBot -> IdentCs .
eq IdentConnectionWithActive((id1,up,id2,pp),L,idAct(id1,up),false) = id2 . 
eq IdentConnectionWithActive(empty,idf1,bwb) = empty . 
eq IdentConnectionWithActive((id1,up,id2,pp),L,idf1,bwb) = IdentConnectionWithActive(L,idf1,bwb) [owise] . 

endfm


mod OPERATIONAL-SEMANTICS is

inc CONCERTO-D-CONFIGURATION .

inc CONSISTENCY-PORTS-FIRING-TRANSITION .
inc CONSISTENCY-PORTS-ENTERING-PLACE .
inc COLLECT-EXTERNAL-FUNCTIONS-FIRING .
inc COLLECT-EXTERNAL-FUNCTIONS-WAIT .
inc COLLECT-EXTERNAL-FUNCTIONS-DISCONNECT .
inc COLLECT-EXTERNAL-FUNCTIONS-ENTERING-PLACE .
inc COMMUNICATION-FUNCTIONS .

var lcx lcy : LocalConfiguration .
var gconfig : LocalConfigurations .

vars Rx Ry : Program .
vars Ix Iy : Instances . 
vars Lx Ly : Connections .
vars Fx Fy : F .
vars QSx QSy : Qsend .
vars QRx QRy : Qrec .
vars Wx Wy : Ws .
var  idf : IdFunction .
var valf : BoolWithBot .

vars ct ctt : ComponentType .
var inst : Instance .
var use : UsePort .
var pro : ProPort .

var efls : ElementFunctionLs .
var efes : ElementFunctionEs .


ops i ii : -> Instance .
op ccc : -> ComponentType .

vars id idd1 idd2 : IdentC .
vars qb : QBehavoirId .
var behx : Behavior .
var mrk : Marking .
var  idbeh : IdentB .
var b : Transitionns .

vars p q : Place .
var ps : Places .
var ts : Transitionns .
var tr : Transitionn .
vars tes tes1 : TransitionnEndings .
var S : Stations .
var s : Station .

-------------------------------------------------------------------------------------------------fonctions utilise dans les regles


--------------------------------------------Rules for communication----------------------------------------------------------------------

--------------a supprimer gconfig

crl [SendRequest] : 
< (Ix,Lx),Rx,Fx, QRx, idf QSx, Wx > , < (Iy,Ly),Ry,Fy,QRy,QSy,Wy >, gconfig  =>
< (Ix,Lx),Rx,Fx,QRx,QSx, (Wx, idf) > , < (Iy,Ly),Ry,Fy,append(QRy, (idf ; bot) ),QSy,Wy >, gconfig 
if ( ExternFun(idf,Fx) and LocalFun(idf,Fy) ) .


crl [SendEvalFun] : 
< (Ix,Lx),Rx,F(efls,efes), QRx, idf QSx, Wx > , < (Iy,Ly),Ry,Fy,QRy,QSy,Wy >, gconfig  =>
< (Ix,Lx),Rx,F(efls,UpDateExternalFunctionsSend(efes,IdentConnectionWithActive(Lx,idf,LocalEval(idf,Ix,Lx,Rx)))),QRx,QSx, Wx > , < (Iy,Ly),Ry,Fy,append(QRy, (idf ; LocalEval(idf,Ix,Lx,Rx)) ),QSy,Wy >, gconfig 
if ( LocalFun(idf,F(efls,efes)) and (idf in Wy) ) .

crl [ReceivesRequest] : 
< (Ix,Lx),Rx,Fx, (idf ; valf ) QRx,  QSx, Wx >, gconfig   =>
< (Ix,Lx),Rx,Fx,QRx,append(QSx, idf  ), Wx > , gconfig
if ( LocalFun(idf,Fx) ) .

crl [ReceivesEvalFun] : 
< (Ix,Lx),Rx,F(efls,efes), (idf ; valf ) QRx,  QSx, Wx >,  gconfig  =>
< (Ix,Lx),Rx,F(efls,SubValExtern(efes,idf,valf)),QRx,QSx, delete(idf,Wx) >,  gconfig 
if ( ExternFun(idf,F(efls,efes)) ) .  


--------------------------------------------end of communication rules---------------------------------------------RestrictTransToPlace
-------------------------------------------------Rules of evolution components

crl [FiringTransitionns] :  < (< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,Lx),Rx,Fx, QRx,  QSx, Wx > , gconfig  =>
< (  < idd1,ct,(idbeh ; b(b)) qb,m(ps,union(ts, RestrictTransToPlace(b,p) ),tes) >, Ix , Lx),Rx,Fx, QRx, QSx, Wx > , gconfig 
if (RestrictTransToPlace(b,p) =/= empty and 
ConsistencyPort(m(ps,union(ts, RestrictTransToPlace(b,p) ),tes) ,< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > ,Ix,Fx,ConnectionProIdent(Lx, idd1 ))) .  

rl [EndingTransitionn] : < (< idd1,ct, qb,m(ps, t(q,s,S), ts,tes) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig =>
< (< idd1,ct, qb,m(ps, ts, te(t(q,s,S),s), tes  ) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig .



crl [EnteringPlace] : < (< idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig  =>
 < (< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) > , Ix,Lx),Rx,Fx, QRx,  QSx, Wx > , gconfig  

if 
(IsSatisfiedTransitionnEndingStation(s,b,te(t(q,s,S),s), tes) 
and 

ConnectedProvidedAllowed (Pi(s,GetStationPlaces(ct)), GetUsePort(ct), < idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >,
< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) >,Ix, Lx,Fx)) 
.  

crl [FinishingBehavior] : < (< idd1,ct,(idbeh ; b(b)) qb,m(ps,empty,empty) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig  =>
< (< idd1,ct, qb,m(ps,empty,empty) > , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig if (intersection(ps,PlacesTrans(b)) == empty) .



---red ConnectedProvidedAllowed (p2,us1 ! p2, < idc1,< p1, p2,p1,s1 ; p1, s2 ; p2,t(p1,s2),b(t(p1,s2)),us1 ! p2,empty >,idb1 ; b(t(p1,s2)),m(empty,empty,te(t(p1,s2),s2)) >,< idc1,< p1, p2,p1,s1 ; p1, s2 ; p2,t(p1,s2),b(t(p1,s2)),us1 ! p2,empty >,nil,m(p2, empty,empty) >,empty, (idc1,us1,idc2,pr1),F(el(idAct(idc1,us1)), el(idIsCon(idc1,idc1,us1,idc2,pr1)), el(idDiscon(idc1,idc1,us1,idc2,pr1)), el(idComp(idc1,idb1)),ee(idAct(idc2,pr1) ; bot), ee(idRef(idc2,pr1) ; bot), ee(idIsCon(idc2,idc1,us1,idc2,pr1) ; bot), ee(idDiscon(idc2,idc1,us1,idc2,pr1) ; bot), ee(idComp(idc2,idb2) ; bot))) .

------------------------------------------------------End collecting rules-------------------------------
-----------------------------------------------------Rules  for collecting the evaluation of external functions------------



crl [ExternalFunctionsFiringTransitionns] : < (< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,Lx),Rx,F(efls,efes), QRx,  QSx, Wx > , gconfig  =>
< (  < idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix , Lx),Rx,F(efls,efes), QRx, append(QSx,CollectFunctionFiring(m(ps,union(ts, RestrictTransToPlace(b,p) ),tes),< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,ConnectionProIdent(Lx, idd1 ),efes,Wx,QSx)), Wx > , gconfig 
if (RestrictTransToPlace(b,p) =/= empty and CollectFunctionFiring(m(ps,union(ts, RestrictTransToPlace(b,p) ),tes),< idd1,ct,(idbeh ; b(b)) qb,m(p, ps,ts,tes) > , Ix,ConnectionProIdent(Lx, idd1 ),efes,Wx,QSx) =/= nil) . 



crl [ExternalFunctionsEnteringPlace] : < (< idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,Lx),Rx,Fx, QRx, QSx, Wx > , gconfig =>
 < (< idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >  , Ix,Lx),Rx,Fx, QRx, append(QSx,CollectFunctionsEnteringPlace(Pi(s,GetStationPlaces(ct)), GetUsePort(ct), < idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >,
< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) >,Ix, Lx,Fx,Wx,QSx)), Wx > , gconfig

if 
(
  IsSatisfiedTransitionnEndingStation(s,b,te(t(q,s,S),s), tes) 
  and
  (CollectFunctionsEnteringPlace(Pi(s,GetStationPlaces(ct)), GetUsePort(ct), < idd1,ct,(idbeh ; b(b)) qb,m(ps, ts, te(t(q,s,S),s), tes  ) >,
< idd1,ct,(idbeh ; b(b)) qb,m(Pi(s,GetStationPlaces(ct)),ps, ts, RemoveTransitionnEndingStation(tes,s) ) >,Ix, Lx,Fx,Wx,QSx) =/= nil )
) .


crl [ExternalFunctionsForDisconnectPorts] : 
< (Ix,Lx), dcon(idd1,use,idd2,pro) . Rx,F(efls,efes), QRx, QSx, Wx > , gconfig    =>  
< (Ix,Lx), dcon(idd1,use,idd2,pro) . Rx,F(efls,efes), QRx, append(QSx,CollectFunctionsDiscon((idd1,use,idd2,pro),efes,Wx,QSx)), Wx > , gconfig   
if (((idd1,use,idd2,pro) in Lx)  and (CollectFunctionsDiscon((idd1,use,idd2,pro),efes,Wx,QSx) =/= nil) ) .

crl [ExternalFunctionsForWait] :
< (Ix,Lx), wait(idd1,idbeh) . Rx,F(efls,efes), QRx, QSx, Wx > , gconfig    =>  
< (Ix,Lx), wait(idd1,idbeh) . Rx,F(efls,efes), QRx, append(QSx,CollectFunctionWait(idd1,idbeh,efes,Wx,QSx)), Wx > , gconfig   
if (CollectFunctionWait(idd1,idbeh,efes,Wx,QSx) =/= nil ) .

--------------------------------------------------------End of evolution components---------------------------------------------------------------
------------------------------------------------------- Instructions of program------------------------------------------------------------------------- 

crl [AddComponentInstance] :   < (Ix,Lx), add(id, ct) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>
 < (insert( < id, ct, nil, m(InitialPlace(ct) ,empty,empty)  > , Ix),Lx),  Rx,Fx, QRx, QSx, Wx > ,gconfig if not IsUsedIdentInstances(id,Ix)   .  


crl [DeleteComponentInstance] : < (< idd1,ct,qb,mrk > ,Ix,Lx), del(id) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>   
< (Ix,Lx), Rx,Fx, QRx, QSx, Wx > , gconfig  if (id == idd1 and (not InConnectionIdent(id,Lx)) ) . 

crl [ConnectPorts] : < (Ix,Lx), con(id,use,idd1,pro) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>   
< (Ix,(id,use,idd1,pro),Lx), Rx,Fx, QRx, QSx, Wx > , gconfig  
if (id =/= idd1 and ((InstanceIdent(Ix,id) in Ix) or (InstanceIdent(Ix,idd1) in Ix)) and (not InConnectionIdentUsePort(id,use,Lx)) ) . ---peut etre reduit la condition comme dans les règles


crl [DisconnectPorts] : < (Ix,Lx), dcon(id,use,idd1,pro) . Rx,Fx, QRx, QSx, Wx > , gconfig    =>  
< (Ix,delete((id,use,idd1,pro),Lx)), Rx,Fx, QRx, QSx, Wx > , gconfig  
if
(  ((id,use,idd1,pro) in Lx)
  and
Eval(idDiscon(id,(id,use,idd1,pro)),Fx,Ix,Lx,dcon(id,use,idd1,pro) . Rx) == true
and
Eval(idDiscon(idd1,(id,use,idd1,pro)),Fx,Ix,Lx,dcon(id,use,idd1,pro) . Rx) == true
and
Eval(idAct(id,use),Fx,Ix,Lx,dcon(id,use,idd1,pro) . Rx) == false

) .


crl [PushingBehavior] : < (< idd1,ct,qb,mrk >,Ix,Lx), pushB(id, behx, idbeh) . Rx,Fx, QRx, QSx, Wx > , gconfig
=>   < (< idd1,ct,append(qb,(idbeh ; behx)),mrk >,Ix,Lx),  Rx,Fx, QRx, QSx, Wx > , gconfig 
if (id == idd1 and IsBehaviorOfComponent(behx,ct)) .
  

crl [Waiting] : < ( < idd1,ct,qb,mrk > ,Ix,Lx), wait(id,idbeh) . Rx,Fx, QRx, QSx, Wx > , gconfig
=>   < ( < idd1,ct,qb,mrk > ,Ix,Lx), Rx,Fx, QRx, QSx, Wx > , gconfig
if (Eval(idComp(id,idbeh),Fx,Ix,Lx, Rx) == true ) . 


-----------------------------------------------rule for Global Configuration
---crl [GlobalConfiguration] : gconfig, lcx => gconfig, lcy if lcx => lcy /\  gconfig =/= empty .


endm

mod Concerto-PREDS is 
 protecting OPERATIONAL-SEMANTICS . 
 including SATISFACTION .
 subsort LocalConfigurations < State .
 ops d1 d2 d3 :  -> Prop .

 var Q : Prop .

var gconfig : LocalConfigurations .

var Rx : Program .
var Ix  : Instances . 
var Lx  : Connections .
var Fx  : F .
var QSx  : Qsend .
var QRx  : Qrec .
var Wx  : Ws .


var ct : ComponentType .

var use : UsePort .
var pro : ProPort .


var idd1  : IdentC .
vars qb : QBehavoirId .


var p : Place .
var ps : Places .
var ts : Transitionns .
var tes  : TransitionnEndings .

eq (< (< idc1,ct,qb,m(p3, ps,ts,tes) > , Ix,Lx),Rx,Fx, QRx,  QSx, Wx >, gconfig)  |= d1 = true .
eq (< (< idc2,ct,qb,m(q3, ps,ts,tes) > , Ix,Lx),Rx,Fx, QRx,  QSx, Wx >, gconfig)  |= d2 = true .
eq (< (< idc3,ct,qb,m(p3, ps,ts,tes) > , Ix,Lx),Rx,Fx, QRx,  QSx, Wx >, gconfig)  |= d3 = true .
eq gconfig  |= Q = false [owise] .
 ---eq < ( < "id1",ct,bl,m(p3, p,te,tes) > ,I, L),  R >  |= AccessibleStateP3  = true .
 ---ceq < ( I, L),  R >  |= activeUs1 = true if(active(InstanceIdent(I,"id1"),us1)) .
 ---ceq < ( I, L),  R >  |= activePr1 = true if(active(InstanceIdent(I,"id2"),pr1)) .
 ---eq < (I, L),  R > |= Q = false [owise] . 
endm

mod Concerto-CHECK is 
 protecting Concerto-PREDS . 
 including MODEL-CHECKER . 
 including LTL-SIMPLIFIER . 

ops c1 c2 cc11 cc22 : -> ComponentType .
ops confx confy confxx confyy confzz  : -> LocalConfiguration .
ops  test  test1 : -> LocalConfigurations .

eq c1 =  < (p1, p2) , p1 , (s1 ; p1, s2 ; p2), (t(p1, s2) ), (b(t(p1, s2))) , us1 ! (p2), empty   > .
eq c2 =  < (q1, q2) , q1 , (r1 ; q1, r2 ; q2), (t(q1, r2) ), (b(t(q1, r2))) , empty, pr1 ? (q2) > .
eq confx = < (empty, empty) , add(idc1,c1)  . con(idc1,us1,idc2,pr1) .  pushB(idc1,b(t(p1, s2)),idb1) . [], F(el(idIsCon(idc1,(idc1,us1,idc2,pr1))),el(idComp(idc1,idb1)),el(idAct(idc1,us1)),el(idDiscon(idc1,idc1,us1,idc2,pr1) ) , ee(idIsCon(idc2,(idc1,us1,idc2,pr1)) ; bot), ee(idComp(idc2,idb2) ; bot ) , ee(idRef(idc2,pr1) ; bot), ee(idAct(idc2,pr1) ; bot),ee(idDiscon(idc2,idc1,us1,idc2,pr1) ; bot)), nil, nil  , empty >  .
eq confy = < (empty, empty) , add(idc2,c2)  . con(idc1,us1,idc2,pr1) .   pushB(idc2,b(t(q1, r2)),idb2) . [], F(el(idIsCon(idc2,(idc1,us1,idc2,pr1))),el(idComp(idc2,idb2)), el(idAct(idc2,pr1)),el(idRef(idc2,pr1)),el(idDiscon(idc2,idc1,us1,idc2,pr1))  ,ee(idIsCon(idc1,(idc1,us1,idc2,pr1)) ; bot), ee(idComp(idc1,idb1) ; bot ) , ee(idAct(idc1,us1) ; bot),ee(idDiscon(idc1,idc1,us1,idc2,pr1) ; bot)), nil, nil , empty >  .
---eq confy = < (empty, empty) , add(idc2,c2)  . con(idc1,us1,idc2,pr1) . [], F(el(idIsCon(idc2,(idc1,us1,idc2,pr1))),el(idComp(idc2,idb2)), el(idAct(idc2,pr1)),el(idRef(idc2,pr1)),el(idDiscon(idc2,idc1,us1,idc2,pr1))  ,ee(idIsCon(idc1,(idc1,us1,idc2,pr1)) ; bot), ee(idComp(idc1,idb1) ; bot ) , ee(idAct(idc1,us1) ; bot),ee(idDiscon(idc1,idc1,us1,idc2,pr1) ; bot)), nil, nil , empty >  .



eq cc11 =  < (p1, p2, p3) , p1 , (s1 ; p1, s2 ; p2, s3 ; p3), (t(p1, s2), t(p2, s3) ), (b(t(p2, s3),t(p1, s2))) , us1 ! (p3), empty   > .
eq cc22 =  < (q1, q2, q3) , q1 , (r1 ; q1, r2 ; q2, r3 ; q3), (t(q1, r2), t(q2, r3) ), (b(t(q2, r3),t(q1, r2))) , empty, pr1 ? (q3) > .



eq confxx = < (empty, empty) , add(idc1,cc11)  . con(idc1,us1,idc2,pr1) .  pushB(idc1,b(t(p2, s3),t(p1, s2)),idb1) . [], F(el(idIsCon(idc1,(idc1,us1,idc2,pr1))),el(idComp(idc1,idb1)),el(idAct(idc1,us1)),el(idDiscon(idc1,idc1,us1,idc2,pr1) ) , ee(idIsCon(idc2,(idc1,us1,idc2,pr1)) ; bot), ee(idComp(idc2,idb2) ; bot ) , ee(idRef(idc2,pr1) ; bot), ee(idAct(idc2,pr1) ; bot),ee(idDiscon(idc2,idc1,us1,idc2,pr1) ; bot)), nil, nil  , empty >  .
eq confzz = < (empty, empty) , add(idc3,cc11)  . con(idc3,us1,idc2,pr1) .  pushB(idc3,b(t(p2, s3),t(p1, s2)),idb3) . [], F(el(idIsCon(idc3,(idc3,us1,idc2,pr1))),el(idComp(idc3,idb3)),el(idAct(idc3,us1)),el(idDiscon(idc3,idc3,us1,idc2,pr1) ) , ee(idIsCon(idc2,(idc3,us1,idc2,pr1)) ; bot), ee(idComp(idc2,idb2) ; bot ) , ee(idRef(idc2,pr1) ; bot), ee(idAct(idc2,pr1) ; bot),ee(idDiscon(idc2,idc3,us1,idc2,pr1) ; bot)), nil, nil  , empty >  .

eq confyy = < (empty, empty) , add(idc2,cc22)  . con(idc1,us1,idc2,pr1) .   pushB(idc2,b(t(q2, r3),t(q1, r2)),idb2) . [], F(el(idIsCon(idc2,(idc1,us1,idc2,pr1))),el(idComp(idc2,idb2)), el(idAct(idc2,pr1)),el(idRef(idc2,pr1)),el(idDiscon(idc2,idc1,us1,idc2,pr1))  ,ee(idIsCon(idc1,(idc1,us1,idc2,pr1)) ; bot), ee(idComp(idc1,idb1) ; bot ) , ee(idAct(idc1,us1) ; bot),ee(idDiscon(idc1,idc1,us1,idc2,pr1) ; bot)), nil, nil , empty >  .

----eq confw = < (empty, empty) , add(idc1,c33)  .  pushB(idc1,b(t(p2, s3),t(p1, s2)),idb1)  . [], F(el(idComp(idc1,idb1)) , empty), nil, nil  , empty >  .

---eq c33 =  < (p1, p2, p3) , p1 , (s1 ; p1, s2 ; p2, s3 ; p3), (t(p1, s2), t(p2, s3) ), (b(t(p2, s3),t(p1, s2))) , empty, empty   > .
 
eq test = confxx, confyy, confzz .

eq test1 =  confx, confy .

endm


---red modelCheck(test, [] ( (d1 \/ d3)  -> d2 )) .  verifié

--- red modelCheck(test1, [] ( d1 -> d2 )) .
--- red modelCheck(gconf1, [] ( d1 -> d2 )) . il tourne infiniement
--- red modelCheck(gconf1, [] ( (d1 \/ d2) -> d3 )) .
--- red modelCheck(confw, <> ( d1 )) .   non verifiée

---red modelCheck(Fig1, <> AccessibleStateP3  ) .
---red modelCheck(Fig2, <> AccessibleStateP3  ) .

