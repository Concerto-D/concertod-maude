
mod OPERATIONAL-SEMANTICS is

  pr LISTENER-SENSOR-EXAMPLE .

  --- Considering two nodes x and y

  vars Dst Id1 Id2 : IdInstance .
  var Idsx Idsy : IdInstances .
  var Q : Query .
  var R : Request .
  vars Isx Isy : Instances .
  vars Csx Csy : Connections .
  vars RPx, RPy : Program .
  vars RcvAnsx RcvAnsy : Map{Request, Bool} .
  vars OutAnsx OutAnsy : List{Request} . 
  vars OutReqx OutReqy : List{Request} .
  vars Hx Hy : Set{Request} .
  vars Bx By : List{Message} .
  var Val : Bool .
  var Ct : ComponentType .
  var Use : UsePort .
  var Pro : ProvidePort .

  vars Qb Qb1 : List{BehaviorWithId} .
  var B : Behavior .
  var M : Marking .
  var IdB : IdBehavior .

  vars P P1 P2 : Place .
  var Ps : Places .
  vars Ts : Transitions .
  var TsB : Transitions .
  var Tes : TransitionEndings .
  var Ss : Stations .
  var S : Station .

  -------------------------------------------------Rules for component evolution------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------

crl [FiringTransitions] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m((P, Ps),Ts,Tes) }) , Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      > 
    =>
    < nodeInventory: Idsx,
      instances:  (Id1 |-> { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m(Ps,union(Ts, getTransitionsofPlace(TsB,P) ),Tes) }), Isx , 
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    if ( getTransitionsofPlace(TsB,P) =/= empty and
        isSafeToFire(Idsx,m(Ps,union(Ts, getTransitionsofPlace(TsB,P) ),Tes) ,(Id1 |-> { type: Ct,
        queueBehavior: (IdB ; b(TsB)) Qb,marking: m(P, Ps,Ts,Tes) } ,Isx),RcvAnsx,getPConnectionsofCInst(Id1, Csx))) . 


  rl [EndingTransition] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: m(Ps, t(P1,S,Ss), Ts,Tes) }) , Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      > 
    =>
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: m(Ps, Ts, te(t(P1,S,Ss),S), Tes ) }) , Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx  >   .

  crl [EnteringPlace] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m(Ps, Ts, te(t(P1,S,Ss),S), Tes  ) }), Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >   
    =>
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,
      marking: m(getPlacefromStation(S,getStationPlaces(Ct)),Ps, Ts, rmTesOfStation(Tes,S) ) }) , Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    if 
      (isSatisfiedTransitionEndingStation(S,TsB,te(t(P1,S,Ss),S), Tes) and 
      isConnectedAndAllowed(Idsx,Id1,getPlacefromStation(S,getStationPlaces(Ct)), getUsePorts(Ct), { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m(Ps, Ts, te(t(P1,S,Ss),S), Tes) },
      { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m(getPlacefromStation(S,getStationPlaces(Ct)),Ps, Ts, rmTesOfStation(Tes,S) ) } ,Isx, Csx,RcvAnsx)
      ) .  

  crl [FinishingBehavior] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m(Ps,empty,empty) }) , Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    =>
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: m(Ps,empty,empty) })  , Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    if (intersection(Ps,getSourcesOfTransitions(TsB)) == empty) .

  -------------------------------------------------- Rules for program instructions------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------
 

  crl [AddComponentInstance] :   
    < nodeInventory: Idsx,
      instances: Isx,
      connections: Csx,
      program: add(Id1, Ct) RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >    
    =>
    < nodeInventory: Idsx,
      instances: insert(Id1, { type: Ct,queueBehavior: nil,marking: m(getInitialPlace(Ct) ,empty,empty) }, Isx),
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >     
    if (not isInstanceIdUsed(Id1,Isx))   .  

  crl [DeleteComponentInstance] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: M }) ,Isx,
      connections: Csx,
      program: del(Id1) RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >   
    =>   
    < nodeInventory: Idsx,
      instances: Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >   
    if (not isCInstinConnections(Id1,Csx) ) . 

  crl [ConnectPorts] : 
    < nodeInventory: Idsx,
      instances: (Dst |-> { type: Ct,queueBehavior: Qb,marking: M }) , Isx,
      connections: Csx,
      program: con((Id1,Use)--(Id2,Pro)) RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >     
    =>   
    < nodeInventory: Idsx,
      instances: (Dst |-> { type: Ct,queueBehavior: Qb,marking: M }) , Isx,
      connections: (Id1,Use)--(Id2,Pro), Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      > 
    if (Id1 =/= Id2 and ((Dst == Id1) or (Dst == Id2)) and (not isUseinConnections(Id1,Use,Csx)) ) . 

  crl [disconnectPorts] : 
    < nodeInventory: Idsx,
      instances: Isx,
      connections: (Id1,Use)--(Id2,Pro), Csx, 
      program: dcon((Id1,Use)--(Id2,Pro)) RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >     
    =>  
    < nodeInventory: Idsx,
      instances: Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      > 
    if
    ( 
    funCall([ dst: Id1 , query: onDisconnect((Id1,Use)--(Id2,Pro)) ],Idsx,RcvAnsx,Isx,Csx,dcon((Id1,Use)--(Id2,Pro)) RPx) == true and
    funCall([ dst: Id2 , query: onDisconnect((Id1,Use)--(Id2,Pro)) ],Idsx,RcvAnsx,Isx,Csx,dcon((Id1,Use)--(Id2,Pro)) RPx) == true and 
    funCall([ dst: Id1 , query: isActive(Use) ],Idsx,RcvAnsx,Isx,Csx,dcon((Id1,Use)--(Id2,Pro)) RPx) == false
    ) .
  
  crl [PushingBehavior] : 
   < nodeInventory: Idsx,
     instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: M }) , Isx,
     connections: Csx, 
     program: pushB(Id1, B, IdB) RPx,
     receivedAnswers: RcvAnsx,
     outgoingAnswers: OutAnsx,
     outgoingRequests: OutReqx,
     history: Hx,
     buffer: Bx >  
    =>   
   < nodeInventory: Idsx,
     instances: ( Id1 |-> { type: Ct,queueBehavior: append(Qb,(IdB ; B)),marking: M } ), Isx,
     connections: Csx,
     program: RPx,
     receivedAnswers: RcvAnsx,
     outgoingAnswers: OutAnsx,
     outgoingRequests: OutReqx,
     history: Hx,
     buffer: Bx 
      >   
    if (isBehaviorInComponent(B,Ct)) .

  --- TODO éventuel (à appliquer partout) Fred manipuler les queues directement dans la règle sans evaluation
  --- TODO plus de règles (locales et externes)
  crl [Waiting] : 
    < nodeInventory: Idsx,
      instances: ( Id1 |-> { type: Ct,queueBehavior: Qb,marking: M }) , Isx,
      connections: Csx, 
      program: wait(Id2,IdB) RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    =>   
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: M }) ,Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    if (funCall([ dst: Id2 , query: isCompleted(IdB) ],Idsx,RcvAnsx,Isx,Csx,wait(Id2,IdB) RPx) == true ) .
   
  -----------------------------------------------Rules for collecting messages related to external used functions------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------

  crl [RequestsForFiringTransitions] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m((P, Ps),Ts,Tes) }) , Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >   
    =>
    < nodeInventory: Idsx, 
      instances:  (Id1 |-> { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m((P, Ps),Ts,Tes) }) , Isx ,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: append(OutReqx,collectMsgFiring(Idsx,m(Ps,union(Ts, getTransitionsofPlace(TsB,P) ),Tes),
      (Id1 |-> { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m((P, Ps),Ts,Tes) }) , Isx,getPConnectionsofCInst(Id1,Csx),RcvAnsx,Hx,OutReqx)),
      history: Hx,
      buffer: Bx 
      >   
    if (getTransitionsofPlace(TsB,P) =/= empty and collectMsgFiring(Idsx,m(Ps,union(Ts, getTransitionsofPlace(TsB,P) ),Tes),
    (Id1 |-> { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m((P, Ps),Ts,Tes) }) , Isx,getPConnectionsofCInst(Id1,Csx ),RcvAnsx,Hx,OutReqx) =/= nil) . 

  crl [RequestsForEnteringPlace] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes) })  , Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      > 
    => 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes  ) })  , Isx,
      connections: Csx,
      program: RPx, 
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: append(OutReqx,collectMsgEnteringPlace(Idsx,Id1,getPlacefromStation(S,getStationPlaces(Ct)), getUsePorts(Ct), 
      { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes  ) },
      { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m(getPlacefromStation(S,getStationPlaces(Ct)),Ps, Ts, rmTesOfStation(Tes,S) ) },
      Isx,Csx,RcvAnsx,Hx,OutReqx)), 
      history: Hx,
      buffer: Bx 
      >  
    if 
    ( isSatisfiedTransitionEndingStation(S,TsB,te(t(P,S,Ss),S), Tes)  and
      (collectMsgEnteringPlace(Idsx,Id1,getPlacefromStation(S,getStationPlaces(Ct)), getUsePorts(Ct), 
      { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes) },
      { type: Ct,queueBehavior: (IdB ; b(TsB)) Qb,marking: m(getPlacefromStation(S,getStationPlaces(Ct)),Ps, Ts, rmTesOfStation(Tes,S) ) },
      Isx, Csx,RcvAnsx,Hx,OutReqx) =/= nil )
    ) .

  crl [RequestsForDisconnectPorts] : 
    < nodeInventory: Idsx,
      instances: Isx,
      connections: ((Id1,Use)--(Id2,Pro)), Csx,
      program: dcon((Id1,Use)--(Id2,Pro)) RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >     
    =>  
    < nodeInventory: Idsx,
      instances: Isx,
      connections: ((Id1,Use)--(Id2,Pro)), Csx,
      program: dcon((Id1,Use)--(Id2,Pro)) RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: append(OutReqx,collectMsgDisconnect(Idsx,((Id1,Use)--(Id2,Pro)),RcvAnsx,Hx,OutReqx)),
      history: Hx,
      buffer: Bx 
      >    
    if ( (collectMsgDisconnect(Idsx,(Id1,Use)--(Id2,Pro),RcvAnsx,Hx,OutReqx) =/= nil) ) .

  crl [RequestsForWait] :
    < nodeInventory: Idsx,
      instances: Isx,
      connections: Csx,
      program: wait(Id1,IdB) RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >     
    =>  
    < nodeInventory: Idsx,
      instances: Isx,
      connections: Csx,
      program: wait(Id1,IdB) RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx, 
      outgoingRequests: append(OutReqx,collectMsgWait(Idsx,Id1,IdB,RcvAnsx,Hx,OutReqx)),
      history: Hx,
      buffer: Bx 
      >     
    if (collectMsgWait(Idsx,Id1,IdB,RcvAnsx,Hx,OutReqx) =/= nil ) .

  --------------------------------------------------------------Rules for communication---------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------
 
rl [SendRequest] : 
    < nodeInventory: Idsx, 
      instances: Isx, 
      connections: Csx, 
      program: RPx, 
      receivedAnswers: RcvAnsx, 
      outgoingAnswers: OutAnsx, 
      outgoingRequests: [ dst: Dst, query: Q ] OutReqx, 
      history: Hx,
      buffer: Bx > , 
    < nodeInventory: (Dst, Idsy), 
      instances: Isy, 
      connections: Csy, 
      program: RPy, 
      receivedAnswers: RcvAnsy, 
      outgoingAnswers: OutAnsy, 
      outgoingRequests: OutReqy, 
      history: Hy,
      buffer: By >
    => 
    < nodeInventory: Idsx, 
      instances: Isx, 
      connections: Csx, 
      program: RPx, 
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx, 
      outgoingRequests: OutReqx, 
      history: [ dst: Dst, query: Q ], Hx,
      buffer: Bx > ,
    < nodeInventory: (Dst, Idsy), 
      instances: Isy, 
      connections: Csy, 
      program: RPy, 
      receivedAnswers: RcvAnsy, 
      outgoingAnswers:  OutAnsy,
      outgoingRequests: OutReqy,
      history: Hy,
      buffer: append(By, reqMsg([ dst: Dst, query: Q ]))     > .
    

  crl [SendAnswer] : 
    < nodeInventory: Idsx, 
      instances: Isx, 
      connections: Csx, 
      program: RPx, 
      receivedAnswers: RcvAnsx, 
      outgoingAnswers: R OutAnsx,  
      outgoingRequests: OutReqx, 
      history: Hx,
      buffer: Bx > , 
    < nodeInventory: Idsy, 
      instances: Isy, 
      connections: Csy, 
      program: RPy, 
      receivedAnswers: RcvAnsy, 
      outgoingAnswers: OutAnsy, 
      outgoingRequests: OutReqy, 
      history: R, Hy,
      buffer: By >
    => 
    < nodeInventory: Idsx, 
      instances: Isx, 
      connections: Csx, 
      program: RPx, 
      receivedAnswers: upDateReceivedAnswers(RcvAnsx,IdInstanceConnectionWhenSendActive(Csx,R,localFunCall(R,Isx,Csx,RPx))) ,
      outgoingAnswers: OutAnsx, 
      outgoingRequests: OutReqx, 
      history: Hx,
      buffer: Bx > ,
    < nodeInventory: Idsy, 
      instances: Isy, 
      connections: Csy, 
      program: RPy, 
      receivedAnswers: RcvAnsy,
      outgoingAnswers: OutAnsy, 
      outgoingRequests: OutReqy,
      history: (R, Hy),
      buffer: append(By, ansMsg([ req: R, value: localFunCall(R,Isx,Csx,RPx) ])) > 
    if (not occurs(reqMsg(R), By)) .

    rl [ReceiveRequest] : 
    < nodeInventory: (Dst, Idsx),
      instances: Isx,
      connections: Csx,
      program: RPx,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: reqMsg([dst: Dst, query: Q]) Bx >   
    => 
  < nodeInventory: (Dst,Idsx),
    instances: Isx,
    connections: Csx,
    program: RPx,
    receivedAnswers: RcvAnsx,
    outgoingAnswers: append(OutAnsx,[ dst: Dst, query: Q ]), 
    outgoingRequests: OutReqx,
    history: Hx,
    buffer: Bx >  .

    rl [ReceiveAnswer] : 
  < nodeInventory: Idsx,
    instances: Isx,
    connections: Csx,
    program: RPx,
    receivedAnswers: RcvAnsx,
    outgoingAnswers: OutAnsx, 
    outgoingRequests: OutReqx,
    history: (R,Hx),
    buffer: ansMsg([ req: R, value: Val ]) Bx >  
      =>
  < nodeInventory: Idsx,
    instances: Isx,
    connections: Csx,
    program: RPx,
    receivedAnswers: insert(R,Val,RcvAnsx),
    outgoingAnswers: OutAnsx, 
    outgoingRequests: OutReqx,
    history: Hx,
    buffer: Bx > .
    
endm

