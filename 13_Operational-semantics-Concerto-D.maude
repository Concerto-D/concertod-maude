
mod OPERATIONAL-SEMANTICS is

  pr LISTENER-SENSOR-EXAMPLE .

  vars Dst Id1 Id2 : IdInstance .
  var Idsx Idsy : IdInstances .
  var Q : Query .
  var R : Request .
  vars Ix Iy : Instances .
  vars Cx Cy : Connections .
  vars Px, Py : Program .
  vars RcvAnsx RcvAnsy : Map{Request, Bool} .
  vars OutAnsx OutAnsy : List{Request} . 
  vars OutReqx OutReqy : List{Request} .
  vars Hx Hy : Set{Request} .
  vars Bx By : List{Message} .
  var Val : Bool .
  var Ct : ComponentType .
  var Use : UsePort .
  var pro : ProvidePort .

  vars Qb Qb1 : List{BehaviorWithId} .
  var Beh : Behavior .
  var Mrk : Marking .
  var IdBeh : IdBehavior .

  vars P P1 P2 : Place .
  var Ps : Places .
  vars Ts : Transitions .
  var TsBeh : Transitions .
  var Tes : TransitionEndings .
  var Ss : Stations .
  var S : Station .

  -------------------------------------------------Rules for component evolution------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------

crl [FiringTransitions] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m((P, Ps),Ts,Tes) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      > 
    =>
    < nodeInventory: Idsx,
      instances:  (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps,union(Ts, restrictTransitionsToPlace(TsBeh,P) ),Tes) }), Ix , 
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    if ( restrictTransitionsToPlace(TsBeh,P) =/= empty and
        safeToFire(Idsx,m(Ps,union(Ts, restrictTransitionsToPlace(TsBeh,P) ),Tes) ,(Id1 |-> { type: Ct,
        queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(P, Ps,Ts,Tes) } ,Ix),RcvAnsx,connectionProIdent(Id1, Cx))) . 


  rl [EndingTransition] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: m(Ps, t(P1,S,Ss), Ts,Tes) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      > 
    =>
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: m(Ps, Ts, te(t(P1,S,Ss),S), Tes ) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx  >   .

  crl [EnteringPlace] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P1,S,Ss),S), Tes  ) }), Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >   
    =>
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,
      marking: m(getPlacefromStation(S,getStationPlaces(Ct)),Ps, Ts, removeTransitionEndingStation(Tes,S) ) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    if 
      (isSatisfiedTransitionEndingStation(S,TsBeh,te(t(P1,S,Ss),S), Tes) and 
      connectedAndAllowed(Idsx,Id1,getPlacefromStation(S,getStationPlaces(Ct)), getUsePorts(Ct), { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P1,S,Ss),S), Tes) },
      { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(getPlacefromStation(S,getStationPlaces(Ct)),Ps, Ts, removeTransitionEndingStation(Tes,S) ) } ,Ix, Cx,RcvAnsx)
      ) .  

  crl [FinishingBehavior] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps,empty,empty) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    =>
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: m(Ps,empty,empty) })  , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    if (intersection(Ps,placesSourceOfTransitions(TsBeh)) == empty) .

  -------------------------------------------------- Rules for program instructions------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------
 

  crl [AddComponentInstance] :   
    < nodeInventory: Idsx,
      instances: Ix,
      connections: Cx,
      program: add(Id1, Ct) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >    
    =>
    < nodeInventory: Idsx,
      instances: insert(Id1, { type: Ct,queueBehavior: nil,marking: m(initialPlace(Ct) ,empty,empty) }, Ix),
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >     
    if (not isUsedIdInstances(Id1,Ix))   .  

  crl [DeleteComponentInstance] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) ,Ix,
      connections: Cx,
      program: del(Id1) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >   
    =>   
    < nodeInventory: Idsx,
      instances: Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >   
    if (not inConnectionIdent(Id1,Cx) ) . 

  crl [ConnectPorts] : 
    < nodeInventory: Idsx,
      instances: (Dst |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) , Ix,
      connections: Cx,
      program: con(Id1,Use,Id2,pro) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >     
    =>   
    < nodeInventory: Idsx,
      instances: (Dst |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) , Ix,
      connections: (Id1,Use,Id2,pro), Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      > 
    if (Id1 =/= Id2 and ((Dst == Id1) or (Dst == Id2)) and (not inConnectionIdentUsePort(Id1,Use,Cx)) ) . 

  crl [disconnectPorts] : 
    < nodeInventory: Idsx,
      instances: Ix,
      connections: (Id1,Use,Id2,pro), Cx, 
      program: dcon(Id1,Use,Id2,pro) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >     
    =>  
    < nodeInventory: Idsx,
      instances: Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      > 
    if
    ( 
    evaluation([ dst: Id1 , query: isDisconnect(Id1,Use,Id2,pro) ],Idsx,RcvAnsx,Ix,Cx,dcon(Id1,Use,Id2,pro) Px) == true and
    evaluation([ dst: Id2 , query: isDisconnect(Id1,Use,Id2,pro) ],Idsx,RcvAnsx,Ix,Cx,dcon(Id1,Use,Id2,pro) Px) == true and 
    evaluation([ dst: Id1 , query: isActive(Use) ],Idsx,RcvAnsx,Ix,Cx,dcon(Id1,Use,Id2,pro) Px) == false
    ) .
  
  crl [PushingBehavior] : 
   < nodeInventory: Idsx,
     instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) , Ix,
     connections: Cx, 
     program: pushB(Id1, Beh, IdBeh) Px,
     receivedAnswers: RcvAnsx,
     outgoingAnswers: OutAnsx,
     outgoingRequests: OutReqx,
     history: Hx,
     buffer: Bx >  
    =>   
   < nodeInventory: Idsx,
     instances: ( Id1 |-> { type: Ct,queueBehavior: append(Qb,(IdBeh ; Beh)),marking: Mrk } ), Ix,
     connections: Cx,
     program: Px,
     receivedAnswers: RcvAnsx,
     outgoingAnswers: OutAnsx,
     outgoingRequests: OutReqx,
     history: Hx,
     buffer: Bx 
      >   
    if (isBehaviorOfComponent(Beh,Ct)) .

  --- TODO éventuel (à appliquer partout) Fred manipuler les queues directement dans la règle sans evaluation
  --- TODO plus de règles (locales et externes)
  crl [Waiting] : 
    < nodeInventory: Idsx,
      instances: ( Id1 |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) , Ix,
      connections: Cx, 
      program: wait(Id2,IdBeh) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    =>   
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) ,Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >  
    if (evaluation([ dst: Id2 , query: isCompleted(IdBeh) ],Idsx,RcvAnsx,Ix,Cx,wait(Id2,IdBeh) Px) == true ) .
   
  -----------------------------------------------Rules for collecting messages related to external used functions------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------

  crl [RequestsForFiringTransitions] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m((P, Ps),Ts,Tes) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >   
    =>
    < nodeInventory: Idsx, 
      instances:  (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m((P, Ps),Ts,Tes) }) , Ix ,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: append(OutReqx,collectRuleFiring(Idsx,m(Ps,union(Ts, restrictTransitionsToPlace(TsBeh,P) ),Tes),
      (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m((P, Ps),Ts,Tes) }) , Ix,connectionProIdent(Id1,Cx),RcvAnsx,Hx,OutReqx)),
      history: Hx,
      buffer: Bx 
      >   
    if (restrictTransitionsToPlace(TsBeh,P) =/= empty and collectRuleFiring(Idsx,m(Ps,union(Ts, restrictTransitionsToPlace(TsBeh,P) ),Tes),
    (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m((P, Ps),Ts,Tes) }) , Ix,connectionProIdent(Id1,Cx ),RcvAnsx,Hx,OutReqx) =/= nil) . 

  crl [RequestsForEnteringPlace] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes) })  , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      > 
    => 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes  ) })  , Ix,
      connections: Cx,
      program: Px, 
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: append(OutReqx,collectRuleEnteringPlace(Idsx,Id1,getPlacefromStation(S,getStationPlaces(Ct)), getUsePorts(Ct), 
      { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes  ) },
      { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(getPlacefromStation(S,getStationPlaces(Ct)),Ps, Ts, removeTransitionEndingStation(Tes,S) ) },
      Ix,Cx,RcvAnsx,Hx,OutReqx)), 
      history: Hx,
      buffer: Bx 
      >  
    if 
    ( isSatisfiedTransitionEndingStation(S,TsBeh,te(t(P,S,Ss),S), Tes)  and
      (collectRuleEnteringPlace(Idsx,Id1,getPlacefromStation(S,getStationPlaces(Ct)), getUsePorts(Ct), 
      { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes) },
      { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(getPlacefromStation(S,getStationPlaces(Ct)),Ps, Ts, removeTransitionEndingStation(Tes,S) ) },
      Ix, Cx,RcvAnsx,Hx,OutReqx) =/= nil )
    ) .

  crl [RequestsForDisconnectPorts] : 
    < nodeInventory: Idsx,
      instances: Ix,
      connections: (Id1,Use,Id2,pro), Cx,
      program: dcon(Id1,Use,Id2,pro) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >     
    =>  
    < nodeInventory: Idsx,
      instances: Ix,
      connections: (Id1,Use,Id2,pro), Cx,
      program: dcon(Id1,Use,Id2,pro) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: append(OutReqx,collectRuleDisconnect(Idsx,(Id1,Use,Id2,pro),RcvAnsx,Hx,OutReqx)),
      history: Hx,
      buffer: Bx 
      >    
    if ( (collectRuleDisconnect(Idsx,(Id1,Use,Id2,pro),RcvAnsx,Hx,OutReqx) =/= nil) ) .

  crl [RequestsForWait] :
    < nodeInventory: Idsx,
      instances: Ix,
      connections: Cx,
      program: wait(Id1,IdBeh) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: Bx 
      >     
    =>  
    < nodeInventory: Idsx,
      instances: Ix,
      connections: Cx,
      program: wait(Id1,IdBeh) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx, 
      outgoingRequests: append(OutReqx,collectRuleWait(Idsx,Id1,IdBeh,RcvAnsx,Hx,OutReqx)),
      history: Hx,
      buffer: Bx 
      >     
    if (collectRuleWait(Idsx,Id1,IdBeh,RcvAnsx,Hx,OutReqx) =/= nil ) .

  --------------------------------------------------------------Rules for communication---------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------
 
rl [SendRequest] : 
    < nodeInventory: Idsx, 
      instances: Ix, 
      connections: Cx, 
      program: Px, 
      receivedAnswers: RcvAnsx, 
      outgoingAnswers: OutAnsx, 
      outgoingRequests: [ dst: Dst, query: Q ] OutReqx, 
      history: Hx,
      buffer: Bx > , 
    < nodeInventory: (Dst, Idsy), 
      instances: Iy, 
      connections: Cy, 
      program: Py, 
      receivedAnswers: RcvAnsy, 
      outgoingAnswers: OutAnsy, 
      outgoingRequests: OutReqy, 
      history: Hy,
      buffer: By >
    => 
    < nodeInventory: Idsx, 
      instances: Ix, 
      connections: Cx, 
      program: Px, 
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx, 
      outgoingRequests: OutReqx, 
      history: [ dst: Dst, query: Q ], Hx,
      buffer: Bx > ,
    < nodeInventory: (Dst, Idsy), 
      instances: Iy, 
      connections: Cy, 
      program: Py, 
      receivedAnswers: RcvAnsy, 
      outgoingAnswers:  OutAnsy,
      outgoingRequests: OutReqy,
      history: Hy,
      buffer: append(By, reqMsg([ dst: Dst, query: Q ]))     > .
    

  crl [SendAnswer] : 
    < nodeInventory: Idsx, 
      instances: Ix, 
      connections: Cx, 
      program: Px, 
      receivedAnswers: RcvAnsx, 
      outgoingAnswers: R OutAnsx,  
      outgoingRequests: OutReqx, 
      history: Hx,
      buffer: Bx > , 
    < nodeInventory: Idsy, 
      instances: Iy, 
      connections: Cy, 
      program: Py, 
      receivedAnswers: RcvAnsy, 
      outgoingAnswers: OutAnsy, 
      outgoingRequests: OutReqy, 
      history: R, Hy,
      buffer: By >
    => 
    < nodeInventory: Idsx, 
      instances: Ix, 
      connections: Cx, 
      program: Px, 
      receivedAnswers: upDateReceivedAnswers(RcvAnsx,IdInstanceConnectionWhenSendActive(Cx,R,localEvaluation(R,Ix,Cx,Px))) ,
      outgoingAnswers: OutAnsx, 
      outgoingRequests: OutReqx, 
      history: Hx,
      buffer: Bx > ,
    < nodeInventory: Idsy, 
      instances: Iy, 
      connections: Cy, 
      program: Py, 
      receivedAnswers: RcvAnsy,
      outgoingAnswers: OutAnsy, 
      outgoingRequests: OutReqy,
      history: (R, Hy),
      buffer: append(By, ansMsg([ req: R, value: localEvaluation(R,Ix,Cx,Px) ])) > 
    if (not occurs(reqMsg(R), By)) .

    rl [ReceiveRequest] : 
    < nodeInventory: (Dst, Idsx),
      instances: Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx,
      buffer: reqMsg([dst: Dst, query: Q]) Bx >   
    => 
  < nodeInventory: (Dst,Idsx),
    instances: Ix,
    connections: Cx,
    program: Px,
    receivedAnswers: RcvAnsx,
    outgoingAnswers: append(OutAnsx,[ dst: Dst, query: Q ]), 
    outgoingRequests: OutReqx,
    history: Hx,
    buffer: Bx >  .

    rl [ReceiveAnswer] : 
  < nodeInventory: Idsx,
    instances: Ix,
    connections: Cx,
    program: Px,
    receivedAnswers: RcvAnsx,
    outgoingAnswers: OutAnsx, 
    outgoingRequests: OutReqx,
    history: (R,Hx),
    buffer: ansMsg([ req: R, value: Val ]) Bx >  
      =>
  < nodeInventory: Idsx,
    instances: Ix,
    connections: Cx,
    program: Px,
    receivedAnswers: insert(R,Val,RcvAnsx),
    outgoingAnswers: OutAnsx, 
    outgoingRequests: OutReqx,
    history: Hx,
    buffer: Bx > .
    
endm

