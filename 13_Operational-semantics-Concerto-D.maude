
mod OPERATIONAL-SEMANTICS is

  pr LISTENER-SENSOR-EXAMPLE .

  var Lcx Lcy : LocalConfiguration .
  vars IdIx IdIy : IdentInstances .  
  vars Ix Iy : Instances . 
  vars Lx Ly : Connections .
  vars Rx Ry : Program .
  vars Mx My : MsgToUses .
  vars QSx QSy : Qsend .
  vars QRx QRy : Qreceive .
  vars Hx Hy : SentHistorys .
  
  var  M : Msg .
  var Val : BoolWithBot .
  var Ct : ComponentType .
  var Use : UsePort .
  var pro : ProvidePort .

  vars Id1 Id2  : IdentInstance .
  vars Qb Qb1 : QBehaviorWithId .
  var Beh : Behavior .
  var Mrk : Marking .
  var IdBeh : IdentBehavior .

  vars P Q : Place .
  var Ps : Places .
  vars Ts : Transitions .
  var TsBeh : Transitions .
  var Tes : TransitionEndings .
  var Ss : Stations .
  var S : Station .

  -------------------------------------------------Rules for component evolution------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------
crl [FiringTransitions] : 
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(P, Ps,Ts,Tes) > ,Ix,connections: Lx,program: Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx > 
    =>
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps,union(Ts, RestrictTransitionsToPlace(TsBeh,P) ),Tes) >, Ix , connections: Lx,program: Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx > 
  if ( RestrictTransitionsToPlace(TsBeh,P) =/= empty and
   NotActUseWhenLeavinGroupProvide(IdIx,m(Ps,union(Ts, RestrictTransitionsToPlace(TsBeh,P) ),Tes) ,< id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(P, Ps,Ts,Tes) > ,Ix,Mx,ConnectionProIdent(Id1, Lx))) . 


  rl [EndingTransition] : 
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: Qb,marking: m(Ps, t(Q,S,Ss), Ts,Tes) > , Ix,connections: Lx,program: Rx,msgs: Mx,
    receive: QRx,send: QSx,history: Hx > 
    =>
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: Qb,marking: m(Ps, Ts, te(t(Q,S,Ss),S), Tes ) > , Ix,connections: Lx,program: Rx,
    msgs: Mx,receive: QRx,send: QSx,history: Hx >  .

  crl [EnteringPlace] : 
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(Q,S,Ss),S), Tes  ) >  , Ix,connections: Lx,
    program: Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx >  
    =>
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Pi(S,GetStationPlaces(Ct)),Ps, Ts, RemoveTransitionEndingStation(Tes,S) ) > , 
    Ix,connections: Lx,program: Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx > 
    if 
      (IsSatisfiedTransitionEndingStation(S,TsBeh,te(t(Q,S,Ss),S), Tes) 
      and 
      ConnectedAndAllowed(IdIx,Pi(S,GetStationPlaces(Ct)), GetUsePorts(Ct), < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(Q,S,Ss),S), Tes  ) >,
      < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Pi(S,GetStationPlaces(Ct)),Ps, Ts, RemoveTransitionEndingStation(Tes,S) ) >,Ix, Lx,Mx)
      ) .  


  crl [FinishingBehavior] : 
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps,empty,empty) > , Ix,connections: Lx,program: Rx,msgs: Mx,
    receive: QRx,send: QSx,history: Hx >   
    =>
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: Qb,marking: m(Ps,empty,empty) > , Ix,connections: Lx,program: Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx >  
    if (intersection(Ps,PlacesSourceOfTransitions(TsBeh)) == empty) .

  -------------------------------------------------- Rules for program instructions------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------
  crl [AddComponentInstance] :   
    < ids: IdIx,instances: Ix,connections: Lx,program: add(Id1, Ct) Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx >    
    =>
    < ids: IdIx,instances: insert( < id: Id1,type: Ct,queueBehavior: nil,marking: m(InitialPlace(Ct) ,empty,empty)  > , Ix),connections: Lx,program: Rx,
    msgs: Mx,receive: QRx,send: QSx,history: Hx >    
    if (not IsUsedIdentInstances(Id1,Ix))   .  

  crl [DeleteComponentInstance] : 
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: Qb,marking: Mrk > ,Ix,connections: Lx,program: del(Id1) Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx >    
    =>   
    < ids: IdIx,instances: Ix,connections: Lx,program: Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx >  
    if (not InConnectionIdent(Id1,Lx) ) . 

  crl [ConnectPorts] : 
    < ids: IdIx,instances: Ix,connections: Lx,program: con(Id1,Use,Id2,pro) Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx >    
    =>   
    < ids: IdIx,instances: Ix,connections: (Id1,Use,Id2,pro), Lx,program: Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx > 
    if (Id1 =/= Id2 and ((InstanceOfIdent(Ix,Id1) in Ix) or (InstanceOfIdent(Ix,Id2) in Ix)) and (not InConnectionIdentUsePort(Id1,Use,Lx)) ) . 

  crl [DisconnectPorts] : 
    < ids: IdIx,instances: Ix,connections: Lx, program: dcon(Id1,Use,Id2,pro) Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx >    
    =>  
    < ids: IdIx,instances: Ix,connections: delete((Id1,Use,Id2,pro),Lx),program: Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx >  
    if
    (  
    (Id1,Use,Id2,pro) in Lx
    and
    Evaluation(IdIx,ExprDisconnect(Id1,(Id1,Use,Id2,pro)),Mx,Ix,Lx,dcon(Id1,Use,Id2,pro) Rx) == true
    and
    Evaluation(IdIx,ExprDisconnect(Id2,(Id1,Use,Id2,pro)),Mx,Ix,Lx,dcon(Id1,Use,Id2,pro) Rx) == true
    and
    Evaluation(IdIx,ExprActive(Id1,Use),Mx,Ix,Lx,dcon(Id1,Use,Id2,pro) Rx) == false
    ) .
  
  crl [PushingBehavior] : 
   < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: Qb,marking: Mrk >,Ix,connections: Lx, program: pushB(Id1, Beh, IdBeh) Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx > 
    =>   
   < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: append(Qb,(IdBeh ; Beh)),marking: Mrk >,Ix,connections: Lx,program: Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx >  
    if (IsBehaviorOfComponent(Beh,Ct)) .

  crl [Waiting] : 
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: Qb,marking: Mrk > ,Ix,connections: Lx, program: wait(Id2,IdBeh) Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx > 
    =>   
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: Qb,marking: Mrk > ,Ix,connections: Lx,program: Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx > 
    if (Evaluation(IdIx,ExprCompleted(Id2,IdBeh),Mx,Ix,Lx, Rx) == true ) .

  -----------------------------------------------Rules for collecting messages related to external used functions------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------

  crl [MsgToUsesForFiringTransitions] : 
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(P, Ps,Ts,Tes) > , Ix,connections: Lx,program: Rx,msgs: Mx,
    receive: QRx,send: QSx,history: Hx >  
    =>
    < ids: IdIx, instances: < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(P, Ps,Ts,Tes) > , Ix ,connections: Lx,program: Rx,msgs: Mx,
    receive: QRx,send: append(QSx,CollectFunctionFiring(IdIx,m(Ps,union(Ts, RestrictTransitionsToPlace(TsBeh,P) ),Tes),< id: Id1,type: Ct,
    queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(P, Ps,Ts,Tes) > , Ix,ConnectionProIdent(Id1,Lx),Mx,Hx,QSx)),history: Hx >  
    if (RestrictTransitionsToPlace(TsBeh,P) =/= empty and CollectFunctionFiring(IdIx,m(Ps,union(Ts, RestrictTransitionsToPlace(TsBeh,P) ),Tes),
    < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(P, Ps,Ts,Tes) > , Ix,ConnectionProIdent(Id1,Lx ),Mx,Hx,QSx) =/= nil) . 

  crl [MsgToUsesForEnteringPlace] : 
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(Q,S,Ss),S), Tes  ) >  , Ix,connections: Lx,program: Rx,
    msgs: Mx,receive: QRx,send: QSx,history: Hx > 
    =>
    < ids: IdIx,instances: < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(Q,S,Ss),S), Tes  ) >  , Ix,connections: Lx,program: Rx,
    msgs: Mx,receive: QRx,send: append(QSx,CollectFunctionsEnteringPlace(IdIx,Pi(S,GetStationPlaces(Ct)), GetUsePorts(Ct), < id: Id1,type: Ct,
    queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(Q,S,Ss),S), Tes  ) >,
    < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Pi(S,GetStationPlaces(Ct)),Ps, Ts, RemoveTransitionEndingStation(Tes,S) ) >,Ix,Lx,Mx,Hx,QSx)), history: Hx > 
    if 
    (
      IsSatisfiedTransitionEndingStation(S,TsBeh,te(t(Q,S,Ss),S), Tes) 
      and
      (CollectFunctionsEnteringPlace(IdIx,Pi(S,GetStationPlaces(Ct)), GetUsePorts(Ct), < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(Q,S,Ss),S), Tes) >,
      < id: Id1,type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Pi(S,GetStationPlaces(Ct)),Ps, Ts, RemoveTransitionEndingStation(Tes,S) ) >,Ix, Lx,Mx,Hx,QSx) =/= nil )
    ) .

  crl [MsgToUsesForDisconnectPorts] : 
    < ids: IdIx,instances: Ix,connections: Lx,program: dcon(Id1,Use,Id2,pro) Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx >    
    =>  
    < ids: IdIx,instances: Ix,connections: Lx,program: dcon(Id1,Use,Id2,pro) Rx,msgs: Mx,receive: QRx,
    send: append(QSx,CollectFunctionsDiscon(IdIx,(Id1,Use,Id2,pro),Mx,Hx,QSx)),history: Hx >   
    if (((Id1,Use,Id2,pro) in Lx)  and (CollectFunctionsDiscon(IdIx,(Id1,Use,Id2,pro),Mx,Hx,QSx) =/= nil) ) .

  crl [MsgToUsesForWait] :
    < ids: IdIx,instances: Ix,connections: Lx,program: wait(Id1,IdBeh) Rx,msgs: Mx,receive: QRx,send: QSx,history: Hx >     
    =>  
    < ids: IdIx,instances: Ix,connections: Lx,program: wait(Id1,IdBeh) Rx,msgs: Mx,receive: QRx,
    send: append(QSx,CollectFunctionWait(IdIx,Id1,IdBeh,Mx,Hx,QSx)),history: Hx >    
    if (CollectFunctionWait(IdIx,Id1,IdBeh,Mx,Hx,QSx) =/= nil ) .

  --------------------------------------------------------------Rules for communication---------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------

  crl [SendRequest] : 
    < ids: IdIx,instances: Ix,connections: Lx,program: Rx,msgs: Mx,receive: QRx,send: M QSx,history: Hx > , 
    < ids: IdIy,instances: Iy,connections: Ly,program: Ry,msgs: My,receive: QRy,send: QSy,history: Hy >  
    =>
    < ids: IdIx,instances: Ix,connections: Lx,program: Rx,msgs: AddFunctionExtern(M,Mx),receive: QRx,send: QSx, history: (Hx, M) >  ,  
    < ids: IdIy,instances: Iy,connections: Ly,program: Ry,msgs: My,receive: append(QRy, (M ; bot) ),send: QSy,history: Hy > 
    if ( (not LocalFunction(M,IdIx)) and LocalFunction(M,IdIy) ) .

  crl [SendEvaluationFunction] : 
    < ids: IdIx,instances: Ix,connections: Lx,program: Rx,msgs: Mx,receive: QRx,send: M QSx,history: Hx > , 
    < ids: IdIy,instances: Iy,connections: Ly,program: Ry,msgs: My,receive: QRy,send: QSy,history: Hy >   
    =>
    < ids: IdIx,instances: Ix,connections: Lx,program: Rx,msgs: UpDateMsgToUsesSend(Mx,IdentInstanceonnectionWhenSendActive(Lx,M,LocalEvaluation(M,Ix,Lx,Rx))),
    receive: QRx,send: QSx,history: Hx > , 
    < ids: IdIy,instances: Iy,connections: Ly,program: Ry,msgs: My,receive: append(QRy, (M ; LocalEvaluation(M,Ix,Lx,Rx)) ),send: QSy,history: Hy >  
    if ( LocalFunction(M,IdIx) and ((M in Hy) and (not ExistMsgInReceiveQueue(M,QRy) )  ) ) .

  crl [ReceivesRequest] : 
    < ids: IdIx,instances: Ix,connections: Lx,program: Rx,msgs: Mx,receive: (M ; Val ) QRx,send: QSx,history: Hx >  
    =>
    < ids: IdIx,instances: Ix,connections: Lx,program: Rx,msgs: Mx,receive: QRx,send: append(QSx, M ),history: Hx > 
    if ( LocalFunction(M,IdIx) ) .  

  crl [ReceivesEvaluationFunction] : 
    < ids: IdIx,instances: Ix,connections: Lx,program: Rx,msgs: Mx,receive: (M ; Val ) QRx,send: QSx,history: Hx >   
    =>
    < ids: IdIx,instances: Ix,connections: Lx,program: Rx,msgs: SubstitueEvaluationOfFunction(Mx,M,Val),receive: QRx,send: QSx,history: delete(M,Hx) >  
    if ( not LocalFunction(M,IdIx) ) .  

endm

  