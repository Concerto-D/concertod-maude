
mod OPERATIONAL-SEMANTICS is

  pr LISTENER-SENSOR-EXAMPLE .

  vars Dst Id1 Id2 : IdentInstance .
  var Idsx Idsy : IdentInstances .
  var Q : Query .
  vars Ix Iy : Instances .
  vars Cx Cy : Connections .
  vars Px, Py : Program .
  vars RcvAnsx RcvAnsy : Map{Request,ExpectedValue} .
  vars OutAnsx OutAnsy : Qanswers . 
  vars OutReqx OutReqy : Qrequests .
  vars Hx Hy : Set{Request} .

  var Val : ExpectedValue .
  var Ct : ComponentType .
  var Use : UsePort .
  var pro : ProvidePort .

  vars Qb Qb1 : QBehaviorWithId .
  var Beh : Behavior .
  var Mrk : Marking .
  var IdBeh : IdentBehavior .

  vars P P1 P2 : Place .
  var Ps : Places .
  vars Ts : Transitions .
  var TsBeh : Transitions .
  var Tes : TransitionEndings .
  var Ss : Stations .
  var S : Station .

  -------------------------------------------------Rules for component evolution------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------

crl [FiringTransitions] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m((P, Ps),Ts,Tes) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx > 
    =>
    < nodeInventory: Idsx,
      instances:  (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps,union(Ts, restrictTransitionsToPlace(TsBeh,P) ),Tes) }), Ix , 
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx > 
    if ( restrictTransitionsToPlace(TsBeh,P) =/= empty and
        notActiveUseWhenLeavinGroupProvide(Idsx,m(Ps,union(Ts, restrictTransitionsToPlace(TsBeh,P) ),Tes) ,(Id1 |-> { type: Ct,
        queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(P, Ps,Ts,Tes) } ,Ix),RcvAnsx,connectionProIdent(Id1, Cx))) . 


  rl [EndingTransition] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: m(Ps, t(P1,S,Ss), Ts,Tes) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx > 
    =>
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: m(Ps, Ts, te(t(P1,S,Ss),S), Tes ) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >  .

  crl [EnteringPlace] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P1,S,Ss),S), Tes  ) }), Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >  
    =>
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,
      marking: m(placeOfStation(S,getStationPlaces(Ct)),Ps, Ts, removeTransitionEndingStation(Tes,S) ) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx > 
    if 
      (isSatisfiedTransitionEndingStation(S,TsBeh,te(t(P1,S,Ss),S), Tes) and 
      connectedAndAllowed(Idsx,Id1,placeOfStation(S,getStationPlaces(Ct)), getUsePorts(Ct), { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P1,S,Ss),S), Tes) },
      { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(placeOfStation(S,getStationPlaces(Ct)),Ps, Ts, removeTransitionEndingStation(Tes,S) ) } ,Ix, Cx,RcvAnsx)
      ) .  

  crl [FinishingBehavior] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps,empty,empty) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >   
    =>
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: m(Ps,empty,empty) })  , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >  
    if (intersection(Ps,placesSourceOfTransitions(TsBeh)) == empty) .

  -------------------------------------------------- Rules for program instructions------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------
 

  crl [AddComponentInstance] :   
    < nodeInventory: Idsx,
      instances: Ix,
      connections: Cx,
      program: add(Id1, Ct) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >    
    =>
    < nodeInventory: Idsx,
      instances: insert(Id1, { type: Ct,queueBehavior: nil,marking: m(initialPlace(Ct) ,empty,empty) }, Ix),
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >    
    if (not isUsedIdentInstances(Id1,Ix))   .  

  crl [DeleteComponentInstance] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) ,Ix,
      connections: Cx,
      program: del(Id1) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >    
    =>   
    < nodeInventory: Idsx,
      instances: Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >  
    if (not inConnectionIdent(Id1,Cx) ) . 

  crl [ConnectPorts] : 
    < nodeInventory: Idsx,
      instances: (Dst |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) , Ix,
      connections: Cx,
      program: con(Id1,Use,Id2,pro) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >    
    =>   
    < nodeInventory: Idsx,
      instances: (Dst |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) , Ix,
      connections: (Id1,Use,Id2,pro), Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx > 
    if (Id1 =/= Id2 and ((Dst == Id1) or (Dst == Id2)) and (not inConnectionIdentUsePort(Id1,Use,Cx)) ) . 

  crl [disconnectPorts] : 
    < nodeInventory: Idsx,
      instances: Ix,
      connections: (Id1,Use,Id2,pro), Cx, 
      program: dcon(Id1,Use,Id2,pro) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >    
    =>  
    < nodeInventory: Idsx,
      instances: Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >  
    if
    ( 
    evaluation([ dst: Id1 , query: isDisconnect(Id1,Use,Id2,pro) ],Idsx,RcvAnsx,Ix,Cx,dcon(Id1,Use,Id2,pro) Px) == true and
    evaluation([ dst: Id2 , query: isDisconnect(Id1,Use,Id2,pro) ],Idsx,RcvAnsx,Ix,Cx,dcon(Id1,Use,Id2,pro) Px) == true and 
    evaluation([ dst: Id1 , query: isActive(Use) ],Idsx,RcvAnsx,Ix,Cx,dcon(Id1,Use,Id2,pro) Px) == false
    ) .
  
  crl [PushingBehavior] : 
   < nodeInventory: Idsx,
     instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) , Ix,
     connections: Cx, 
     program: pushB(Id1, Beh, IdBeh) Px,
     receivedAnswers: RcvAnsx,
     outgoingAnswers: OutAnsx,
     outgoingRequests: OutReqx,
     history: Hx > 
    =>   
   < nodeInventory: Idsx,
     instances: ( Id1 |-> { type: Ct,queueBehavior: append(Qb,(IdBeh ; Beh)),marking: Mrk } ), Ix,
     connections: Cx,
     program: Px,
     receivedAnswers: RcvAnsx,
     outgoingAnswers: OutAnsx,
     outgoingRequests: OutReqx,
     history: Hx >  
    if (isBehaviorOfComponent(Beh,Ct)) .

  crl [Waiting] : 
    < nodeInventory: Idsx,
      instances: ( Id1 |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) , Ix,
      connections: Cx, 
      program: wait(Id2,IdBeh) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx > 
    =>   
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: Qb,marking: Mrk }) ,Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx > 
    if (evaluation([ dst: Id2 , query: isCompleted(IdBeh) ],Idsx,RcvAnsx,Ix,Cx,wait(Id2,IdBeh) Px) == true ) .
   
  -----------------------------------------------Rules for collecting messages related to external used functions------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------

  crl [RequestsForFiringTransitions] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m((P, Ps),Ts,Tes) }) , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >  
    =>
    < nodeInventory: Idsx, 
      instances:  (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m((P, Ps),Ts,Tes) }) , Ix ,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: append(OutReqx,collectRuleFiring(Idsx,m(Ps,union(Ts, restrictTransitionsToPlace(TsBeh,P) ),Tes),
      (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m((P, Ps),Ts,Tes) }) , Ix,connectionProIdent(Id1,Cx),RcvAnsx,Hx,OutReqx)),
      history: Hx >  
    if (restrictTransitionsToPlace(TsBeh,P) =/= empty and collectRuleFiring(Idsx,m(Ps,union(Ts, restrictTransitionsToPlace(TsBeh,P) ),Tes),
    (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m((P, Ps),Ts,Tes) }) , Ix,connectionProIdent(Id1,Cx ),RcvAnsx,Hx,OutReqx) =/= nil) . 

  crl [RequestsForEnteringPlace] : 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes) })  , Ix,
      connections: Cx,
      program: Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx > 
    => 
    < nodeInventory: Idsx,
      instances: (Id1 |-> { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes  ) })  , Ix,
      connections: Cx,
      program: Px, 
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: append(OutReqx,collectRuleEnteringPlace(Idsx,Id1,placeOfStation(S,getStationPlaces(Ct)), getUsePorts(Ct), 
      { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes  ) },
      { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(placeOfStation(S,getStationPlaces(Ct)),Ps, Ts, removeTransitionEndingStation(Tes,S) ) },
      Ix,Cx,RcvAnsx,Hx,OutReqx)), 
      history: Hx > 
    if 
    ( isSatisfiedTransitionEndingStation(S,TsBeh,te(t(P,S,Ss),S), Tes)  and
      (collectRuleEnteringPlace(Idsx,Id1,placeOfStation(S,getStationPlaces(Ct)), getUsePorts(Ct), 
      { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(Ps, Ts, te(t(P,S,Ss),S), Tes) },
      { type: Ct,queueBehavior: (IdBeh ; b(TsBeh)) Qb,marking: m(placeOfStation(S,getStationPlaces(Ct)),Ps, Ts, removeTransitionEndingStation(Tes,S) ) },
      Ix, Cx,RcvAnsx,Hx,OutReqx) =/= nil )
    ) .

  crl [RequestsForDisconnectPorts] : 
    < nodeInventory: Idsx,
      instances: Ix,
      connections: (Id1,Use,Id2,pro), Cx,
      program: dcon(Id1,Use,Id2,pro) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >    
    =>  
    < nodeInventory: Idsx,
      instances: Ix,
      connections: (Id1,Use,Id2,pro), Cx,
      program: dcon(Id1,Use,Id2,pro) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: append(OutReqx,collectRuleDisconnect(Idsx,(Id1,Use,Id2,pro),RcvAnsx,Hx,OutReqx)),
      history: Hx >   
    if ( (collectRuleDisconnect(Idsx,(Id1,Use,Id2,pro),RcvAnsx,Hx,OutReqx) =/= nil) ) .

  crl [RequestsForWait] :
    < nodeInventory: Idsx,
      instances: Ix,
      connections: Cx,
      program: wait(Id1,IdBeh) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx,
      outgoingRequests: OutReqx,
      history: Hx >     
    =>  
    < nodeInventory: Idsx,
      instances: Ix,
      connections: Cx,
      program: wait(Id1,IdBeh) Px,
      receivedAnswers: RcvAnsx,
      outgoingAnswers: OutAnsx, 
      outgoingRequests: append(OutReqx,collectRuleWait(Idsx,Id1,IdBeh,RcvAnsx,Hx,OutReqx)),
      history: Hx >    
    if (collectRuleWait(Idsx,Id1,IdBeh,RcvAnsx,Hx,OutReqx) =/= nil ) .

  --------------------------------------------------------------Rules for communication---------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------
 
  rl [SendReceiveRequest] : 
    < nodeInventory: Idsx, instances: Ix, 
      connections: Cx, program: Px, 
      receivedAnswers: RcvAnsx, 
      outgoingAnswers: OutAnsx, 
      outgoingRequests: [ dst: Dst, query: Q ] OutReqx, 
      history: Hx > , 
    < nodeInventory: (Dst, Idsy), instances: Iy, 
      connections: Cy, program: Py, 
      receivedAnswers: RcvAnsy, 
      outgoingAnswers: OutAnsy, 
      outgoingRequests: OutReqy, 
      history: Hy >
    => 
    < nodeInventory: Idsx, instances: Ix, 
      connections: Cx, program: Px, 
      receivedAnswers: RcvAnsx, ---insert([dst: Dst, query: Q],noValueYet, RcvAnsx),  [dst: Dst, query: Q] |-> noValueYet, RcvAnsx) est remplacee ou bien on la supprimer c mieux modif par outgoingAnswers
      outgoingAnswers: OutAnsx, 
      outgoingRequests: OutReqx, 
      history: [dst: Dst, query: Q], Hx > ,
    < nodeInventory: (Dst, Idsy), instances: Iy, 
      connections: Cy, program: Py, 
      receivedAnswers: RcvAnsy, 
      outgoingAnswers: append(OutAnsy,[req: [dst: Dst, query: Q], value: noValueYet ]),
      outgoingRequests: OutReqy,
      history: Hy > .
    ---if not($hasMapping(RcvAnsx, [dst: Dst, query: Q])) --- vraiment nécessaire?
    
      ---if not($hasMapping(RcvAnsx, [dst: Dst, query: Q])) --- vraiment nécessaire?
    ---- on doit pas mettre cette condition si non la regle se bloque 
    --- il se fait inserer le nouveau mapping avec une valeur indeterminé
    --- dans le cas ou un map existe pour cet valeur elle sera ecrasé sa valeur booleene ou valeur indetermine par indeterminé
    --- ca valeur booleene n'est pas intersessente pour la fonction correspondante et une nouvelle recherche sur eventuellement une valeur intersesnte est en cou
    
    rl [SendReceiveEvaluation] : 
    < nodeInventory: Idsx, 
      instances: Ix, 
      connections: Cx, program: Px, 
      receivedAnswers: RcvAnsx, 
      outgoingAnswers: [req: [dst: Dst, query: Q], value: noValueYet ] OutAnsx,  
      outgoingRequests: OutReqx, 
      history: Hx > , 
    < nodeInventory: Idsy, 
      instances: Iy, 
      connections: Cy, program: Py, 
      receivedAnswers: RcvAnsy, 
      outgoingAnswers: OutAnsy, 
      outgoingRequests: OutReqy, 
      history: [dst: Dst, query: Q], Hy >
    => 
    < nodeInventory: Idsx, 
      instances: Ix, 
      connections: Cx, program: Px, 
      receivedAnswers: upDateReceivedAnswers(RcvAnsx,identInstanceConnectionWhenSendActive(Cx,[dst: Dst, query: Q],localEvaluation([dst: Dst, query: Q],Ix,Cx,Px))) ,
      outgoingAnswers: OutAnsx, 
      outgoingRequests: OutReqx, 
      history: Hx > ,
    < nodeInventory: Idsy, 
      instances: Iy, 
      connections: Cy, program: Py, 
      receivedAnswers: insert([dst: Dst, query: Q], localEvaluation([dst: Dst, query: Q],Ix,Cx,Px), RcvAnsy),
      outgoingAnswers: OutAnsy, 
      outgoingRequests: OutReqy,
      history: Hy > . 
    
    
    ---- ($hasMapping(RcvAnsx, [dst: Dst, query: Q])) --- vraiment nécessaire?
    




endm

