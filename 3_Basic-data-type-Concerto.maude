fmod PLACE is
  
  inc DECLARATION-SORTS .   
  sorts InitialPlace Places . 
  subsort InitialPlace < Place . 
  pr SET{Place} .   
  subsort Set{Place} <  Places  .  
   
endfm

fmod STATION is
  
  inc DECLARATION-SORTS .
  
  sort Stations .
  pr SET{Station} .   
  subsort Set{Station} <  Stations  . 

endfm

fmod STATION-PLACE is
  
  inc DECLARATION-SORTS . 
  inc PLACE .
  inc STATION .

  sort StationPlaces .
  pr SET{StationPlace} . 
  subsort Set{StationPlace} <  StationPlaces . 

  vars s1 s2 : Station .
  var S : Stations .
  var SPs : StationPlaces .
  var p : Place .
  var Ps : Places .

  op [_](_) : Station Place -> StationPlace [ctor] .
  --- an element StationPlace

  op getPlacefromStation(_,_) : Station StationPlaces -> [Place] .
  op not-found : -> [Place] . 
  --- get the place associated to a station 
  eq getPlacefromStation(s1, ([s1](p),SPs)) = p .
  eq getPlacefromStation(s1, SPs) = not-found [owise] . 

  op getStationsfromGroup(_,_) : Places StationPlaces -> Stations .  
  --- get the stations associated to a group of Places
  eq getStationsfromGroup(Ps,empty) = empty .
  ceq getStationsfromGroup(Ps,([s1](p),SPs)) = s1, getStationsfromGroup(Ps,SPs) if(p in Ps) .
  eq getStationsfromGroup(Ps,([s1](p),SPs)) =  getStationsfromGroup(Ps,SPs) [owise] .


endfm

--- TODO Helene only one kind of Id?
fmod ID-COMPONENT-BEHAVIOR is
  
  inc DECLARATION-SORTS . 
  
  sorts IdInstances IdBehavior  . 
  pr SET{IdInstance} .
  subsort Set{IdInstance} < IdInstances . 
  
endfm

fmod PORT is
  
  sort Port .
  sorts UsePort ProvidePort .
  subsorts UsePort ProvidePort < Port .

endfm



fmod CONNECTION is
  
  inc DECLARATION-SORTS . 
  inc ID-COMPONENT-BEHAVIOR .
  inc PORT .
  
  sort  Connections . 
  pr SET{Connection} .  
  subsort Set{Connection} < Connections . 

  var Cs : Connections .   
  vars use use1 : UsePort .  
  var pr : ProvidePort .   
  vars id id1 id2 : IdInstance .  

  op (_,_)--(_,_) : IdInstance UsePort IdInstance ProvidePort -> Connection .
  --- op (_,_,_,_) : IdInstance UsePort IdInstance ProvidePort -> Connection .  
  --- Define a new operator to create a Connection

  --- some operations related to the connections used later
  op isUseinConnections(_,_,_) :  IdInstance UsePort Connections -> Bool . 
  --- checks whether a component instance is connected via a use port
  eq isUseinConnections(id,use,((id,use)--(id2,pr),Cs)) = true  .  
  eq isUseinConnections(id,use,Cs) = false [owise] .  

  op isCInstinConnections(_,_) :  IdInstance Connections -> Bool .   
  --- checks whether a component instance is connected (via use or provide port)
  eq isCInstinConnections(id1,((id1,use)--(id2,pr),Cs)) = true .  
  eq isCInstinConnections(id2,((id1,use)--(id2,pr),Cs)) = true . 
  eq isCInstinConnections(id,Cs) = false [owise] .  

  op getPConnectionsofCInst(_,_) :  IdInstance Connections -> Connections .  
  --- get the connections of CInst where CInst is providing a port
  eq getPConnectionsofCInst(id,empty) = empty .
  eq getPConnectionsofCInst(id2,((id1,use)--(id2,pr)),Cs) = ((id1,use)--(id2,pr)), getPConnectionsofCInst(id2,Cs)  .  
  eq getPConnectionsofCInst(id,((id1,use)--(id2,pr)),Cs) = getPConnectionsofCInst(id,Cs) [owise] .  
endfm

--- TODO Fred subsort?
fmod REQUEST is

  inc ID-COMPONENT-BEHAVIOR . 
  inc PORT .
  inc CONNECTION .
  
  sorts Query .

  op isActive(_) :  Port -> Query [ctor] .  
  op isRefusing(_) : Port -> Query [ctor] .    
  op isConnected(_) : Connection -> Query [ctor] .
  op isCompleted(_) : IdBehavior -> Query [ctor] .
  op onDisconnect(_) : Connection -> Query [ctor] . 
  --- to synchronize the disconnection of reconfiguration programs  
  
  op [ dst: _ , query: _ ] : IdInstance Query -> Request [ctor] .

  
endfm


fmod ANSWER is 
  inc REQUEST . 

  op [ req: _, value: _ ] : Request Bool -> Answer [ctor] .
endfm


fmod MESSAGE is
   inc REQUEST .
   inc ANSWER .

   op reqMsg : Request -> Message [ctor] .
   op ansMsg : Answer -> Message [ctor] .

endfm


fmod TRANSITION-TRANSITION-ENDING is
  inc PLACE .
  inc STATION .
  inc DECLARATION-SORTS .
  sorts Transitions TransitionEndings .  
   
  pr SET{Transition} .
  subsort Set{Transition} < Transitions .
  
  pr SET{TransitionEnding} .
  subsort Set{TransitionEnding} < TransitionEndings . 
 
  --- TODO Helene change notations (in particular because Stations is a Set -> (,,,,,)?
  op t(_,_) : Place Stations -> Transition [ctor] .
  op te(_,_) : Transition Station -> TransitionEnding [ctor] .

  var p1 p2 : Place .
  var Ps : Places .
  vars Ss1 Ss2 : Stations .
  vars s1 s2 : Station .
  var Ts : Transitions .
  var Tes : TransitionEndings .

  --- some operations related to Transition and TransitionEnding used later
  op getSourcesOfTransitions(_) : Transitions -> Places .  
  --- get the set of source places of a set of transitions
  eq getSourcesOfTransitions(empty) = empty .
  eq getSourcesOfTransitions((t(p1,Ss1),Ts)) = p1, getSourcesOfTransitions(Ts) .

  op getTransitionsofPlace(_,_) : Transitions Place -> Transitions . 
  --- get transitions linked to a place
  
  eq getTransitionsofPlace(empty,p1) = empty .
  eq getTransitionsofPlace((t(p1,Ss1),Ts),p1) = t(p1,Ss1), getTransitionsofPlace(Ts,p1)  .
  eq getTransitionsofPlace((t(p2,Ss1),Ts),p1) = getTransitionsofPlace(Ts,p1) [owise] .
 
  --- HELENE I do not understand this remove function
  op rmTesOfStation(_,_) : TransitionEndings Station -> TransitionEndings .
  --- delete transition endings of a station 
  
  eq rmTesOfStation(empty,s1) = empty .
  eq rmTesOfStation((te(t(p1,Ss1),s1),Tes),s1) = rmTesOfStation(Tes,s1) .
  eq rmTesOfStation((te(t(p1,Ss1),s1),Tes),s2) = te(t(p1,Ss1),s1),rmTesOfStation(Tes,s2) [owise] .
  --- Helene - owise without ceq?
  
  --- Helene ??? op getTransitionsfrom
  op transitionsOfPlacesWithRespectToStations(_,_,_) : Places Transitions Stations -> Transitions .   
 ---retrieve transitions starting from a place of a set of places and ending in stations included in the set of stations of these places.
  
  eq transitionsOfPlacesWithRespectToStations(Ps,empty,Ss1) = empty .
  ceq transitionsOfPlacesWithRespectToStations(Ps,(t(p1,Ss2),Ts),Ss1) = t(p1,Ss2), transitionsOfPlacesWithRespectToStations(Ps,Ts,Ss1) if ((p1 in Ps) and (Ss2 subset Ss1)) .
  eq transitionsOfPlacesWithRespectToStations(Ps,(t(p1,Ss2),Ts),Ss1) = transitionsOfPlacesWithRespectToStations(Ps,Ts,Ss1) [owise] .
 
  op getEndingsofTransition(_,_) : Transition Stations -> TransitionEndings .  
  ---get the transition endings of a transition according to a set of Stations
  eq getEndingsofTransition(t(p1,Ss2),empty) = empty . 
  eq getEndingsofTransition(t(p1,Ss2), (s1,Ss1)) = union(te(t(p1,Ss2),s1), getEndingsofTransition(t(p1,Ss2), Ss1) ) .


  op getEndingsfTransitions(_) : Transitions -> TransitionEndings .  
  --- get the transition endings of a set of transitions
  eq getEndingsfTransitions(empty) = empty .
  eq getEndingsfTransitions(t(p1,Ss1),Ts) = union(getEndingsofTransition(t(p1,Ss1),Ss1), getEndingsfTransitions(Ts) ) .


  --- Helene ???
  op isSatisfiedTransitionEndingStation(_,_,_) : Station Transitions TransitionEndings -> Bool .
  --- is used in the entering place rule
  --- the parameters used are : a chosen station, the current transitions of a behavior and the transition endings of the instance concerned
  --- the principale is : if a station is chosen as a station of the ending of a transition 
  --- then for all transitions of the current behavior for which the chosen station is one of its stations
  --- the transition endings of these transitions according to this station must be included in their trnasition endings.
  eq isSatisfiedTransitionEndingStation(s1,empty,Tes) = true .
  ceq isSatisfiedTransitionEndingStation(s1,t(p1,Ss1),Ts,Tes) = isSatisfiedTransitionEndingStation(s1,Ts,Tes) 
  if(not(s1 in Ss1) or (te(t(p1,Ss1),s1) in Tes) ) .
  eq isSatisfiedTransitionEndingStation(s1,t(p1,Ss1),Ts,Tes) = false [owise] .

endfm

--- TODO Fred projection to remove
fmod MARKING is
  inc TRANSITION-TRANSITION-ENDING .
  sort Marking . 
  
  vars Ps1 Ps2 : Places .
  vars Ts1 Ts2 : Transitions .
  vars Tes1 Tes2 : TransitionEndings .
  
  op m(_,_,_) : Places Transitions TransitionEndings -> Marking [ctor] .
  
  op placesOfMarking : Marking -> Places . 
  ---- gives the places of a marking
  eq placesOfMarking(m(Ps1,Ts1,Tes1)) = Ps1 .

  op transitionsOfMarking : Marking -> Transitions . 
  --- gives the transitions of a marking
  eq transitionsOfMarking(m(Ps1,Ts1,Tes1)) = Ts1 .

  op transitionEndingsOfMarking : Marking -> TransitionEndings . 
  --- gives the transition endings of a marking
  eq transitionEndingsOfMarking(m(Ps1,Ts1,Tes1)) = Tes1 .

  op  intersectionMarkings(_,_) : Marking Marking -> Marking . 
  --- intersection of two markings
  eq  intersectionMarkings(m(Ps1,Ts1,Tes1),m(Ps2,Ts2,Tes2)) = 
  m(intersection(Ps1,Ps2),intersection(Ts1,Ts2),intersection(Tes1,Tes2)) .

  op notEmptyMarking(_) : Marking -> Bool .  
  ---to check if a given Marking is empty
  eq notEmptyMarking(m(Ps1,Ts1,Tes1)) = (Ps1 =/= empty or Ts1 =/= empty or Tes1 =/= empty ) .

endfm

fmod BEHAVIOR is
  
  inc TRANSITION-TRANSITION-ENDING .
  inc ID-COMPONENT-BEHAVIOR .

  pr DECLARATION-SORTS .
  sorts Behaviors .  
  pr SET{Behavior} .
  subsort Set{Behavior} < Behaviors .  
  pr LIST{BehaviorWithId} .
  --- List{BehaviorWithId} est une liste pour les element de sort BehaviorWithId 

  vars IdBehx IdBehy : IdBehavior .
  var BehL : List{BehaviorWithId} .
  var Beh : Behavior .

  op b(_) : Transitions -> Behavior .   
  ---a behavoir is a set of transitions

  --- Helene the pushB(id,b) is identified not the behavior itself
  op (_;_) : IdBehavior Behavior -> BehaviorWithId . 
  ---BehaviorWithId is an identified behavior

  op isBehaviorinList(_,_) : IdBehavior List{BehaviorWithId} -> Bool .
  ---to check if a behavior identifier exists in the behavior list  
  eq isBehaviorinList(IdBehx, nil) = false .
  eq isBehaviorinList(IdBehx, (IdBehx ; Beh) BehL) = true .
  eq isBehaviorinList(IdBehx, (IdBehy ; Beh) BehL) = isBehaviorinList(IdBehx,BehL) [owise] .

endfm
