------- some ops used in the operating rules to determine messages 
------- related to the remote evaluation of queries whose result 
------- is used locally

fmod COLLECT-EXTERNAL-MESSAGES-FIRING is

  inc CONCERTO-D-CONFIGURATION .

  var Ids : Ids . 
  var Is : Instances .
  var Cs : Connections .
  var Val : Bool .
  var Use : UsePort .
  var Pro : ProvidePort .
  vars Id1 Id2 : Id .
  var NewM : Marking .
  var eState : Map{Question,Bool} .
  var H : Set{Question} .
  var OutReq : List{Question} .

  op collectMsgFiring(_,_,_,_,_,_,_) : Ids Marking Instances Connections Map{Question,Bool} Set{Question} List{Question} -> List{Question} .
  --- used to determine msg related to external functions that allow to apply the rule firing transition. 
  --- it aims to build a queue of external [ dst: Id1 , query: isActive(Use) ]  messages for use ports whose current valuation in Map{Question,Bool} does not allow the rule to be applied; 
  --- in other words, the evaluation of these messages is true or noValueYet 
  --- knowing that the provide port linked to thier use port wants to change the status of its provide port from active to inactive.
  --- in this case, we add the message [ dst: Id1 , query: isActive(Use) ]  of each use port to the queue of external information, 
  --- on condition that the request for this message is not currently being processed.
  --- this last condition is verified if [ dst: Id1 , query: isActive(Use) ]  doesn't belong to either Set{Question} or List{Question}.
  eq collectMsgFiring(Ids, NewM, Is, empty, eState, H, OutReq) = nil .
  ceq collectMsgFiring(Ids, NewM, Is, (Id1, Use)--(Id2, Pro), Cs, eState, H, OutReq) = 
  append([ dst: Id1 , query: isActive(Use) ], collectMsgFiring(Ids,NewM,Is,Cs,eState,H,OutReq))
  if
  (   
  (not [ dst: Id1 , query: isActive(Use) ]  in H) and 
  (not (occurs([ dst: Id1 , query: isActive(Use) ], OutReq)))  and
  (not (Id1 in Ids)) and
  (question([ dst: Id1 , query: isActive(Use) ], Ids, eState, empty, empty, nil) =/= false) and
  ((localQuestion([ dst: Id2 , query: isActive(Pro)], Is, empty, nil) == true) and (activeMarking(Is[Id2],Pro,NewM) == false))
  ) .
  eq collectMsgFiring(Ids,NewM,Is,(Id1,Use)--(Id2,Pro),Cs,eState,H,OutReq) = collectMsgFiring(Ids,NewM,Is,Cs,eState,H,OutReq) [owise] .


endfm


--- we follow a similar reasoning to construct the messages for the external functions 
--- needed to apply the rules: entering place, wait and disconnect.
fmod COLLECT-EXTERNAL-MESSAGES-ENTERING-PLACE is

  inc CONCERTO-D-CONFIGURATION .

  var P : Place .
  var Ps : Places .
  var GU :  GroupUses .
  vars I I' : Instance .
  var Is : Instances .
  var Cs : Connections .
  var eState : Map{Question,Bool} .
  var Use : UsePort .
  var Pro : ProvidePort .
  vars Id1 Id2 : Id .
  var H : Set{Question} .
  var OutReq : List{Question} .  
  var Ids : Ids .   

  op collectMsgEnteringPlace(_,_,_,_,_,_,_,_,_,_,_) : 
  Ids Id Place GroupUses Instance Instance Instances Connections Map{Question,Bool} Set{Question} List{Question} -> List{Question} .
  eq collectMsgEnteringPlace(Ids,Id1,P,empty,I,I',Is,Cs,eState,H,OutReq) = nil .
  ceq collectMsgEnteringPlace(Ids,Id1,P,g(Use ? Ps),GU,I,I',Is,Cs,eState,H,OutReq) = 
  append(collectConnected(Ids,Use,Id1,Cs,eState,H,OutReq),append(collectAllowed(Ids,Use,Id1,Is,Cs,eState,H,OutReq), collectMsgEnteringPlace(Ids,Id1,P,GU,I,I',Is,Cs,eState,H,OutReq))) 
  if  ((P in Ps) and isActiveLocal(I,Use) == false and isActiveLocal(I',Use) == true  ).   
  eq collectMsgEnteringPlace(Ids,Id1,P,g(Use ? Ps),GU,I,I',Is,Cs,eState,H,OutReq) = collectMsgEnteringPlace(Ids,Id1,P,GU,I,I',Is,Cs,eState,H,OutReq) [owise] .

  op collectConnected(_,_,_,_,_,_,_) : Ids UsePort Id Connections Map{Question,Bool} Set{Question} List{Question} -> List{Question} . 
  ceq collectConnected(Ids,Use,Id1,(Id1,Use)--(Id2,Pro),Cs,eState,H,OutReq) = [ dst: Id2 , query: isConnected((Id1,Use)--(Id2,Pro)) ] 
  if(
    (not ([ dst: Id2 , query: isConnected((Id1,Use)--(Id2,Pro)) ]  in H)) and 
    (not (occurs([ dst: Id2 , query: isConnected((Id1,Use)--(Id2,Pro)) ],OutReq)))  and
    (not (Id2 in Ids)) and
    ( externQuestion([ dst: Id2 , query: isConnected((Id1,Use)--(Id2,Pro)) ],eState )   =/= true )
    ) .
  eq collectConnected(Ids,Use,Id1,Cs,eState,H,OutReq) = nil [owise] .

  op collectAllowed(_,_,_,_,_,_,_,_) : Ids UsePort  Id Instances Connections Map{Question,Bool} Set{Question} List{Question} -> List{Question} . 
  ceq collectAllowed(Ids,Use,Id1,Is,((Id1,Use)--(Id2,Pro)),Cs,eState,H,OutReq) = [ dst: Id2 , query:  isRefusing(Pro) ] 
  if (
      (not [ dst: Id2 , query:  isRefusing(Pro) ] in H) and 
      (not (occurs([ dst: Id2 , query:  isRefusing(Pro) ],OutReq)))  and
      (not (Id2 in Ids)) and  
      ( externQuestion([ dst: Id2 , query:  isRefusing(Pro) ],eState)   =/= false)   
    ) .
  eq collectAllowed(Ids,Use,Id1,Is,Cs,eState,H,OutReq) = nil [owise] .

endfm

fmod COLLECT-EXTERNAL-MESSAGES-WAIT is

  inc CONCERTO-D-CONFIGURATION .

  var Val : Bool .
  var Id1 : Id .
  var IdB : Id .
  var eState : Map{Question,Bool} .
  var H : Set{Question} .
  var OutReq : List{Question} .
  var R : Question .
  var Ids : Ids .   

  op collectMsgWait(_,_,_,_,_,_) : Ids Id Id Map{Question,Bool} Set{Question} List{Question} -> List{Question} .
  ceq collectMsgWait(Ids,Id1,IdB,eState,H,OutReq) = [ dst: Id1 , query:  isCompleted(IdB) ] 
  if(
    (not ([ dst: Id1 , query:  isCompleted(IdB) ]   in H)) and 
    (not (occurs([ dst: Id1 , query:  isCompleted(IdB) ] ,OutReq)))  and
    (not (Id1 in Ids)) and
    (externQuestion([ dst: Id1 , query:  isCompleted(IdB) ],eState)   =/= true )
    ) .
  eq collectMsgWait(Ids,Id1,IdB,eState,H,OutReq) = nil [owise] .

endfm

fmod COLLECT-EXTERNAL-MESSAGES-DISCONNECT is

  inc CONCERTO-D-CONFIGURATION .

  var Val : Bool .
  var Use : UsePort .
  var Pro : ProvidePort .
  vars Id1 Id2 : Id .
  var eState : Map{Question,Bool} .
  var H : Set{Question} .
  var OutReq : List{Question} .
  var R : Question .
  var Ids : Ids . 
  var C : Connection .  

  op collectMsgDisconnect(_,_,_,_,_) : Ids Connection Map{Question,Bool} Set{Question} List{Question} -> List{Question} .
  ceq collectMsgDisconnect(Ids,((Id1,Use)--(Id2,Pro)),eState,H,OutReq) =
   append(collectActive(Id1,Use,eState,H,OutReq),(collectDisconnect(Id1,((Id1,Use)--(Id2,Pro)),eState,H,OutReq))) 
  if (not (Id1 in Ids) ) .
  ceq collectMsgDisconnect(Ids,((Id1,Use)--(Id2,Pro)),eState,H,OutReq) = 
  collectDisconnect(Id2,((Id1,Use)--(Id2,Pro)),eState,H,OutReq) 
  if (not (Id2 in Ids) ) .
  eq collectMsgDisconnect(Ids,((Id1,Use)--(Id2,Pro)),eState,H,OutReq) = nil [owise] .

  op collectActive(_,_,_,_,_) : Id UsePort Map{Question,Bool} Set{Question} List{Question} -> List{Question} .
  ceq collectActive(Id1,Use,eState,H,OutReq) = [ dst: Id1 , query: isActive(Use) ] 
  if(
    (not ([ dst: Id1 , query: isActive(Use) ]   in H)) and 
    (not (occurs([ dst: Id1 , query: isActive(Use) ] ,OutReq)))  and
    (externQuestion([ dst: Id1 , query: isActive(Use) ],eState )  =/= false )
    ) .
  eq collectActive(Id1,Use,eState,H,OutReq) = nil [owise] .

  op collectDisconnect(_,_,_,_,_) : Id Connection Map{Question, Bool} Set{Question} List{Question} -> List{Question} .
  ceq collectDisconnect(Id1,C,eState,H,OutReq) = [ dst: Id1 , query: onDisconnect(C) ] 
  if(
    (not ([ dst: Id1 , query: onDisconnect(C) ]   in H)) and 
    (not (occurs([ dst: Id1 , query: onDisconnect(C) ], OutReq))) and
    (externQuestion([ dst: Id1 , query: onDisconnect(C) ], eState ) =/= true )
    ) .
  eq collectDisconnect(Id1,C,eState,H,OutReq) = nil [owise] .

endfm



